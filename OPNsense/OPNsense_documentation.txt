
Introduction

Welcome to the OPNsense documentation & wiki project! The documentation is work in progress and is updated frequently. If you would like to contribute in anyway, please take a look at our guide how to Contribute.
_images/opnsense_logo-zilver_grijs.png
Welcome to OPNsense’s documentation!

OPNsense® is an open source, easy-to-use and easy-to-build FreeBSD based firewall and routing platform.

OPNsense includes most of the features available in expensive commercial firewalls, and more in many cases. It brings the rich feature set of commercial offerings with the benefits of open and verifiable sources.
Mission Statement

    Give users, developers and businesses a friendly, stable and transparent environment. Make OPNsense the most widely used open source security platform. The project’s name is derived from open and sense and stands for: “Open (source) makes sense.”

_images/OPNsense-Deciso-Screenshot.jpg
Reading guide

While reading the documentation, it’s good to know how the various topics are structured, what their purpose is and how to find what you’re looking for. Maybe even more important is what this documentation doesn’t offer.

If you’re looking for deeper insights about networking and best practices in designing them, this might not be the best place to look. Most of our documents and how-to’s focus on how to use functionality included in our software and/or one of it’s plugins. Quite some books are written about networking, there are (online) courses available and wikipedia contains a lot of relevant articles as well. Some interesting reads include the fundamentals about the OSI model, IP addressing, routing and network address translation. Likely these resources are more suitable for learning about general network concepts. Although we do try to include some context in our documents, there are often assumptions made about the readers knowledge on (basic) networking.

Like many products and projects, ours grows over time, functionality extends and changes, which sometimes makes it difficult to find what you need for the version you’re using. Although we try to keep our documentation up to date, sometimes text doesn’t reflect reality anymore. If that’s the case and you think you found an omission, don’t hestitate to open a report using one of our templates on GitHub or a pull request of course if you’re able to.

Always assume the text is intended for the latest version of our product, in time we might add a version selector in the documentation, but given OPNsense is a security product, we advise to keep it up to date anyway to protect yourself against the latest threats.

The releases section contains the changelogs for all versions we published over the years, if there are remarks for an upgrade, this is a useful resource to collect the details.

Installation and setup is all about getting you started using one of the target options available.

The next sections should be quite familiair when working with OPNsense, as they reflect the options in the menu of the product. In case you’re not yet used to OPNsense, you can always use the search input in the left corner of the screen to find your topic.

Both community and third-party plugins have their own area available, although they eventually register into the same menu structure, it’s good to know about possible differences between add-ons and standard functionality. The level of support may differ between core functionality, as also explained in the “Support options” section, feature requests and bugs maybe treated different as well (a lot of questions for a plugin which is being developed by a single person, maybe less active than a group of people improving a plugin together for example).

When it comes to building software on top of OPNsense or extending existing functionality, the development chapter is the one to read. It explains all about our architecture, coding style, how to hook into available facilities and much more.

Some pointers when it comes to troubleshooting can be found in the section with the same name, it explains a bit about our issue workflow and some tips we collected over the years.

Last but not least our documentation includes some pages around project relations, legal guidelines and ways to contribute to the project.
Feature set

The feature set of OPNsense includes high-end features such as forward caching proxy, traffic shaping, intrusion detection and easy OpenVPN client setup. The latest release is based on a recent FreeBSD for long-term support and uses a newly developed MVC-framework based on Phalcon. OPNsense’s focus on security brings unique features such as easy to use one time password authentication for various components.

The robust and reliable update mechanism gives OPNsense the ability to provide important security updates in a timely fashion.
OPNsense Core Features

    Traffic Shaper

    Captive portal

        Voucher support

        Template manager

        Multi zone support

    Forward Caching Proxy

        Transparent mode supported

        Blacklist support

    Virtual Private Network

        Site to site

        Road warrior

        IPsec

        OpenVPN

    High Availability & Hardware Failover

        Includes configuration synchronization & synchronized state tables

        Moving virtual IPs

    Intrusion Detection and Inline Prevention

        Built-in support for Emerging Threats rules

        Simple setup by use of rule categories

        Scheduler for period automatic updates

    Built-in reporting and monitoring tools

        System Health, the modern take on RRD Graphs

        Packet Capture

        Netflow

    Support for plugins

    DNS Server & DNS Forwarder

    DHCP Server and Relay

    Dynamic DNS

    Backup & Restore

        Encrypted cloud backup to Google Drive and Nextcloud

        Configuration history with colored diff support

        Local drive backup & restore

    Stateful inspection firewall

    Granular control over state table

    802.1Q VLAN support

    and more…

Security

Index

    Security

        Intro

        Staying ahead

        Upstream vulnerabilities

        Reporting an incident

        Information handling policies

        Third party security verification

            Intro

            Business Edition

            Framework / Type of testing (LINCE)

            Steps in the process

            Timeline

            Results

            External references

Intro

As your trusted opensource security product, we do care a lot about security and with our regular release schedule we try to stay ahead of possible incidents. Even though we are cautious and stay informed, sometimes issues do occur, in which case it’s good to know what to do.
Staying ahead

Even though we always encourage people to update regularly, sometimes it’s not possible to do so for various reasons.

Luckily OPNsense comes with an integrated security check for known vulnerabilities, which can be found in our firmware module. In which case you do have the opportunity to validate for yourself what the risk is to keep using the current version for a bit longer.

You can reach it via System -> Firmware in the status pane, the button “Run an Audit” will bring you right into the security report.

If all goes well, a report like the one below will be shown:

***GOT REQUEST TO AUDIT SECURITY***
Currently running OPNsense 22.1.8_1 (amd64/OpenSSL) at Tue May 31 09:01:04 CEST 2022
vulnxml file up-to-date
0 problem(s) in 0 installed package(s) found.
***DONE***

Note

We do not offer community support on assessing if incidents on older versions do warrant an immediate upgrade on your end as this often depends on features used and settings configured. Our advise always will be to upgrade into the latest community or business version.

Warning

Please don’t report issues to us reported by the security health check, they are already known and highly likely a fix is pending for the next release.
Upstream vulnerabilities

Since OPNsense is a collection of opensource software, when finding an issue, it is always a good idea to inspect where is should be fixed first. In case you don’t know or aren’t sure, you can still ask on our end, just know that we don’t have the manpower to act as an intermediate between various projects.
Reporting an incident

Security incidents on our product can be reported to our security team available at security @ opnsense.org.

All reports should contain at least the following information:

    A clear description of the vulnerability at hand

    Which version(s) of our product seem to be affected

    Any known workaround

    When possible, some example code

Information handling policies

As a general policy we do favor full disclosure of vulnerability information after a reasonable amount of time to permit safe analysis and correction as well as appropriate testing for the correction at hand.

In order to coordinate with other affected parties, we might share parts of the information provided to us to them as well or ask the reporter to do so.

When the submitter is interested in a coordinated disclosure process, this should be indicated in any submission to avoid discussions later on.
Third party security verification
Intro

Within the OPNsense team and community we spend a lot of time safeguarding our software and keeping up with the latest threats, like checking used software against CVE’s on every release, implementing best practices in our development methods and offering clear and transparent release engineering.

To even improve this further, we decided to bring a third party on board and mold a process around our security verification by trained security professionals.
Business Edition

As our business edition is aimed at professional users, it does make sense to offer additional safeguards, like even more extensive testing on this product. Looking at the lifecycle of our software, this is also the most mature stage of what we do have to offer:

    Development version

        Available at every release, offers a glimpse of what to expect in the near future

    Community version

        When changes survive the development version, these are included in the community version, these are internally tested and feedback has been offered by community members.

    Business Edition

        Functional changes are being included in a more conservative manner, more feedback has been collected from development and community, leading to a mission critical version of your well known OPNsense firewall.

As security testing is quite time-consuming, we aim to offer a full qualification cycle at every major release.
Framework / Type of testing (LINCE)

In our quest for a framework to use, we found the LINCE methodology.

LINCE is a lightweight methodology for evaluating and certifying ICT products, created by Spain’s National Cryptologic Center (CCN), based on Common Criteria principles and oriented to vulnerability analysis and penetration tests.

LINCE strengths over other methodologies mainly consist of reduced effort and duration. However, the way in which it is applied also makes it possible to pay more attention to the critical points of each product, giving more weight to concrete and practical tests that combat real threats than to dense documentation or exhaustive functionality tests.

As most frameworks are not intended to be repeated very regularly, together with jtsec we came up with an approach which makes it possible to pass the test twice a year, which is needed to align with our Business Edition releases.

During every cycle, there’s always a chance that (small) issues appear which should be fixed, in close accordance with jtsec, the OPNSense team prepares fixes for the findings and makes sure that these are included in a future (minor) release.
Steps in the process

To better understand where a version of OPNsense is at in terms of verification, we distinct the following stages in the process, which we will also note on the version at hand.

    In test - Software delivered to jtsec, in process (interaction between OPNsense and jtsec).

    Tested - Software verified / tested, documentation not yet published.

    LINCE Compliant - Test complete including summarised report (by jtsec)

    Certification pending - Offered for formal certification. (as of 2023)

    LINCE Certified - Certified by CCN (as of 2023)

The certification steps are planned to be executed once a year starting in 2023, this process is quite time consuming, but adds another independent party to the mix.
Timeline

The first fully certified product has been a community version (21.7.1), which offered us insights into the process and helped us improve the process which we would like to use for the business edition. We started this cycle with version 22.4 including full testing by jtsec and made plans for the future.
Results

Below you will find the versions that have been tested or are currently in test.

Version
	

status
	

Download

BE 24.04
	

In test
	

BE 23.10
	

LINCE Compliant / Certification pending
	

BE23.10-STIC_OPNSENSE_CQ-ETR-v1.0.pdf 3cd1135bee4c17299d4740c10ed9ef965b77be6e3899cc1c7587b9578930ea51

BE 23.04
	

LINCE Compliant
	

BR23.04-STIC_OPNSENSE_CQ-ETR-v3.1.pdf 9cce20526a25de2f03b29dcb80df8277eac4eb02066e504396c07e0caffd104e

BE 22.10
	

LINCE Compliant
	

BE22.10-STIC_OPNSENSE_CQ-ETR-v2.0.pdf 6fae801d18c3c8574ab8cca9a6f03f8b898dbe8a22136ee8fc8aa01173539fb4

BE 22.04
	

LINCE Compliant
	

BE22.04-STIC_OPNSENSE_CQ-ETR-v1.0.pdf 5b303285f3b9f9cd6290a623d7c509e48c59da4c678884a1513e84ee7d06d5d1


Releases
_images/ideas_join_the_development.jpg

    Community Edition
        24.7 “Thriving Tiger” Series
        24.1 “Savvy Shark” Series
        23.7 “Restless Roadrunner” Series
        23.1 “Quintessential Quail” Series
        22.7 “Powerful Panther” Series
        22.1 “Observant Owl” Series
        21.7 “Noble Nightingale” Series
        21.1 “Marvelous Meerkat” Series
        20.7 “Legendary Lion” Series
        20.1 “Keen Kingfisher” Series
        19.7 “Jazzy Jaguar” Series
        19.1 “Inspiring Iguana” Series
        18.7 “Happy Hippo” Series
        18.1 “Groovy Gecko” Series
        17.7 “Free Fox” Series
        17.1 “Eclectic Eagle” Series
        16.7 “Dancing Dolphin” Series
        16.1 “Crafty Coyote” Series
        15.7 “Brave Badger” Series
        15.1 “Ascending Albatross” Series
    Business Edition
        24.4 Series
        23.10 Series
        23.4 Series
        22.10 Series
        22.4 Series
        21.10 Series
        21.4 Series
        20.7 “Legendary Lion” Series
        20.1 “Keen Kingfisher” Series
        19.7 “Jazzy Jaguar” Series
        19.1 “Inspiring Iguana” Series


Business Edition
_images/pexels-field-engineer-442152.jpg

A mission critical version of the well-known OPNsense firewall.

The Business Edition offers additional safeguards where functional changes are being included in a more conservative manner and feedback has been collected from development and community.

Offering specific business-oriented features and third party security verification. Currently, the only open source LINCE compliant firewall.

    Mission critical

    LINCE compliant (security verification by trained third party independent professionals)

    Commercial firmware repository

    Free GeoIP database

    Official OPNsense Open Virtualisation Image

    Central Management, including easy one click remote host access, provisioning and monitoring.

    Web Application Firewall

    Free E-Book (English & German)

More information:

    Central Management
    Web Application Firewall
    Extended Blocklists


Central Management

As part of the OPNsense Business Edition, Deciso offers a plugin to keep all your firewalls up to date and have an easy entry point to manage them.

Index

    Central Management

        Installation

        Register new hosts

            Central WebGui certificate management

            Alter generic host settings

        Centralized backups

        Multi tenancy using host groups

        Connect to managed machine

        Machine firmware status / upgrade

        Machine service status and control

        Machine resource status

        Provisioning / sharing settings

        Provisioning classes

            Users & Groups

            Aliases (Firewall)

            Firewall rules

            NAT (Firewall)

            Firewall categories

            WebGui (Administration)

        Configuration Tutorials

            Automatic WebGUI Login

Installation

After acquiring a license, you can switch to the commercial software repository containing OPNcentral. In order to install, just go to System->Firmware->Plugins and search for os-OPNcentral.
Register new hosts

Before adding a host, you need to generate an API key and secret from the machine you will grant accesss to. API keys are managed in the user manager (system_usermanager.php), go to the user manager page and select a user. Somewhere down the page you will find the API section for this user.

Click on the + sign to add a new key. When the key is created, you will receive a (single download) with the credentials in one text file (ini formatted). The contents of this file look like this:

key=w86XNZob/8Oq8aC5r0kbNarNtdpoQU781fyoeaOBQsBwkXUt
secret=XeD26XVrJ5ilAc/EmglCRC+0j2e57tRsjHwFepOseySWLM53pJASeTA3

Next go to the Hosts section of the management menu in Management ‣ Host ‣ Configuration and add a new host, copy the url from the machine and the API key and secret generated above.

Note

You can disable certificate validation if your using a self-signed certificate, although we advise to generate proper certificates for the machines.
../../_images/OPNcentral_hosts.png Icons
Group membership
Download configuration (or all as a zip file)
Edit host configuration
Clone host configuration
Delete host configuration

Central WebGui certificate management

The host configuration offers an option to link a central certificate to the managed host, in which case the certificate will be distributed to the host (if WebGui is being provisioned).

Using this feature, you’re able to centrally manage certificates (manually or using ACME) easily.

Tip

Add OPNcentral - provision / reconfigure remote hosts in System ‣ Settings ‣ Cron with a daily schedule to automatically provision all attached firewalls on a daily basis.

Attention

Do not synchronize Certificates and WebGUI at the same time. Provisioning classes WebGUI
Alter generic host settings

The second tab in the screen contains the setting page which configures defaults for all hosts where applicable.

Option
	

Description

Interfaces
	

Select the interfaces of the central node that would be used when merging settings on the remote firewall, only applicable on part of the configuration sections (such as the firewall). See the provisioning section for more details.

Enable backups
	

Enable centralized backups.

Backups:
	

    Sequential count

	

Number of sequential backups to preserve from remote host (per host), copy of local history to a maximum of X per host.

    Interval type

	

When an interval is provided, this option determines the period for the interval. e.g. when weekly is specified, each last record of the week is preserved to a maximum of the number of intervals

    Interval count

	

Non sequential number of backups to keep, last backup of specified interval type is preserved for the number of items specified here.
Centralized backups

When “Enable backups” is checked in the generic host settings tab OPNcentral will perform a nighly backup of all configured hosts. The host overview (Management ‣ Host ‣ Configuration) shows the number of backups with their related size and last modification date for each host.

Note

The modification date defines the last time the remote host was changed, so if a host hasn’t been changed for a longer period of time this value would show an older date.

Tip

It is possible to execute the backup manually from the gui. In order to do that, go to Management ‣ Host ‣ Configuration and press the Execute backup button.

Tip

If more frequent backups are desired, just add a cron job in System‣Settings‣Cron for the task OPNcentral - backup remote hosts.
Multi tenancy using host groups

Hosts can be organised in groups using the Management ‣ Host ‣ Groups menu option. By default hosts are accessible by all users having access to the specified OPNcentral menu options. You can change that behaviour by linking a host into one or more groups, where you can constrain access.

Warning

When attaching a host to multiple host groups and want to constraint access, make sure you limit all host groups to avoid accidental access for all OPNcentral users.
Connect to managed machine

On various management pages there are direct links available to login to the firewall in question. Usually connected nodes are shown with a link which opens in a new tab when clicking.

The example below shows a link in the firmware status page which will open https://node1.opnsense.local.
../../_images/OPNcentral_status_uptodate.png

When the management server is allowed to access the OPNcentral components on the connected node it will automatically login after the link is clicked with the proper credentials assigned to the api token user.

If the latests Business Edition is installed on the managed machine, but access prohibits automatic logins, you will be redirected to the login page.

When the connected machine is not using the business edition, it’s not possible to use the link, a message such as the following will be presented to the user:
../../_images/OPNcentral_auto_login_unavailable.png

Note

Make sure your browser trusts the remote node otherwise the browser can’t access the machine and will signal an issue with the software version.
Machine firmware status / upgrade

All connected and enabled machines can be contacted using the Management ‣ Status ‣ Firmware page, when visiting the page all connected machines will automatically be contacted to report their status and installed version.
../../_images/OPNcentral_status_toupdate.png

When an update is available, it will be shown in the list, including if this upgrade requires a reboot. The upgrade button starts the upgrade procedure, but will only upgrade machines that will require a reboot if Enable reboot is checked.

Tip
Use the refresh button to request status again.

The upgrade wheel starts spinning when an upgrade was requested, since the upgrade itself can consume some time, you can revisit the status page later (or press refresh) to show the new status.
Machine service status and control

The service status and control page provides an overview on all managed OPNsense firewalls connected to OPNcentral and offers the ability to restart services when needed.
../../_images/OPNcentral_service_status_overview.png

In the screenshot above there are 7 machines managed by OPNcentral, for every configured service there’s an icon reflecting the status of the service.
Stopped (inactive, but configured)
Running (active)
Host unreachable or misconfigured

When you click one of the service icons, the icon changes into a checkbox which can be used to restart the selected services with the button below the table.

Tip

The link in the host column brings you directly into the service control page of the selected firewall.
Machine resource status

In order to gain insights into the managed machines there is a resource page available which queries all connected firewalls and reports aggregated status about them.

While collecting data for a machine there’s a spinner visible, as soon as information is collected you can view relevant information per node.
../../_images/OPNcentral_resources_host.png

From left to right the following information is available:

    Host information

        Host name (description)

        Version installed

        Processor type

        Most recent configuration change (tooltip uncovers who made the change and from which module)

    General statistics

        Current cpu usage (total percentage)

        Total memory usage

        Swap file usage

        Total interfaces configured (up/down)

        Aggregated HA status (when configured), MASTER when all interfaces are, BACKUP when at least one is demoted to BACKUP

        Root file system usage

        Gateway status including maximum delay

    Firewall

        State table usage

        Alias usage (when over 100% the requested entries don’t fir in memory)

        Source tracking table usage

        Current traffic in/out, tooltip the piechart to show protocol name (or number) with current rate

Tip

When headings are underlined, a click brings you to the relevant module of the firewall in question.
Provisioning / sharing settings

The provisioning tool offers the ability to configure some settings in a more centralised manner. Inspired by the functionality that is offered for high-availability setups, you can distribute global settings among all connected firewalls for various configuration options. The central host acts as a template in this case.

In order to configure the settings that should be shared, you can configure the “classes” to synchronize in the host settings Management ‣ Host ‣ Configuration.
../../_images/OPNcentral_provisioning_host_classes_setup.png

Here you will find the same options as are available under System->High Availability->Settings. After configuring the desired parameters, you can use the Provisioning page (Management ‣ Provisioning) to inspect status and push options to the attached firewalls.

Warning

Be very careful pushing settings to your connected firewall which may disconnect your session, such as firewall and routing related options. The central management host can’t predict if settings you plan to make lead to an inaccesible firewall.

Tip

Add OPNcentral - provision / reconfigure remote hosts in System ‣ Settings ‣ Cron with a daily schedule to automatically provision all attached firewalls on a daily basis.

All provisioning classes known by the management machine will be shown in the table, combined with the status of each section. OPNcentral calculates if settings are equal, keeps track of changes and restarts related services when needed.
../../_images/OPNcentral_provisioning_status.png

You can either selectlively reconfigure specific hosts with the checkbox or reconfigure all at once on command.
Collecting status
Class equals this machine (nothing todo)
Changes ready to commit
Unknown yet configured class
Unable to connect

Provisioning classes

By default merging configuration items from the central firewall overwrites the settings on the target machine, but in some cases we need a more practical approach to deal with local modifications.

In this chapter we are going to describe how classes with special implemenations are being treated on synchronisation and how to utilise this behaviour to ease management.
Users & Groups

When users and groups are synchronized, the existing api key+secret is merged into the user with the same name to prevent access issues after reconfigure. To avoid issues, make sure there’s a unique username with proper credentials before using the synchronization.

Note

Although quite some setups will likely use external authentication options available in OPNsense, sometimes it’s practical to share the same user database among different firewalls. This option allows for sharing, without the need to sue the same key+secret on all connected firewalls.
Aliases (Firewall)

Since various firewall sections depend on aliases, OPNcentral checks if aliases are used before removing local aliases from the remote firewall.

Due to this powerful feature, after synchronisation of the central aliases you can also use nesting to combine remote aliases into new local ones.

For example, when the local machine has local_alias_1 and the central location offers central_alias_1 when both are combined into local_alias_2 and local_alias_2 is used in firewall/nat rules it will automatically merge central changes after a reconfigure action from the dashboard.

Note

As long as local_alias_2 is used, both local_alias_1 and local_alias_2 will be preserved after provisioning.
Firewall rules

Merging the firewall rules will keep the interfaces unaltered which don’t exists on the central node as these are being provided to the target firewall. In case you want to exclude some interfaces (for all remote firewalls), you can easily override the known interfaces in Management -> Host configuration on the General settings tab.

Since there’s an explicit order in which different types of rules are being handled, you can choose if you want to prefer central rules being matched first or last depending on the type of “interface” to use.

Tip

When forcing interface groups to the backup node, these will precede interface rules such as LAN and WAN, when only sending over interface groups the remote firewall is able to allow traffic which would otherwise be rejected.

Note

When multiple interfaces are attached to a (floating) rule, these will be removed by the provisioning algorithm as the intend isn’t fully clear in these matters.

Note

Rules on the central node which do apply to all interfaces or a selection of interfaces are always being send to the remote firewall. When this isn’t intentional, best not use these options in the “floating” rules.
NAT (Firewall)

Merging the nat rules will keep the interfaces unaltered which don’t exists on the central node as these are being provided to the target firewall. In case you want to exclude some interfaces (for all remote firewalls), you can easily override the known interfaces in Management -> Host configuration on the General settings tab.

Note

All NAT type rules (Port Forward, One-to-One, Outbound, NPTv6) are treated similar.

Note

When multiple interfaces are attached to a rule, which is possible for port forwards. These will be removed by the provisioning algorithm.

Note

Port forwarding rules on the central node which do apply on a selection of interfaces are always being send to the remote firewall. When this isn’t intentional, best prevent the usage of these forwards.
Firewall categories

Merging categories will preserve the ones that are currently used on the remote firewall.
WebGui (Administration)

To prevent breakage after synchronisation, the certificate used by the webgui will be preserved after synchronisation (or the one provided in the host configuration will be shipped).

Attention

Currently it’s not possible to merge certificates and webgui admin settings, as the certificate store will potentially be overwritten in that case.
Configuration Tutorials

In this section we will show example configurations of some of the features that OPNcentral Central Management offers.
Automatic WebGUI Login

For the automatic login feature to work, the following infrastructure is required:

    One OPNsense with Business Edition and OPNcentral installed, which will be used as the Central Host for configuration. Using this OPNsense for no other tasks than configuration and administration is recommended.
    One or several other OPNsense with Business Edition and OPNcentral installed, which will be managed by the Central Host.
    Either your own PKI (Public Key Infrastructure) or using the OPNsense provided one in System ‣ Trust
    A DNS infrastructure or public DNS provider, that manages the FQDNs (Full Qualified Domain Names) of each OPNsense

We assume that we have this example infrastructure:

FQDN
	

IP Address
	

Task

central-host.opnsense.local
	

203.0.113.1
	

Central Host for administration

node-a1.opnsense.local
	

198.51.100.1
	

Firewall Node site A

node-b1.opnsense.local
	

192.0.2.1
	

Firewall Node site B
1. Add Firewall Nodes to the Central Host

    Go to Management ‣ Host ‣ Configuration.
    Follow the steps described here Register new hosts.
    If there are connection problems, check if the Central Host can resolve the FQDNs of the Firewall Nodes. They have to be added via their FQDN and not via IP address. Otherwise the SAN of the certificates will not match the FQDN.

Tip

When using a custom WebGUI port, specify the socket like this: https://node-a1.opnsense.local:8443

Note

Only add the Firewall Nodes to the Central Host. Do not add the Central Host to itself to prevent configuration loops.
2. Create a PKI on the Central Host

    Go to System ‣ Trust ‣ Authorities and press + to Create an internal Certificate Authority.
    Leave all the populated fields on their default values.
    As State, City, Organization and Email Address, add your own.
    As Descriptive name and Common Name, use opncentral-ca.
    Press Save.

Note

Export the CA certificate, and import it into the Trusted Root Certificate Store of each client that should use the automatic WebGUI login. It will only work if the Browser trusts the connection.
3. Create Server Certificates for all Hosts

    Go to System ‣ Trust ‣ Certificates and press + to Create an internal Certificate.
    Leave all the populated fields on their default values.
    As Type choose Server Certificate.
    As Common Name and Alternative Names Type DNS (SAN) choose the FQDNs of the Firewall; e.g., central-host.opnsense.local
    Press Save and repeat this until there are certificates for the Central Host and the Firewall Nodes.

4. Change WebGUI certificate of Central Host

    Go to System ‣ Settings ‣ Administration.
    Make sure the Protocol is HTTPS and choose the certificate with the FQDN of the Central Host; e.g., central-host.opnsense.local
    Press Save and press the link that appears, which will redirect the session to a new browser tab.

Note

The browser should automatically trust the connection to the Central Host now. If not, make sure the opncentral-ca certificate has been imported as described in Step 2. It is mandatory that the browser trust is established before continuing.
5. Provision Certificates and WebGUI to Firewall Nodes

    Go to Management ‣ Host ‣ Configuration.
    Select a Firewall Node, e.g., node-a1.opnsense.local and edit it.
    Make sure that Validate SSL is not selected right now.
    Select the correct certificate in Push WebUI certificate, in this case node-a1.opnsense.local
    In Provision classes, select Web GUI. Please be careful not to select Certificates, only Web GUI is needed as Provision classes.
    Press Save and repeat the same for all other Firewall Nodes.
    Go to Management ‣ Provisioning and select all Hosts, then press Reconfigure.
    After the provisioning has succeeded, go back to Management ‣ Host ‣ Configuration and enable Validate SSL for all Firewall Nodes.

6. Test the Automatic Login

    Go to Management ‣ Provisioning and click on any of the Host links. An additional browser tab will open with the selected Firewall Node and the session is automatically logged in.

Tip

This feature is especially useful for Network Administrators that centrally manage a large amount of OPNsense Firewalls.


Web Application Firewall

As part of the OPNsense Business Edition, Deciso offers a plugin to easily protect webservices against all sort of injection attacks and provides encryption for traffic to and from the outside world.

Our Web Application Firewall plugin offers some functionality which can also be found in community plugins available, but in a more user friendly manner. It combines the features most commonly used in reverse proxies, such as TLS offloading and load balancing.

To ease maintenance the OPNWAF plugin offers usage of both internal certificates or newly generated using the ACME protocol via Let’s Encrypt with a single click.
Prerequisites

Before using this plugin in combination with Let’s Encrypt, make sure port 443 isn’t being used for the web gui of this firewall (System->Settings->Administration).

Note

When using Let’s Encrypt, The Web Application Firewall uses the tls-alpn-01 challenge type for easy domain verification, this requires the virtual server to listen on port 443. Make sure the firewall allows incoming HTTPS connections on port 443. If the client connects via a custom port, you can forward these requests to port 443, and configure the virtual server to forward these requests to the correct internal port.
Installation

To install this plugin, go to System ‣ Firmware ‣ Plugins and search for os-OPNWAF, the [+] button downloads and installs the software.

Next go to Firewall ‣ Web Application ‣ Settings to enable it.
General

Before deep diving into the settings pages, we will explain the most important terminology used in this module.
Virtual servers

A virtual server (also known as a virtual host) is a a concept which allows the use of multiple domains on a single webserver using the same port. In our case it offers the possibility to host various webservers inside your network and forward traffic to them in a secure fashion.
Locations

Locations reside in virtual servers and describe on a path level how requests are being handled, if for example one would like to forward only a subdirectory (like /api) to a server in the network, the location is where to configure this.
Web protection

The web protection options offer easy access to the OWASP ModSecurity ruleset , which offers a set of generic attack detection rules against a wide range attacks including the OWASP Top Ten.
Setup

Before configuring virtual servers, let’s take a look at the general settings pages (Firewall ‣ Web Application ‣ Settings). After installation, the module itself should be enabled by default.

In order to use the integrated ACME client (for Let’s Encrypt), the ACME enable checkbox needs to be set, the certificate agreement needs to be accepted (next checkbox) and contact email needs to be specified.
../../_images/OPNWAF_settings.png

Web protection is not enabled by default, but you can enable it in the Web protection tab. This is also the place to configure the module and settings which apply for all virtual hosts.
Configure virtual hosts

With the general settings in place, we can start adding virtual servers to offload traffic to machines in our network. First go to Firewall ‣ Web Application ‣ Gateways and click on the [+] in the top section of the screen, which defines the virtual servers.

Enabled
	

Enable this virtual server

ServerName
	

Fully qualified hostname for this server

Port
	

Port number this vhost will listen on, can easily be combined with firewall nat rules to map traffic to non standard ports when origination from remote destinations. (e.g. listen 8443 on, forward 443 to 8443)

Certificate
	

When using a certificate available in the system trust store, select it here

CA for client auth
	

Require a client certificate signed by the provided authority before allowing a connection.

CRL for client auth
	

Attach the (first) found certificate revocation list for the selected CA to this virtual host. Please note when no CRL is offered all clients are rejected.

Enable ACME
	

Enable the ACME protocol to automatically provision certificates using Let’s Encrypt, when set will ignore the selected certificate (and enable SSL on this virtual server)

Header Security
	

Header security, by default several privacy and security related headers are set, in some cases (old applications for example) you might want to disable sending default headers to clients.

TLS Security profile
	

TLS security profile as documented by Mozilla

Description
	

User friendly description for this vhost

The section above defines the port the virtual server will listen on. Remember, in order to use ACME (Let’s encrypt) this should either be 443 or the traffic should be forwarded from port 443 to the port defined here.

Note

Port numbers don’t have to be unique when more virtual servers are defined as the hostname correctly identifies the location.

Warning

The ALPN protocol (the challenge type used by Let’s Encrypt) will resolve the FQDNs specified in the virtual host entry to the IP address of the firewall. If your DNS records point to both IPv4 and IPv6 addresses, IPv6 will be preferred by the challenge, so make sure your firewall is reachable via IPv6 as well if this is the case.

When supplying a certificate manually via the system trust store you can assign it in this dialog as well.

The virtual server itself doesn’t provide much content to the user other than offering a page telling access is prohibited, so the next step is to map directories to external locations. These can be defined in the “Locations” Grid underneath the Virtual servers.

Enabled
	

Enable this location

Path
	

Local path to match

Remote destinations
	

Locations to forward requests to, when more than one is provided, requests will be loadbalanced in a round robin fashion. Supports http, https, ws and wss destinations. When your webapp uses websockets and https requests, use wss:// (available as of 22.10.1)

Access control
	

List of networks allowed to access this path (empty means any)

VirtualServer
	

The server this location belongs to

Description
	

User friendly description for this location

The options here are quite simple, first you define a path on your end (/ in our example), next you define one or more destinations this path should map to (for example you could point to a public server here, like https://opnsense.org).

Note

When more than one destination is provided, the load will be balanced automatically.

Tip

Constraining access to allow only specific networks or hosts can be arranged using the Access control input.
Test web protection

When web protection was enabled, we always advise to test if it’s actually functional. Luckily this is quite easy to test using a webbrowser. For this example we will try to inject some sql code in the url, which should be blocked when properly configured:

https://your.example.domain/?id=100 or 'x'='y'

This should show a page similar to the one below:
../../_images/OPNWAF_forbidden.png

Tip

You can disable web protection on a per virtual host bases to, just open the advanced settings and click Disable Web Protection, apply settings after saving and try the previous example again.
Protect a local server with certificates

In the above virtual host configuration there are a couple of parameters related to client authentication. The advantage of using these is that you can prevent unauthorized access to services using certificates signed by a (local) certificate authority.

To use this functionality, first make sure you have a certificate authority defined in System ‣ Trust ‣ Authorities which you are going to use to create certificates for your clients.

Next step is to add a VirtualServer which contains at least the following information:

ServerName
	

The fully qualified domain name this host listens to

Port
	

Port number to bind to, you can use Port forwarding to redirect traffic from standard ports to non standard ones when needed

Certificate / Enable ACME
	

Either use an ACME certificate or define one yourself, this one should be trusted by the browser connecting to this host

CA for client auth
	

select the Authority created earlier

Followed by a location, which maybe as simple as binding path / to a local machine without certificate at http://10.0.0.1.

Tip

You can use revocation lists to pull back access rights for selected clients, just make sure to restart the service in order to make the changes effective.

After this step, clients should not be able to access the virtual host, next you can create a certificate for the client and import it in the trust store. Usually browsers automatically pick these up when allowed by the client.


Extended Blocklists

As part of the OPNsense Business Edition, Deciso offers the extended blocklists module as part of the standard Business Edition installation. With this module you are able to configure DNS blocking policies in a more fine-grained manner by specifying networks on which the blocklists should apply.

The extended blocklists can be found under Services->Unbound DNS->Extended Blocklists.
Blocklists

Blocklists are configured in the same manner as with regular blocklists, except they are listed in a grid, where multiple blocklists and multiple networks may be defined per grid entry to ease administration for a large amount of networks. An optional description may be provided for your own reference.

Source networks are provided as IP addresses in CIDR notation, or singular IP addresses. The validation for this field is strict, meaning that setting host bits in a CIDR notation is not allowed.

Note

If you’d like to use the extended blocklists module, keep in mind that the regular blocklists, if configured, are still active. They define a policy for all networks, and are given preference above the extended blocklists. Therefore it’s possible that a conflict arises between blocklists for a specific network and regular blocklists. Please verify that the relevant blocklists are not configured in Services->Unbound DNS->Blocklist.

If you’re not sure if a policy would overlap in this manner, please use the tester as described below.
Custom

In the Custom tab you are able to configure custom domains to block, also per source network. The domains can either be exact matches, or entered as a wildcard in a separate field. Wildcard entries will block every subdomain of the configured domain name. It’s not possible to block a first-level domain such as ‘com’.

To prevent cluttering in the grid, the relevant domains and wildcards are not shown in the grid. Therefore it’s mandatory to add a description for your own reference so you can easily locate a custom policy. You can view the blocked domains/wildcards by clicking “edit” on the grid entry.
Tester

If you’d like to verify whether a specified domain is correctly being blocked, or if you want to know if a domain is part of a specific list, you can use the tester to see the policy that’s applied to a DNS request. Here you’re able to enter a domain, as well as a source IP address to simulate a request from a specific address. Note that no actual DNS request is sent if a domain were to pass, it’s kept isolated as part of the blocklisting mechanism.

It’s also possible to verify whether a domain overlaps with another policy. For example, if you configured the facebook blocklist, the output would look something like this:

{
    "status": "OK",
    "action": "Block",
    "policy": {
        "bl": "ext_blf0",
        "wildcard": false,
        "source_net": [
            "192.168.2.0/24",
            "192.168.1.0/24",
            "10.0.0.0/8"
        ]
    }
}

However, if you also enabled the facebook blocklist in the regular blocklist section, you would get:

{
    "status": "OK",
    "action": "Block",
    "policy": {
        "bl": "blf0",
        "wildcard": false,
        "collisions": [
            {
                "bl": "ext_blf0",
                "wildcard": false,
                "source_net": [
                    "192.168.2.0/24",
                    "192.168.1.0/24",
                    "10.0.0.0/8"
                ]
            }
        ],
        "source_net": []
    }
}

which would tell you that a regular list is conflicting with an extended blocklist policy.


Installation and setup
_images/architect-architecture-black-and-white-1537008.jpg

When your device wasn’t shipped with OPNsense® pre-installed, you can find how to install it yourself and which hardware platforms are supported in this chapter.

    Hardware sizing & setup
    Initial Installation & Configuration
    Virtual & Cloud based Installation
    Updates
    Included software

Setup guides

    Changelogs
    Serial Access
    Installing OPNsense AWS image
    Installing OPNsense OVA image
    OPNsense Azure Virtual Appliance

Hardware sizing & setup

The hardware setup requires a careful preparation and selection of the standard PC hardware components for the intended installation of OPNsense.

⚠ Computer hardware with the open source security software OPNsense® pre-installed can be purchased directly from various (online) stores.

Tip

The OPNsense development team encourage everyone looking for a turn-key solution to buy from Deciso or one of the other partners listed at our partner page. Listed partners make significant contributions back to the project.
Supported hardware architectures

OPNsense® is available for x86-64 (amd64) bit microprocessor architectures. Full installs on SD memory cards, solid-state disks (SSD) or hard disk drives (HDD) are intended for OPNsense.

While the range of supported devices are from embedded systems to rack mounted servers, the hardware must be capable of running 64-bit operating systems.
Hardware requirements

For substantially narrowed OPNsense® functionality there is the basic specification. For full functionality there are minimum, reasonable and recommended specifications.

Minimum

The minimum specification to run all OPNsense standard features that do not need disk writes, means you can run all standard features, except for the ones that require disk writes, e.g. a caching proxy (cache) or intrusion detection and prevention (alert database).

Processor
	

1 GHz dual core cpu

RAM
	

2 GB

Install method
	

Serial console or video (vga)

Install target
	

SD or CF card with a minimum of 4 GB, use nano images for installation.

Table: Minimum hardware requirements

Reasonable

The reasonable specification to run all OPNsense standard features, means every feature is functional, but perhaps not with a lot of users or high loads.

Processor
	

1 GHz dual core cpu

RAM
	

4 GB

Install method
	

Serial console or video (vga)

Install target
	

40 GB SSD, a minimum of 2 GB memory is needed for the installer to run.

Table: Reasonable hardware requirements

Recommended

The recommended specification to run all OPNsense standard features, means every feature is functional and fits most use cases.

Processor
	

1.5 GHz multi core cpu

RAM
	

8 GB

Install method
	

Serial console or video (vga)

Install target
	

120 GB SSD

Table: Recommended hardware requirements

Hardware guide

The hardware required for your local OPNsense, will be determined by the intended minimum throughput and the feature set.
Impact of Feature set

While most features do not affect hardware dimensioning, a few features have massive impact on it. The candidates are:

Squid

    a caching web proxy which can be used for web-content control, respectively. These packages rely strongly on CPU load and disk-cache writes.
Captive portal

    settings with hundreds of simultaneously served captive portal users will require more CPU power in all the hardware specifications displayed below.
State transition tables

    it is a known fact, that each state table entry requires about 1 kB (kilobytes) of RAM. The average state table, filled with 1000 entries will occupy about ~10 MB (megabytes) of RAM. OPNsense usage settings with hundred of thousands of connections will require memory accordingly.


Throughput

The main hardware-factors of the OPNsense setup involved are CPU, RAM, mass storage (disc), the number and quality of network interfaces.

Throughput (Mbps)
	

Hardware requirements
	

Feature set
	

Users / Networks

11-150
	

Basic spec.
	

narrowed
	

adjusted (10-30)

11-150
	

Minimum spec.
	

reduced
	

adjusted (10-30)

151-350
	

Reasonable spec.
	

all
	

substantial (30-50)

350-750+
	

Recommended spec.
	

all
	

substantial+ (50-150+)

Mbps (Mbit/s or Mb/s) - Megabit per second - 1,000,000 bits per second

Network interface cards

    As the FreeBSD hardware-lists and -recommendations say, Intel® network interface cards (NIC) for LAN connections are reliable, fast and not error-prone. Intel chipset NICs deliver higher throughput at a reduced CPU load.

Supported hardware

FreeBSD is the base of OPNsense. All FreeBSD drivers are included in the OPNsense kernel, and the hardware compatibility is the same.

Tip

If you are looking to buy new hardware then take a look at our partner page as these partners contribute back to OPNsense and sell hardware that is know to work well.


Initial Installation & Configuration

Note

Just looking on how to invoke the installer? When the live environment has been started just login with user installer and password opnsense.

Index

    Initial Installation & Configuration

        Architecture

        Embedded vs Full

        Installation Images

        Image Filename Composition

        Download and Verification

        Installation Media

        System Boot Preparation

        Installation Instructions

            OPNsense Importer

            Live Environment

            OPNsense Installer

            Nano Image

        Initial Configuration

Architecture

The software setup and installation of OPNsense® is available for the x86-64 microprocessor architecture only.
Embedded vs Full

OPNsense offers two Image types with all major releases: embedded and full images. The Embedded Image is intended for environments where preinstalling the storage media is required due to a lack of local resources on the firewall like storage, and/or console access (VGA/Serial). The image is tailored to reduce write cycles as well, but the image can be used anywhere. Another reason for the Embedded Image is to eliminate the need for local console access for installing OPNsense. Installation is managed by prewriting the image to a storage device, installing the storage device, and booting the system.

Full Images provide installation tools like OPNsense Importer, Live Environment, and Installer. Full Images are released to support different console/hardware installation requirements.

Both image types can be installed and run from virtual disks (VM), SD memory cards, USB disks, solid-state disks (SSD), or hard disk drives (HDD).

The main differences between embedded and full images are:

Embedded
	

Full

Writes to RAM disk
	

Writes to local disk

No log data retention after reboot
	

Log data retention after reboot

Not intended for local disk writes
	

Suitable for disk writes.

Embedded only use, SWAP file is optional
	

Can enable RAM disk for embedded mode.

Embedded image store logging and cache data in memory only, while full versions will keep the data stored on the local drive. A full version can mimic the behavior of an embedded version by enabling RAM disks, this is especially useful for SD memory card installations.

Warning

See the chapter Hardware Sizing & Setup for further information on hardware requirements prior to an install.
Installation Images

Depending on your hardware and use case, different installation options are available:

Type
	

Description
	

Image Type

dvd
	

ISO image boots into a live environment in VGA-only mode with UEFI support
	

Full

vga
	

USB image boots into a live environment in VGA-only mode with UEFI support
	

Full

serial
	

USB image boots into live environment running in serial console (115200) mode only with UEFI support
	

Full

nano
	

Image for preinstalling onto >=4 GB USB drives, SD, or CF cards for use with embedded devices running in serial console (115200) mode with secondary VGA support (no kernel messages though)
	

Embedded

Note

All Full Image types can run both OPNsense Importer before booting into the Live environment and also run Installer once booted into the Live environment.

Warning

Flash memory cards will only tolerate a limited number of writes and re-writes. For Nano image memory disks for /var/log and /tmp are applied by default to prolong CF (flash) card lifetimes.

To enable non-embedded versions: Go to System ‣ Settings ‣ Miscellaneous ‣ Disk / Memory Settings, change the setting, then reboot. Consider enabling an external syslog server as well.
Image Filename Composition

Note

Please be aware that the latest installation media does not always correspond with the latest released version available. OPNsense installation images are provided on a scheduled basis with major release versions in January and July. More information on our release schedule is available from our package repository, see README. We are encouraged to update OPNsense after installation to be on the latest release available, see Update Page.
Download and Verification

The OPNsense distribution can be downloaded from one of our mirrors.

OpenSSL is used for image file verification. 4 files are needed for verification process:

    The SHA-256 checksum file (<filename>.sha256)

    The bzip compressed image file (<filename>.<image>.bz2)

    The signature file for the uncompressed image file (<filename>.<image>.sig)

    The openssl public key (<filename>.pub)

Use one of the OPNsense mirrors to download these files:

    Go to the bottom of OPNSense download page.

    Click one of the available mirrors closest to your location.

    Download one of each file mentioned above for your Image type.

The OpenSSL public key (.pub) is required to verify against. Although the file is available on the mirror’s repository, you should not trust the copy there. Download it, open it up, and verify the public key matches the one from other sources. If it does not, the mirror may have been hacked, or you may be the victim of a man-in-the-middle attack. Some other sources to get the public key from include:

    https://pkg.opnsense.org/releases/mirror/README

    https://forum.opnsense.org/index.php?board=11.0

    https://opnsense.org/blog/

    https://github.com/opnsense/changelog/tree/master/community

    https://pkg.opnsense.org (/<FreeBSD:<version>:<architecture>/<release version>/sets/changelog.txz)

Note

Only major release announcements for images contain the public key, and update release announcements will not. i.e. 22.1 will have a copy of the public key in the release announcement, but 22.1.9 will not.

Once you download all the required files and verify that the public key matches the public key found in one of the alternate sources listed above, you can be relatively confident that the key has not been tampered with. To verify the downloaded image, run the following commands (substituting the filenames in brackets for the files you downloaded):

openssl sha256 OPNsense-<filename>.bz2

Match the checksum command output with the checksum values in the file OPNsense-<version>-OpenSSL-checksums-amd64.sha256. If the checksums don’t match, redownload your image file.

If checksums match continue with the verification commands.

openssl base64 -d -in OPNsense-<filename>.<image>.sig -out /tmp/image.sig
openssl dgst -sha256 -verify OPNsense-<filename>.pub -signature /tmp/image.sig OPNsense-<filename>.<image>

Warning

Make sure to unpack the image using bunzip2 before verifying. Our signatures are generated before compressing them (as of OPNsense version 24.1)

If the output of the second command is “Verified OK”, your image file was verified successfully, and its safe to install from it. Any other outputs, and you may need to check your commands for errors, or the image file may have been compromised.
Installation Media

Now that you have downloaded and verified the installation image from above. You must unpack the image file before you can write the image to disk. For Unix-like OSes use the following command:

bzip2 -d OPNsense-<filename>.bz2

For Windows use an application like 7zip. The .bz2 will be removed from the end of the filename after command/application completes.

After unpacking the image you can create the installation media. The easiest method to install OPNsense is to use the USB “vga” Image. If your target platform has a serial console interface choose the “serial” image. If you need to know more about using the serial console interface, consult the serial access how-to.

Write the image to a USB flash drive (>=1 GB) or hard disk, using either dd for Unix-like OSes and for Windows use physdiskwrite, Etcher, or Rufus.

FreeBSD

dd if=OPNsense-##.#.##-[Type]-[Architecture].img of=/dev/daX bs=16k

Where X = the device number of your USB flash drive (check dmesg)

OpenBSD

dd if=OPNsense-##.#.##-[Type]-[Architecture].img of=/dev/rsd6c bs=16k

The device must be the ENTIRE device (in Windows/DOS language: the ‘C’ partition), and a raw I/O device (the ‘r’ in front of the device “sd6”), not a block mode device.

Linux

sudo dd if=OPNsense-##.#.##-[Type]-[Architecture].img of=/dev/sdX bs=16k

where X = the IDE device name of your USB flash drive (check with hdparm -i /dev/sdX) (ignore the warning about trailing garbage - it’s because of the digital signature)

macOS

sudo dd if=OPNsense-##.#.##-[Type]-[Architecture].img of=/dev/rdiskX bs=64k

where r = raw device, and where X = the disk device number of your CF card (check Disk Utility) (ignore the warning about trailing garbage - it’s because of the digital signature)

Windows

physdiskwrite -u OPNsense-##.#.##-[Type]-[Architecture].img

(use v0.3 or later!)
System Boot Preparation

After preparing the installation media, we need to make sure we can access the console (either via keyboard and [virtual]monitor or serial connectivity). Next we need to know how to access the boot menu or the system bios (UEFI) to boot from the installation media. Most times will be a function (F#), Del, or ESC key that needs to pressed immediately after powering on (or rebooting) the system. Usually within the first 2 to 3 seconds from powering up.

Tip

OPNsense devices from the OPNsense shop use <ESC> to enter the bios and boot selection options.

Note

Serial connectivity settings for DECXXXX devices can be found here
Installation Instructions

Install Instructions

OPNsense installation boot process allows us to run several optional configuration steps. The boot process was designed to always boot into the live environment, allowing us to access the GUI or even SSH directly. If a timeout was missed, restart the boot procedure.
OPNsense Importer

All Full Images have the OPNsense Importer feature that offers flexibility in recovering failed firewalls, testing new releases without overwriting the current installation by running the new version in memory with the existing configuration or migrating configurations to new hardware installations. Using Importer is slightly different between previous installs with existing configurations on disk vs new installations/migrations.

For systems that have OPNsense installed, and the configuration intact. Here is the process:

    Boot the system with installation media

    Press any key when you see “Press any key to start the configuration importer”.

        If you see OPNsense logo you have past the Importer and will need to reboot.

    Type the device name of the existing drive that contains the configuration and press enter.

    If Importer is successful, the boot process will continue into the Live environment using the stored configuration on disk.

    If Importer was unsuccessful, we will returned to the device selection prompt. Confirm the device name is correct and try again. Otherwise, there maybe possible disk corruption and restoring from backup.

At this point the system will boot up with a fully functional firewall in Live enironment using existing configuration but will not overwrite the previous installation. Use this feature for safely previewing or testing upgrades.

For New installations/migrations follow this process:

    We must have a 2nd USB drive formatted with FAT or FAT32 File system.

        Preferable non-bootable USB drive.

    Create a conf directory on the root of the USB drive

    Place an unencrypted <downloaded backup>.xml into /conf and rename the file to config.xml (/conf/config.xml)

    Put both the Installation media and the 2nd USB drive into the system and power up / reboot.

    Boot the system from the OPNsense Installation media via Boot Menu or BIOS (UEFI).

    Press aany key when you see: “Press any key to start the configuration importer”

    Type the device name of the 2nd USB Drive, e.g. da0 or nvd0 , and press Enter.

        If Importer is successful, the boot process will continue into the Live environment using the configuration stored on the USB drive.

        If unsuccessful, importer will error and return us to the device selection prompt. Suggest repeating steps 1-3 again.

Live Environment
../_images/opnsense_liveenv.png

After booting with an OPNsense Full Image (DVD, VGA, Serial), the firewall will be in the Live environment with and without the use of OPNsense Importer. We can interact with the Live environment via Local Console, GUI (HTTPS), or SSH.

By default, we can log into the shell using the user root with the password opnsense to operate the live environment via the local console.

The GUI is accessible at https://192.168.1.1/ using Username: root Password: opnsense by default (unless a previous configuration was imported).

Using SSH we can access the firewall at IP 192.168.1.1 . Both the root and installer users are available with the password specified above.

Note

That the installation media is read-only, which means your current live configuration will be lost after reboot.

Continue to OPNsense Installer to install OPNsense to the local storage device.
OPNsense Installer

Note

To invoke the installer login with user installer and password opnsense

After successfully booting up with the OPNsense Full Image (DVD, VGA, Serial), the firewall will be at the Live Environment’s login: prompt. To start the installation process, login with the user installer and password opnsense. If Importer was used to import an existing configuration, the installer and root user password would be the root password from the imported configuration.

If the installer user does not work, log in as user root and select: 8) Shell from the menu and type opnsense-installer. The opnsense-importer can also be run this way should you require to rerun the import.

The installer can always be run to clone an existing system, even for Nano images. This can be useful for creating live backups for later recovery.

Tip

The installer can also be started from an inside host using ssh. Default ip address is 192.168.1.1

The installation process involves the following steps:

    Keymap selection - The default configuration should be fine for most Occasions.

    Install (UFS|ZFS) - Choose UFS or ZFS filesystem. ZFS is in most cases the best option as it is the most reliable option, but it does require enough capacity (a couple of gigabytes at least).

    Partitioning (ZFS) - Choose a device type. The default option (stripe) is usually acceptable when using a single disk.

    Disk Selection (ZFS) - Select the Storage device e.g. da0 or nvd0

    Last Chance! - Select Yes to continue with partitioning and to format the disk. However, doing so will destroy the contents of the disk.

    Continue with recommended swap (UFS) - Yes is usually fine here unless the install target is very small (< 16GB)

    Select Root Password - Change and confirm the new root password

    Select Complete Install - Exits the installer and reboots the machine. The system is now installed and ready for initial configuration.

Warning

You will lose all files on the installation disk. If another disk is to be used then choose a Custom installation instead of the Quick/Easy Install.
Nano Image

To use the nano image follow this process:

    Create the system disk with using the nano image. See Installation Media how to write the nano image to disk.

    Install the system disk drive into the system.

    Configure the system (BIOS) to boot from this disk.

    After the system boots, the firewall is ready to be configured.

Using the nano image for embedded systems, your firewall is already up and running. The configuration settings to enable Memory Disks (RAM disks) that minimize write cycles to relevant partitions by mounting these partitions in system memory and reporting features are disabled by default.
Initial Configuration

After installation the system will prompt you for the interface assignment, if you ignore this then default settings are applied. Installation ends with the login prompt.

By default you have to log in to enter the console.

Welcome message

* * * Welcome to OPNsense [OPNsense 15.7.25 (amd64/OpenSSL) on OPNsense * * *

WAN (em1)     -> v4/DHCP4: 192.168.2.100/24
LAN (em0)     -> v4: 192.168.1.1/24

FreeBSD/10.1 (OPNsense.localdomain) (ttyv0)

login:

Tip

A user can login to the console menu with his credentials. The default credentials after a fresh install are username “root” and password “opnsense”.

VLANs and assigning interfaces

    If choose to do manual interface assignment or when no config file can be found then you are asked to assign Interfaces and VLANs. VLANs are optional. If you do not need VLANs then choose no. You can always configure VLANs at a later time.
LAN, WAN and optional interfaces

    The first interface is the LAN interface. Type the appropriate interface name, for example “em0”. The second interface is the WAN interface. Type the appropriate interface name, eg. “em1” . Possible additional interfaces can be assigned as OPT interfaces. If you assigned all your interfaces you can press [ENTER] and confirm the settings. OPNsense will configure your system and present the login prompt when finished.
Minimum installation actions

    In case of a minimum install setup (i.e. on CF cards), OPNsense can be run with all standard features, except for the ones that require disk writes, e.g. a caching proxy like Squid. Do not create a swap slice, but a RAM Disk instead. In the GUI enable System ‣ Settings ‣ Miscellaneous ‣ RAM Disk Settings and set the size to 100-128 MB or more, depending on your available RAM. Afterwards reboot.

Enable RAM disk manually
../_images/Screenshot_Use_RAMdisks.png

Then via console, check your /etc/fstab and make sure your primary partition has rw,noatime instead of just rw.

Console

The console menu shows 13 options.

0)     Logout                              7)      Ping host
1)     Assign interfaces                   8)      Shell
2)     Set interface(s) IP address         9)      pfTop
3)     Reset the root password             10)     Filter logs
4)     Reset to factory defaults           11)     Restart web interface
5)     Reboot system                       12)     Upgrade from console
6)     Halt system                         13)     Restore a configuration

Table: The console menu

opnsense-update

OPNsense features a command line interface (CLI) tool “opnsense-update”. Via menu option 8) Shell, the user can get to the shell and use opnsense-update.

For help, type man opnsense-update and press [Enter].

Upgrade from console

The other method to upgrade the system is via console option 12) Upgrade from console

GUI

An update can be done through the GUI via System ‣ Firmware ‣ Updates.
../_images/firmware-update.png


Virtual & Cloud based Installation
Local/Server

Installing OPNsense on a virtual machine can be done by using the DVD ISO image. Full instructions are available in chapter Initial Installation & Configuration .
General tips

For optimum performance and compatibility, these guides are given:

    Minimum required RAM is 1 GB

    Minimum recommended virtual disk size of 8 GB

    Disable all off-loading settings in Interfaces ‣ Settings

../_images/disableoffloading.png
VMware ESXi

VMware offers full instructions for installing FreeBSD, these can be found here.

To install the VMware tools just goto System ‣ Firmware ‣ Plugins and install os-vmware by clicking on the + sign next to it.
../_images/os-vmware.png

Note

While other network setups may work fine, the VMXNET 3 is the recommended one according to VMware’s Compatibility Guide.
Xen

To install the Xen tools just goto System ‣ Firmware ‣ Plugins and install os-xen by clicking on the + sign next to it.
../_images/os-xen.png
HyperV

HyperV Generation 1 and 2 are supported out of the box, no additional drivers or tools are needed.

    Secure Boot setting must be un-ticked in the Hardware > Security section for the VM.

KVM

i440FX chipset OPNsense on KVM works with virtio disks and network devices (confirmed on QEMU 5.0).

Q35 chipset As of 22.1.x, OPNsense is based on FreeBSD 13.0, which includes support for the virtualized Q35 chipset and newer generation of KVM virtio devices. Note that this was a relatively recent addition to FreeBSD, so it may not be as well tested as the i440 support.
Others

OPNsense can be installed on all virtual machines that support FreeBSD (such as Bhyve, VirtualBox).
Hosted

For hosted installations where you can’t install using the DVD ISO an alternative approach is available in the form of opnsense-bootstrap.
opnsense-bootstrap

opnsense-bootstrap(8) is a tool that can completely reinstall a running system in place for a thorough factory reset or to restore consistency of all the OPNsense files. It can also wipe the configuration directory, but won’t do that by default.

It will automatically pick up the latest available version and build a chain of trust by using current package fingerprints -> CA root certificates -> HTTPS -> OPNsense package fingerprints.

What it will also do is turn a supported stock FreeBSD release into an OPNsense installation. Both UFS and ZFS installations are supported.

opnsense bootstrap is available for our github source repository
Amazon AWS EC2 Cloud
../_images/amazon-web-services.png

Installing OPNsense into the Amazon cloud can be a daunting task as no console is offered. Luckily an easy to install AMI is also available in the aws marketplace.

See also our how-to for Installing OPNsense AWS image.
Microsoft Azure
../_images/Azure.png

OPNsense is also available in the Microsoft Azure Marketplace as an easy installable virtual appliance.

See also our how-to for OPNsense Azure Virtual Appliance.
Common Issues

Some common issues have been reported for different virtual environments. You can find known solutions to these problems below.

If your problem is not listed always try the General tips mentioned in the article first.
File copy failed during installation

This issue is most likely caused by low memory setting. Make sure your virtual OPNsense installation has a minimum of 1 GB of RAM.
Disk Errors on VMware

This issue can be caused by a defective drive. Changing the drive mode to IDE has been reported to help for certain ESXi versions.
NAT issues on XenServer

This issue has been reported to be solved by disabling checksum offloading on both OPNsense domU and Vifs.
Traffic Shaper does not work on VMware

If you are using vmxnet3 drivers try to switch to E1000.


Updates

OPNsense’s update schedule consists of two major releases each year, which are updated about every two weeks. The major releases’ version number consists of the year and months of release (e.g. 19.1 for the January 2019 release), with the fortnightly updates adding a third number (e.g. 19.1.3 for the third update to 19.1).
Installing updates

Updates can be installed from the web interface, by going to System ‣ Firmware ‣ Status. On this page, you can click Check for updates to search for updates. If they are available, a button will appear to install them.
Update settings

By navigating to System ‣ Firmware ‣ Settings, you can influence the firmware update settings:

    Fimware Mirror: this influences where OPNsense tries to get its updates from. If you have troubles updating or searching for updates, or if your current mirror is running slowly, you can change it here.

    Release Type: With this setting, you can switch between the regular fortnightly schedule of tested releases (Production) or the newest, not fully tested code (Development). Please leave this setting on “Production”, unless you fully understand the implications of switching.

Tip

The settings page is also the place where you can run audits which help debugging common connectivitty issues, just press the “Run an audit” and choose “Connectivity” from the list.
Troubleshooting updates

Usually the connectivity check offers a direction where to look for issues during updates, the following causes are in our experience most common.

    Misconfigured DNS settings, check System ‣ Settings ‣ General for configured servers the firewall is allowed to use

    Misconfigured IPv6, in which case “Prefer IPv4 over IPv6” in System ‣ Settings ‣ General might help to prevent the system from using IPv6 in these cases

    In HA (carp) setups, using the wrong extrenal IPaddress, usually caused by a misconfigued outbound nat rule, easy to check by disabling manual outbound nat rules in Firewall ‣ NAT ‣ Outbound.

Major Upgrades

Major upgrades are recommended to do via VGA display or serial because you can see what is going on.

Note

You can find some documentation about serial access under Serial Access

Warning

Major updates are installed offline. So no web interface or SSH is running to monitor the upgrade. If something fails, you need a second connection or direct access to revert the VM or repair the installation.

If you choose option 12 on the console menu on latest release, you are asked if you want to upgrade to the newest version or to the next major release. Type in the major release number (for example “19.1”) and press enter. OPNsense will download all release files for an offline upgrade (kernel, packages etc.) and will reboot afterwards.

After a reboot, it will install all updates and when it is done, it will reboot again, then you should be on the desired release.


Included software

OPNsense® comes with a lot of features included in the base system, for some situations you may need additional software, which is either provided via a plugin or only as a binary package (without user interface).

This chapter aims to provide some details on the components included in the system, where to find them and how to install them when not installed by default.
The operating system

The basic ( FreeBSD) system contains a kernel and a base package, which provide the bare essentials for the system to be able to boot and do its work.

Both components are updated using opnsense-update, which is explained in more detail here.
Plugins

Plugins are packages offered by OPNsense®, which can be installed directly via the user interface and often come with setup options accessible for the end-user.

Since OPNsense® is a community driven project, the amount of (community/commercial) support available on these plugins can be different.

Note

The plugin repository is maintained by the project, when plugins are not kept up to date by its maintainer, they will be removed at some point in time. (a good example for such a plugin would be if one requires python 2 and we stop shipping it due to upstream deprecation)
Packages (pkg)

Binary software is installed using pkg, which uses our software repository (available via multiple mirrors). All installed software can be found via the user interface System -> Firmware ->Packages, but in some situations people want to install additional software via the command line of the machine itself.

To find a full list of all software available, you can use the following command:

pkg rquery '%n (%v)'

If, for example you would like to install the gnu nano editor, you can do so using the following command:

pkg install nano

Note

OPNsense® is a firewall distribution, we aim to keep our footprint as small as possible. This means that we don’t build all the software available in the world. If you need a specific package for your use-case, you could always ask via a support ticket on GitHub, but note that packages not used by our core system or a supported plugin would not be guaranteed in the future (build contents may change over time).

Warning

Adding (FreeBSD, ..) repositories in /usr/local/etc/pkg/repos/ manually is not supported and usually lead to unexpected issues. Before reporting any type of issue with such setups, we kindly ask you to revert to a standard setup first.
The ports tree

In case you are using software, which is not supplied by us, you can always build these packages yourself. It’s best to use our build system to facilitate this, you can do so using the following commands

opnsense-code ports
cd /usr/ports/your/port
make install

To update a package, the following command can be used instead:

opnsense-code ports
cd /usr/ports/your/port
make reinstall

It might be necessary for some ports to also install the source tree:

opnsense-code src

Note

There are a lot of resources available about building ports packages, such as https://www.freebsd.org/ports/ and the pointers in our documentation and tools. We consider building custom software a feature not usable for beginners, before creating support tickets, make sure you have the necessary skillsets needed to perform such tasks.


Changelogs

OPNsense core offers a changelog of the core and the plugins may offer their own changelog, if they are growing rapidly so the changelog does not fit into core anymore.
Core

Core offers a changelog section in the area System ‣ Firmware as an own menu or the dialog will automatically open in case of an available update.

To open a changelog manually, you can open the Changelog tab, and click the book:
../../_images/changelog_book_icon.png

After opening the changelog, you will get an entry like this one:
../../_images/changelog_entry.png

The changelog entries can be found at different places:

    Forum: https://forum.opnsense.org/index.php?board=11.0

    GitHub: https://github.com/opnsense/changelog/tree/master/community

    Blog: https://opnsense.org/blog/

Plugins

The plugins changelogs can be found in the plugins section after clicking the info button of the plugin (Plugins tab in Firmware).
../../_images/changelog_plugins_info_nginx.png

After the description of the software behind the plugin or the plugin itsef, the changelog follows.


Serial Access
../../_images/serial_bootloader.png

Besides the web frontend, SSH and a locally connected monitor (if your device supports it), OPNsense can also be controlled via serial. Accessing OPNsense via serial is similar to accessing via SSH, but unlike SSH, the system can be accessed at any time, even when OPNsense is not accessible over the network. This makes it especially useful for installing OPNsense, for emergency troubleshooting when you accidentally cut off internet access as well as for major system upgrades.
Requirements

    OPNsense installation must provide a serial interface (virtual or hardware)

    Software which can be used to access the serial interface (screen, minicom, PuTTY etc.)

For a bare metal installation, you also need the following (unless provided though a management interface differently, please refer your server manual):

    a null modem cable

    if you don’t have an RS232 port on your computer, you need an USB to RS232 converter

Connecting to the serial console

If you already installed OPNsense via a non-serial installer, serial access needs to be turned on. To do this, open the web interface, navigate to System ‣ Settings ‣ Administration, scroll down to ‘Console’ and set the primary or secondary console to ‘Serial console’. Note: this is only necessary if you already installed OPNsense, and did not use the serial installer to do so. In all other cases (accessing BIOS, running the serial installer, connecting to an installation that was done via serial), serial access is already available.

On Unix-like systems, you can connect to the serial console using the screen program, with a baud rate of 115200. The device name can differ per system and per serial device. Examples of names are:

    /dev/ttyS0 (serial port, Linux)

    /dev/ttyUSB0 (usb-to-serial, Linux)

    /dev/cuau0 (serial port, FreeBSD)

    /dev/cuaU0 (usb-to-serial, FreeBSD)

    /dev/tty.usbmodem1112421 (usb-to-serial, macOS)

    COM1, COM2, … (Windows)

Note

If you have multiple devices of the same type like shown here:

    # ls /dev/ttyUSB*

    /dev/ttyUSB0  /dev/ttyUSB1

You can disconnect one of them to see which one is left or you can read the dmesg log to get the vendor information for the device node. You can search for a message containing “now attached to ttyUSB1” to find out which device it is. Afterwards you can compare the previous output to the output of a tool like lsusb.

For example, on the Deciso DEC630, accessed from macOS, the device is named /dev/tty.usbmodem1112421. Entering the serial console thus involves opening a terminal and executing the following instruction:

screen /dev/tty.usbmodem1112421 115200
# or
minicom -b 115200 -D /dev/tty.usbmodem1112421

Note

Access to the device is likely to be access restricted. You should run the command as root because running it as a user may lead to an access denied error on Linux / BSD.

If OPNsense is running, you will now be asked for your username and password if authentication is enabled. Otherwise the menu is displayed (at least after pressing enter). The credentials are the same as those used for SSH.

A thing to note is that the screen won’t always auto-update. If you connect and see no output, try pressing Enter first before checking the other (more complex) possibilities. Another thing is that, when connecting via screen, you might not be able to scroll (but you can still pipe the output through a pager like more or less).


Installing OPNsense AWS image
../../_images/amazon-web-services.png

Our EC2 image is available in the aws marketplace.
Step 1 - New Instance

To start a new instance go to “instances”, followed by “launch instance” in your EC2 view.

Next go to “AWS Marketplace” and search “OPNsense”. Our official image is sold via Deciso Sales B.V..
../../_images/aws_step1_choose_ami.png
Step 2 - Select Type

Choose an instance type
../../_images/aws_launch_new_image.png
Step 3 - Configure Instance Details

Here you can configure your network details, by default a network is assigned which is accesible from an external IPv4 address.

At the bottom of the page you can also supply “User data” in the “Advanced Details” section, you can use this to set an initial password for the ec2-user.

Note

When a password is omited, one will be automatically generated for you and displayed on the console (get system log).
Step 4 - Add Storage

Here you can change the initial storage size and type of volume to use.
Step 5 - Add Tags

Optionally you may add tags to the instance, it’s safe to leave this empty.
Step 6 - Configure security group

To configure security group, make sure you allow HTTPS access from your own network. Since SSH is also enabled by default on these images, you may enable port 22 (SSH) too from your network.
../../_images/aws_configure_security_group.png
Step 7 - Review your settings
../../_images/aws_review_settings.png
Step 8 - SSH keypair

Select ssh keypair or skip, the selected ssh key is attached to the ec2-user, you can change this afterwards from the usermanager. (System -> Access -> Users).
../../_images/aws_ssh_keypair.png
Step 9 - Review status page
../../_images/aws_status.png
Step 10 - AWS instances

Go to your AWS instances
../../_images/aws_instances.png

Select the image, go to “image settings” then “get system log” to obtain the initial password for the ec2-user (if not specified in the user data) and the initial root password.

Note

Sometimes it can take a bit of time before the console settings appear in the “system log”, in our experience the output is available when the Status check reports it’s finished.
Step 11 - Initial root password

Copy your initial root password (line ** set initial….)

.....
Configuring system logging...done.
>>> Invoking start script 'aws'
**********************************************************************************************************
*** set initial ec2-user password to : J4heQUAaRWJFGkXrfUKssjQ9jyFiBmaRgqaBiYRK7iiL2lUtvG
*** !!! remember to change this immediately
*** openssh-key provided, set to ec2-user
*** set initial root password to : SNFpd2lcefYXXjyRezPrloTWTF3LjhgZPV3zLuDxEdVkiBGWxn
*** remember to change this immediately
**********************************************************************************************************
>>> Invoking start script 'newwanip'
Reconfiguring IPv4 on xn0: OK
Reconfiguring routes: OK
>>> Invoking start script 'freebsd'
>>> Invoking start script 'syslog-ng'
Stopping syslog_ng.
Waiting for PIDS: 57924.
Starting syslog_ng.
>>> Invoking start script 'carp'
>>> Invoking start script 'cron'
Starting Cron: OK
>>> Invoking start script 'beep'
Root file system: /dev/gpt/rootfs
Sat Feb  5 17:58:45 UTC 2022

*** OPNsense.localdomain: OPNsense 21.7.7 (amd64/OpenSSL) ***

 WAN (xn0)       -> v4/DHCP4: 172.31.27.130/20

 HTTPS: SHA256 52 87 3F 28 48 59 A3 7D 59 66 26 36 01 2C 77 61
               FB 8E 78 C8 C4 C4 80 2C 97 C6 67 AA CB 28 48 60
 SSH:   SHA256 pwupAQ6U+TOKoI1NAvcFpKF90Is02W0YMem7CNPG9j8 (ECDSA)
 SSH:   SHA256 +JOMcgZ14lUnUxp4jEbEWf7Q+OvHJufvjhFzybJG1/M (ED25519)
 SSH:   SHA256 2mR9csHFwDgBl7SGfOPeW2r9E15zMP9OuMpHnBrGwUI (RSA)


FreeBSD/amd64 (OPNsense.localdomain) (ttyu0)



login:

Tip

When the ec2 console doesn’t show the initial password you can also use the configured ssh shell to reset the root password using sudo /usr/local/sbin/opnsense-shell and option 3 in the menu.
Step 11 - Search current address and login
../../_images/aws_search_current_ip.png

Login to OPNsense using the address provided.


Installing OPNsense OVA image

OPNsense is available as an Open Virtual Appliance (OVA) package, which can be deployed in various virtualization products (e.g. VMWare, Virtualbox).

The image is not provided as a community free download, but can be acquired from Deciso.

In this document we describe the simple steps when deploying in VirtualBox, other supported platforms function quite similar.
Step 1 - Import appliance

In the top menu, choose File ‣ Import appliance and select the image you downloaded, it should show a dialog like the following.
../../_images/ova_import_dialog_1.png

Just click import, accept the license and the image should be transferred to your machine.
Step 2 - Network setup

The OVA template comes with two interfaces configured by default (you can add more later if needed). Always choose the right type of network before using OPNsense, the imported adapters might not be assigned to a type after import.

Note

Please be aware that the order of the network cards in the virtualization product may differ from how they are presented to the operating system. In VirtualBox “Adapter 1” seems to connect to WAN (em1)
Step 3 - Initial configuration

The virtual machine is operational now, initial configuration is performed similar to other setups, as described in Initial Installation & Configuration.


OPNsense Azure Virtual Appliance

OPNsense is a fully featured security platform that secures your network with high-end features such as inline intrusion prevention, virtual private networking, two factor authentication, captive portal and filtering web proxy. The optional high availability setup ensures stable network performance with automatic failover and synchronised states, minimising disruption. Keep your network secure and the good packets flowing.

The Virtual Appliance is available on the Microsoft Azure Marketplace (here).
../../_images/azure_offer.png

Our installation manual will guide you through a simple installation scenario using 1 network interface, for more advanced network setups you best checkout the Azure documentation.
Setup : Basic settings

The Marketplace create button guides you to the initial virtual machine setup, choose your subscription and system preferences here and name your virtual machine.
../../_images/azure_deploy_basics.png

Next make sure you create an initial administrative user, since some names are reserved (like admin and root), you need to choose another one here. In our example we choose adm001 here.

Note

You can enable the root user after installation, the setup user can access the system using ssh or https after installation todo so.
../../_images/azure_deploy_basics_user.png
Setup : Disks

Next you can choose a disk type to use, standard SSD is fast enough for most workloads.
../../_images/azure_deploy_disks.png
Setup : Network

For our example, we kept our settings simple using a private IP which is accessible over port 443 (https) after bootup. Most settings can be changed after deployment.
../../_images/azure_deploy_network.png

Note

Microsoft has quite some information available about different networking settings and options here
Create

Proceed to Review + create to finalize the deployment.
Login to your instance

When the virtual machine is created and booted for the first time, you can login using the assigned user (adm001), now you can enable the root user if you like in System -> Access -> Users
../../_images/azure_startup_users.png

Note

Our Azure virtual appliance has ssh enabled by default, you can change these settings in System -> Settings -> Administration


Official hardware
_images/DEC4280-Rendering-v10-schuin.jpg

This chapter contains topics around official OPNsense supplied equipment.

    Quickstart / getting started
    Default Configurations
    Serial Console connectivity
    BIOS updates / settings
    SFP(+) Compatibility


Quickstart / getting started
Intro

After opening the box of your just delivered appliance, there should be a quickstart included. Your OPNsense® appliance has been pre-installed with the OPNsense® Business Edition software

This quickstart applies to all of the devices acquired from the OPNsense® Shop (https://shop.opnsense.com/), which includes the following series:

Serie
	

Formfactor
	

Range
	

Network driver(s)

DEC6XX
	

Desktop
	

Entry level
	

igb

DEC7XX
	

Desktop
	

Midrange
	

igb, ax

DEC8XX
	

Desktop
	

Enterprise
	

igb, ax

DEC26XX
	

Rack
	

Entry level
	

igb

DEC27XX
	

Rack
	

Midrange
	

igb, ax

DEC38XX
	

Rack
	

Enterprise
	

igb, ax

DEC40XX
	

Rack
	

Enterprise / Datacenter
	

igb, ax, [ice]
Port assignments

The Ethernet ports of the appliance are assigned as follows:

Port 0 is assigned to LAN with IP address 192.168.1.1 and has a DHCP Server running with IP range from 192.168.1.100 to 192.168.1.199.

Port 1 is assigned to WAN and uses DHCP Client to obtain an IP-address.

Additional ports available on the device are left unconfigured, you can assign them later using Interfaces->Assignments.

Note

Ports on the devices are all numbered, 0-X (e.g. 0,1,2) for all 1 gbps standard ethernet ports, X0-XX for SFP+ ports (e.g. X0, X1), XXV0-XXVX for SFP28 ports (e.g. XXV0, XXV1). The numbering corresponds with the driver numbering, e.g. port 0 is usually igb0, see the product range for drivers used in the different models
Console connectivity

The supplied USB-cable can be used to gain console access (settings are: 115200 8N1). Console access is restricted with a login. Use the following credentials:

    user : root

    password : opnsense

Web interface

To gain access to the web interface (default IP: 192.168.1.1) use the following credentials:

    user : root

    password : opnsense

Next steps

After performing basic setup, activate your OPNsense Business Edition license token and then update your system or change to community when not planning to use the supplied license. (The firmware update module is located at System>Firmware>Settings)

Option 1: use Business Edition license
../_images/quickstart_be.png

Option 2: use Community Edition
../_images/quickstart_community.png

Note

The OPNsense Business Edition license token is sent by email including instructions on how to activate.

Tip

Always update your device after gaining access to the internet, updates are usually available once the device reaches your destination. Just go to the status tab in the firmware section, press “check for updates” and install the pending updates.

Default Configurations

Since our firewall configuration is fully enclosed in a single xml file, we can offer the factory configurations in case a machine needs to be reinstalled at some point in time.

Below you will find the list of our currently available models:

Model
	

Formfactor
	

config

DEC675
	

Desktop
	

22.1/22.4 22.7/22.10 23.1 ... 24.4

DEC695
	

Desktop
	

22.1/22.4 22.7/22.10 23.1 ... 24.4

DEC740
	

Desktop
	

22.1/22.4 22.7/22.10 23.1 ... 24.4

DEC750
	

Desktop
	

22.1/22.4 22.7/22.10 23.1 ... 24.4

DEC840
	

Desktop
	

22.1/22.4 22.7/22.10 23.1 ... 24.4

DEC850
	

Desktop
	

22.1/22.4 22.7/22.10 23.1 ... 24.4

DEC2685
	

Rack
	

22.1/22.4 22.7/22.10 23.1 ... 24.4

DEC2752
	

Rack
	

22.1/22.4 22.7/22.10 23.1 ... 24.4

DEC2770
	

Rack
	

22.1/22.4 22.7/22.10 23.1 ... 24.4

DEC2750
	

Rack
	

22.1/22.4 22.7/22.10 23.1 ... 24.4

DEC3842
	

Rack
	

22.1/22.4 22.7/22.10 23.1 ... 24.4

DEC3840
	

Rack
	

22.1/22.4 22.7/22.10 23.1 ... 24.4

DEC3852
	

Rack
	

22.1/22.4 22.7/22.10 23.1 ... 24.4

DEC3850
	

Rack
	

22.1/22.4 22.7/22.10 23.1 ... 24.4

DEC3862
	

Rack
	

22.1/22.4 22.7/22.10 23.1 ... 24.4

DEC3860
	

Rack
	

22.1/22.4 22.7/22.10 23.1 ... 24.4

DEC4020
	

Rack
	

22.1/22.4 22.7/22.10 23.1 ... 24.4

DEC4040
	

Rack
	

22.1/22.4 22.7/22.10 23.1 ... 24.4

DEC4240
	

Rack
	

22.1/22.4 22.7/22.10 23.1 ... 24.4

DEC4280
	

Rack
	

22.1/22.4 22.7/22.10 23.1 ... 24.4

Serial Console connectivity

The following device families offer a mini-usb connection which can be used for serial communication:

Serie
	

Formfactor
	

Range

DEC6XX
	

Desktop
	

Entry level

DEC7XX
	

Desktop
	

Midrange

DEC8XX
	

Desktop
	

Enterprise

DEC26XX
	

Rack
	

Entry level

DEC27XX
	

Rack
	

Midrange

DEC38XX
	

Rack
	

Enterprise

DEC40XX
	

Rack
	

Enterprise / Datacenter

Supplied with the firewall is a mini-usb to usb cable, use this to connect the to your PC (Windows, Linux, Mac) next start your terminal program (Putty, screen, etc).

The baudrate should be set to 115200,8N1, more information about how to use the serial console is available in our serial access guide

Note

The default configured settings in OPNsense for proper serial connectivity in System->Settings->Administration are as followed:

setting
	

value

Primary Console
	

Serial Console

Secondary Console
	

None

Serial Speed
	

115200

USB-based serial
	

(unchecked)

Console menu
	

(checked)

Windows Tip

On windows a COM port would be assigned after connecting the unit to usb, to find which one (COM1, COM2, .,) to use, keep the windows key pressed and hit R (Windows+R) and execute the following command devmgmt.msc to open the device manager.

In the device manager all available ports are visible under the “Ports (COM & LPT)” section.
Legacy UART vs. UEFI serial

Starting from OPNsense 22.1 (22.4 for the business edition) and the change to FreeBSD 13-STABLE, support for EFI serial has changed, which requires EFI based systems to disable legacy support to prevent confusing the operating system. Should you connect your Deciso appliance with a serial line and get limited output / no output from the point of handover to the OS, it is important your BIOS settings are updated to disable legacy UART.

While in the BIOS, go to Setup Utility –> AMD CBS –> FCH Common Options –> UART Configuration Options –> UART 0 Legacy Options. and make sure this setting is set to Disabled.


BIOS updates / settings

This page is dedicated to the latest BIOS update downloads for Deciso appliances as well as a generic instruction on how to install them.

Table of Contents

    Product families

        DEC800, DEC3800 & DEC4000 series

        DEC700 and DEC2700 series

    Installation instructions

    Hyper threading

    Microcode updates

Product families
DEC800, DEC3800 & DEC4000 series

06-2024 Version 15

Download
	

SHA256 Checksum

Archive
	

9089a1875617fedf0ae634515d31e683e67f494ae55df8cfcac2db6edfb00888

CVE Update.
DEC700 and DEC2700 series

05-2024 Version 30

Download
	

SHA256 Checksum

Archive
	

2d5143f221fa120ef6d5c8799a90bd2c08e8238b3b9dd350327336d0605944a6

CVE Update.
Installation instructions

Updating the UEFI firmware requires writing a bootable image to a USB drive on a separate machine. Make sure you have an empty or unused USB drive before starting this procedure. Also make sure the USB drive is FAT32 formatted.

Warning

As a general warning, following this procedure is at your own risk.

Step 1

Download the latest BIOS archive file for your platform from the downloads section above.

Step 2

Verify the SHA256 checksum.

Step 3

Insert the USB drive into your computer and extract the archive to the USB drive. Make sure the file structure is as follows:

USB drive:/
├── LATEST.FD
├── startup.nsh
├── H2OFFT-Sx64.efi
├── efi/
│   ├── boot/
│   │   ├── Bootx64.efi

Step 4

Safely remove the USB drive from the computer and plug it into the appliance.

Step 5

Connect to the appliance using a Serial Console connectivity connection. Open a terminal to the relevant COM port.

Step 6

Boot the appliance and enter the BIOS by pressing Escape. The current BIOS version (suffix) should show up. Make note of it so you can compare it to the new version to verify everything went well.

Step 7

Go to Setup Utility –> AMD CBS –> FCH Common Options –> UART Configuration Options –> UART 0 Legacy Options. Make sure this setting is set to Disabled. This is explained in Legacy UART vs. UEFI serial.

Note

Should your serial terminal highlight a BIOS option selection in such a way that it is unreadable, for the A20 appliance it’s the very first option in the UART Configuration Options menu screen.

Step 8

Select Boot manager and boot the USB drive. The UEFI shell will take over and execute the necessary BIOS update. If the update is complete, the machine will power off. Do NOT do anything until the machine has shutdown.

Note

Should the USB drive not show up, something went wrong during writing. The newly created FAT32 partition should be the very first block on the drive. Inspect the drive on a different machine to check the layout.

Step 9

Reboot the machine and check the new BIOS version in either the boot log or the BIOS itself.
Hyper threading

Selected models do support hyper threading, but as effectiveness depends on workload, we tend to disable it by default. If you do want to enable it when supported, enter the setup utility and search for the following menu item:

    AMD CBS -> Zen Common Options -> Core/Thread Enablement -> SMTEN

Select Auto here to enable the feature.
Microcode updates

Microcode patches are distributed in our EFI firmware updates. If a Microcode update is required to address specific issues which are deemed important enough by AMD/Intel, you can install the microcode update yourself in a timely manner by using the CPU Microcode updates [AMD/Intel] plugin.

SFP(+) Compatibility

Most OPNsense® appliances feature 10 Gigabit SFP+ cages powered by AMD® axgbe to allow for flexible connectivity. Different SFP(+) transceiver modules can be used to connect to different types of media (e.g. copper or fiber) depending on your needs.

Our enterprise & datacenter OPNsense® appliances may also feature 25 Gigabit capable SFP28 cages powered by Intel® ice.

Below you can find some general information as well as a list of tested SFP(+)/SFP28 transceiver modules that are verified to work with OPNsense® appliances.

Tip

If you are using an SFP(+)/SFP28 module on one of the OPNsense® appliances that is not listed below but is working properly, consider submitting a Pull Request to our documentation to extend the list. Any contribution is welcome!

Table of Contents

    General Information

    Axgbe

        1G Single-mode optical fiber

        1G Multi-mode optical fiber

        10G Single-mode optical fiber

        10G Multi-mode optical fiber

        1G Copper RJ45

        10G Copper RJ45

        10G Direct-Attach

    ICE

        25G Single-mode optical fiber

        25G Multi-mode optical fiber

        25G Direct-Attach

General Information

There are a lot of transceiver modules available on the market and they are usually one of the following types:

    Copper RJ45

Often used for connectivity up to a distance of 100 meters maximum and are relatively inexpensive.

Warning

RJ45 SFP+ modules (10GBASE-T) can run at high operating temperatures in comparison to Fiber or DAC modules. Only the datacenter level OPNsense® appliances are equipped with passive cooling for the SFP+ cages. If the ambient temperature does not exceed 50°C, RJ45 SFP+ modules can be used in all OPNsense® appliances without issue.

    Single-mode optical fiber (SMF)

Often used for communication across large distances (100+km) and usually connected with either Simplex-LC or Duplex-LC OS2 patch cords. It can potentially carry more bandwidth than Multi-mode fiber, but the equipment needed to use SMF is often more expensive in comparison to MMF.

    Multi-mode optical fiber (MMF)

Multi-mode fiber is the alternative for SMF (up to 550M for 10Gb/s), often used for backbone applications in buildings and usually connected with OM3 Duplex-LC patch cords.

    Direct-Attach (DAC)

For short ranges (up to 10M), often a popular choice due to low cost and low latency.

Attention

Most transceiver modules are available for purchase with a variety of different programming options for compatibility with different vendors. Unless specified otherwise, all modules are assumed to have the generic / MSA standard default programming.
Axgbe

Note

10 Mbit/s is currently not supported by Axgbe.
1G Single-mode optical fiber

Vendor
	

Type
	

Speed
	

Notes

BeanField
	

100BASE-BX0-D53
	

100Mb
	

FlexOptix
	

S.B1312.20.DL BiDi LX
	

1G
	

Tested module rated for 20km, other distances are assumed to function properly

FlexOptix
	

S.B1312.10.D
	

1G
	

Tested module rated for 10km, other distances are assumed to function properly

FS
	

SFP-FE-BX
	

100Mb
	

FS
	

SFP-GE-BX
	

1G
	

MikroTik
	

S-53LC20D
	

1G
	

TP-Link
	

1000Base-BX WDM Bi-Directional
	

1G
	

Ubiquiti
	

UACC-OM-SM-1G-S
	

1G
	
1G Multi-mode optical fiber

Vendor
	

Type
	

Speed
	

Notes

FlexOptix
	

S.8512.02.D
	

1G
	
10G Single-mode optical fiber

Vendor
	

Type
	

Speed
	

Notes

FlexOptix
	

P.1396.10 SMF 1310nm Duplex-LC
	

10G
	

Tested module rated for 10km, other distances are assumed to function properly

FlexOptix
	

P.B1696.10.DA + P.B1696.10.AD
	

10G
	

Simplex-LC. Two complementary modules are needed.
10G Multi-mode optical fiber

Vendor
	

Type
	

Speed
	

Notes

Cisco-Finisar
	

SFP-10G-SR
	

10G
	

FS
	

SFP-10GSR-85
	

10G
	

FS
	

SFP-10/25GR-85
	

10G
	

IBM-Finisar
	

FTLX8571D3BCL-IC
	

10G
	

Intel
	

AFBR-709DMZ-IN2
	

10G
	

Mellanox
	

MFM1T01A-SR
	

10G
	

Ubiquiti
	

UF-MM-10G
	

10G
	

Uptimed
	

UP-TR-SR-CI 10G
	

10G
	
1G Copper RJ45

Vendor
	

Type
	

Speed
	

Notes

FS
	

SFP-GB-GE-T
	

10/100/1000Mb
	

HP (Aruba)
	

Instant On
	

1G
	

MikroTik
	

S-RJ01
	

10/100/1000Mb
	

StarTech
	

GLCTST
	

1G
	

Ubiquiti
	

UF-RJ45-1G
	

10/100/1000Mb
	
10G Copper RJ45

Vendor
	

Type
	

Speed
	

Notes

FS
	

SFP-10G-T
	

10G
	

Uptimed
	

UP-TR-10G-RJ45-CI
	

1/2.5/5/10G
	

Will always link at 10G on axgbe, maximum speed is determined by link partner

FlexOptix
	

T.C96.02.KMF
	

1/2.5/5/10G
	

Will always link at 10G on axgbe, maximum speed is determined by link partner
10G Direct-Attach

Vendor
	

Type
	

Speed
	

Notes

Aruba
	

SFP+ DAC
	

10G
	

Cisco
	

SFP-H10GB-CU1M
	

10G
	

FS
	

SFPP-PC02
	

10G
	

MikroTik
	

XS+DA0001
	

10G
	

Rated for 1/10/25G, only links on 10G

Netgear
	

AXC761
	

10G
	

Startech
	

DACSFP10G1M
	

10G
	

Ubiquiti
	

UniFi 1m DAC
	

10G
	
ICE
25G Single-mode optical fiber

Vendor
	

Type
	

Speed
	

Notes

FlexOptix
	

P.B1625G.10.ADI
	

25G
	

Tested module rated for 10km, other distances are assumed to function properly
25G Multi-mode optical fiber

Vendor
	

Type
	

Speed
	

Notes

FlexOptix
	

P.8525G.01
	

25G
	

FS
	

SFP28-25GSR-85
	

25G
	

Uptimed
	

UP-SFP28-SR-CI
	

25G
	
25G Direct-Attach

Vendor
	

Type
	

Speed
	

Notes

FlexOptix
	

P.C3025G.H Passive
	

25G
	
Lobby
_images/architecture-building-ceiling-lamp-260931.jpg

The lobby is the entrance to your (virtual) security appliance, where you can find your dashboard, change your password and end your session. After initial installation, this is the first place you will visit.

    General User Interface
    Dashboard
    Password
    OPNsense Tools


General User Interface

This article explains the basics of the OPNsense Graphical User Interface or GUI for short.
User Login

Before we can take a look at the GUI options we need to login. The default user is root and the password is opnsense.
../_images/login.png
GUI Layout & Main Components

The GUI consists out of the following main components:
../_images/gui_layout.png
Logo & Link to Lobby

Click on the OPNsense logo wherever you are in the interface and you will be directed to the lobby and dashboard.

In the Lobby you can:

    Look at the dashboard with widgets

    View the 2-clause BSD license

    Change your password

    Logout

Menu Area

The Menu area holds all the primary menus and submenus. Here you can select what part of the system you want to watch or change.

You can see the layering on the menu. There are three levels:

    Category level

    Function level

    Configuration level (may not exist if the function is simple)

In the following sample you see a screenshot of the Category System, with:

    Function: Settings

    Selected Configuration item: General

../_images/submenu.png
Quick Navigation

A faster way to navigate trough the GUI is by using the quick navigation/search box on the upper right corner of the screen. Either click on it or hit tab to select it.

The search field is a type-ahead field, meaning that it will guess what you are looking for and fill up while typing. Hit Enter or click on an option to select and navigate directly to the right page.
../_images/quick-navigation.png
System Status

In the upper right corner of the screen is also a small indication of the system status. In a normal situation this will be greyed out, but it will display a color if something is wrong. You can click on it to review any of the pending messages, if any:
../_images/gui_system_status.png

The colors indicate the severity of the issue. They are:

    Red. Indicates that an error has occured during system operation. Click it to go to the relevant page. In most cases this will be the crash reporter, which you can use to send us information about the crash.

../_images/gui_system_status_error.png

    Yellow. Indicates a warning.

    Blue. Indicates an informational message.

    Grey. Everything is working as normal.

User & Local domain

In the right corner just to the left of the system status you will see your username and the full domain name the firewall is configured with (to change firewall name, go to System ‣ Setting ‣ General).
Content Area

The content area is used to display:

    Input forms

    Popup Forms

    Buttons

    General forms of data output graphical and text based

Form View

Let’s take a look at how an advanced form may look like:
../_images/proxy_form.png
Full Help

Many forms are equipped with built-in help. In the upper right corner of the form you can select to view all help messages at once. The toggle will color green when enabled and show the help messages beneath the input items.
../_images/help_msg.png
Advanced Mode

Some forms have hidden advanced features, to view them toggle the advanced mode in the left corner of the form. Doing so will reveal all advanced options.
../_images/advanced.png
Single Item Help

Show a single line help by pressing the (i) left of a form item. Like this:
../_images/info.png
Standard Tabs

A standard tab can be clicked upon to open the corresponding form.

A sample can be seen here:
../_images/tab.png
Dropdown Tabs

A dropdown tab can be clicked upon to open the first menu item or you can click on the arrow next to it to show all options, like so:
../_images/dropdown_tab.png
Data grids

Many components within OPNsense use grid views to navigate through content, below is an example of a simple table view supporting the most relevant actions.
../_images/gui_grid.png
Fields
The available fields vary between components, the icon can be used to select which fields should be visible or hidden.

Filter and limit
The top area of the grid contains a search input combined with a reload button and a selection for the number of rows to show at once on a page. Often the search input will be instantly applied, but in some cases a reload is needed if the action can't be processed fast enough.

When using the filter in log files, you will find a Go to page action behind every record. This will jump to the corresponding page and show you all surrounding records so you can see the context of a log message.

The search input tokenizes space-delimited words, causing the filter to return records matching all of the clauses included in the search phrase.
Actions
Different actions could be supported on a (set of) records:

    / Enable / disable a record
    Edit a record
    Copy a record and edit
    Delete a record, usually this will ask for a confirmation
    Add a new record and open edit dialog



Page Navigation

The navigation buttons « ‹ [1,2,..] › » help scroll through the different pages that are available for the selected data.

Note

Although the page numbers and last page button (») are always visible, they can only be used when the size of the dataset is known upfront. In case of large datasets, such as intrusion alerts and log views the number of records is not known upfront, since there’s no relation between the size of the underlaying data and the number of records.

The record count in these cases is more or less a guestimate based on the number of records already shown.


Dashboard

The Dashboard is the first page you will see after you log into OPNsense. Additionally, it can be accessed via Lobby ‣ Dashboard. The Dashboard provides an overview of your system status.
Configuration

What is shown on the Dashboard can be configured by adding and removing widgets. Some widgets also allow further configuration.

By default, the following widgets are present:

    System Information: Shows information about the installed OPNsense version, updates etc.

    Memory Shows memory usage.

    Disk Shows disk usage.

    CPU Shows CPU usage.

    Announcements Shows the latest announcements from the OPNsense project.

    Gateways: Shows used gateways.

    Interface Statistics Shows the number of packets, bytes and errors handled by each interface.

    Firewall Collects logged events from the moment the dashboard has loaded to represent a snapshot of what the firewall is currently seeing. Can be expanded to show a live log.

    Traffic Graph Shows traffic passing through the system.

In the upper right corner of every widget, there can be two buttons:

    Edit (pencil icon): Click this to modify the widget settings. This button is only present if the widget is configurable.

    Remove (cross icon): Removes the widget from the Dashboard.

In the upper right corner of the page, there are two or three buttons:

    Add widget: Opens a dialog window with a list of widgets that can be added to the Dashboard. Simply click on an entry in the list to add it to the Dashboard.

    Save Settings: When you change the amount of columns or collapse a widget, you can make that change persistent by clicking this button. Otherwise the changes will be discarded as soon as you reload the page.

    Lock Locks the dashboard so you cannot move, remove or resize widgets. New widgets can still be added. This change is persisted and is useful to navigate the dashboard on a mobile device.

All widgets can be resized by dragging on one of the corners of the widget. The widget will snap to the grid, so it will always fit in the available space.

Note

The dashboard configuration is saved per user. This means that each user can have their own dashboard layout.


Password

The password page in the lobby offers the user the ability to change his or hers password and default settings.

When The option User OTP seed is enabled in the System->Settings->Administration page, one could also acquire a new OTP seed here.

Warning

Changing an OTP seed automatically invalidates the previous one, so only request a new one when you are able to scan the new one using your mobile phone.


OPNsense Tools

The OPNsense project offers a number of tools to instantly patch the system, revert a package to a previous (older version) state or revert the whole kernel.
opnsense-update

The opnsense-update utility offers combined kernel and base system upgrades using remotely fetched binary sets, as well as package upgrades via pkg. For a complete list of options look at the manpage on the system.
Example:

A minor update also updated the kernel and you experience some driver issues with your NIC. Open your browser and go to

https://pkg.opnsense.org/FreeBSD:11:amd64/18.1/sets/

Here you can see all the kernels for version 18.1. Be aware to change the version if you are on a newer version. As an example you updated from 18.1.4 to 18.1.5 you have now installed kernel-18.1.5. To revert back to the last stable you can see kernel-18.1 so the syntax would be:

# opnsense-update -kr 18.1

# opnsense-shell reboot

Where -k only touches the kernel and -r takes the version number.

To switch back to the current kernel just use

# opnsense-update -k

# opnsense-shell reboot

Warning

Before reverting a kernel please consult the forums or open an issue via Github. You should only revert kernels on test machines or when qualified team members advise you to do so!
opnsense-revert

The opnsense-revert utility offers to securely install previous versions of packages found in an OPNsense release as long as the selected mirror caches said release. For a complete list of options look at the manpage on the system.
Example 1:

The latest update of OPNsense to version 18.1.5 did a minor jump for the IPSec package “strongswan”. From this moment your VPNs are unstable and only a restart helps.

To check if the update of the package is the reason you can easily revert the package to its previous state while running the latest OPNsense version itself.

# opnsense-revert -r 18.1.4 strongswan

With this command you can, for example, run OPNsense 18.1.5 while using the 18.1.4 version of strongswan. If you want to go back to the current release version just do

# opnsense-revert strongswan
Example 2:

The previous revert of strongswan was not the solution you expected so you try to completely revert to the previous OPNsense version:

# opnsense-revert -r 18.1.4 opnsense

Be aware to also check if there were kernel updates like above to also downgrade the kernel if needed!
opnsense-patch

The opnsense-patch utility treats all arguments as upstream git repository commit hashes, downloads them and finally applies them in order. Patches can also be reversed by reapplying them, but multiple patches must be given in reverse order to succeed. For a complete list of options look at the manpage on the system.
Example 1:

In the Traffic Shaper a newly introduced typo prevents the system from setting the correct ipfw ruleset. You were asked by the developer to test a fresh patch 63cfe0a at URL https://github.com/opnsense/core/commit/63cfe0a96c83eee0e8aea0caa841f4fc7b92a8d0 At the end of the page there’s the short version 63cfe0a so the command would be:

# opnsense-patch 63cfe0a

If it doesn’t fix your issue or makes it even worse, you can just reapply the command to revert it.
Example 2:

You need a special feature for a plugin and ask in Github for it. A developer adds it and ask you to install the patch 699f1f2 for testing. The full link to it would be https://github.com/opnsense/plugins/commit/699f1f28a33ce0122fa0e2f5e6e1f48eb3c4f074

# opnsense-patch -c plugins 699f1f2

The -c changes the default core to plugin repo and adds the patch to the system.

It is also possible to add patches from different users, just add -a githubusername before -c


Reporting
_images/freelance-graphs-laptop-34069.jpg

Your firewall collects quite some information about its health and workload, the reporting section will provide insights into these.

    System Health & Round Robin Data
    Using Insight - Netflow Analyzer
    Netflow Export & Analyses
    Reporting Settings
    Reporting: Traffic
    Reporting: Unbound DNS

Setup guides

    Configure Netflow Exporter


System Health & Round Robin Data
../_images/systemhealth_sample.png

System Health is a dynamic view on RRD data gathered by the system. It can be accessed via Reporting ‣ Health. It allows you to dive into different statistics that show the overall health and performance of the system over time.

The system health module will enable you to track down issues faster and easier than traditional static RRD graphs and it allows you to zoom in.
Data collectors

System Health has the following primary data collectors:

Packets

    Packets show the number of packets per second traveling to and from a certain interface.
Quality

    Quality show latency and packet loss of the monitored gateways (ip).
System

    The system section is used for sensor data regarding the system utilization, such as memory usage, mbufs, states, processes and (when available) cpu temperature.
Traffic

    Shows traffic graphs for each interface including vpn (ipsec).

Depending on the features in use there may be more or less graphs available.
GUI Features Overview

Please see the screenshot below for all element of the system health module. Each element will be explained in the next chapters.
../_images/systemhealth_gui.png
Toggle menu collapse

This feature will show or hide the top menu.
Category Selection

The category items are tabs with drop down menu’s. Click on one of the categories and select the graph you like to dive into.
Graph Selection

Part of the drop down menu, where you can select the graph to view.
Select primary dataset

Select the RRD dataset you want to use. The more to the left the lower the maximum resolution. By default the graphs are opened with the highest available RRD resolution.
Inverse

By selecting Inverse each odd dataset is reversed in direction (times minus one), this is especially useful for traffic flows where you can plot ingoing and outgoing flows in different directions.
../_images/systemhealth_inverse.png
Resolution

The resolution determines the maximum number of datapoints that will be shown in the graph and therefore indirectly influences the scale of the calculated averages.
Hide/show table data

By default the table data is hidden, you can show it by toggling the Show Tables to On.

The table data area consists of the min/max/average and detailed table data area.
Name of the graph

Shows the name of the selected graph.
Current Detail Level

Since the data is dynamically rendered it will automatically calculate the averages and show you the current detail level in this area.
Label filter
../_images/systemhealth_labelfilter.png

The label filter can be used to filer out data you do not want to see. Click once to disable or double click to select only this set.

A nice sample can be seen here, where the processes obscure all other data.
../_images/systemhealth_obscureddata.png

Just click once on processes to hide this data set, notice that the scales will adapt as well.
../_images/systemhealth_filtered.png
Main graph area

The main graph area show the full graph or just the part you selected in the zoom area with more detail.
Zoom Area

The zoom area can be used to select and zoom in on one part of the graph, the scales are adapted automatically and any tables will be updated as well.

This feature is very useful to zoom in on issues or for showing just part of the graph.

To use, click on it and hold while moving your pointer to another part of the zoom area, on mouse up (release mouse click) the main graph area will be updated accordingly. The zoom area will also be updated with more detailed data - when available - for the selected area.

A sample selection:
../_images/systemhealt_selection.png

And the result:
../_images/systemhealth_zoomed.png
Min/max/average table

If Show Tables is on then this area will show: * Minimum value of each dataset * Maximum value of each dataset * Average value of each dataset
Detailed table

If Show Tables is on then this area will show each value that is plotted in the graph. You can toggle the time and date view from timestamp to human readable values and export the data to as comma separated file (.CSV).

The exported dataset can be used for your own reporting.
../_images/systemhealth_excel.png


Using Insight - Netflow Analyzer

OPNsense is equipped with a flexible and fast Netflow Analyzer called Insight. To use Insight, one needs to configure the Netflow exporter for local capturing of Netflow data. To do so take a look at Configure Netflow Exporter.
User Interface

Insight is a fully integrated part of OPNsense. Its User Interface is simple yet powerful. It can be accessed via Reporting ‣ Insight.
../../_images/insight_gui.png

Insight offers a full set of analysis tools, ranging from a graphical overview to a csv exporter for further analysis with your favorite spreadsheet.
Graphs & Totals

The default view of Insight is the Top users and Graphical Overview. This view allows for quick examination of current and past flows, showing a graph for in and out going traffic for each configured interface.
Select Range & Resolution

In the top right corner a selection can be made for the date range and accuracy (resolution) of the collected traffic flows.
View Type

One can show the traffic flows in a stacked manner (default), as a stream or expanded to compare usage with different interfaces.

Stacked
../../_images/stacked_view.png

Stream
../../_images/stream_view.png

Expanded
../../_images/expanded_view.png
Interfaces

Clicking on an interface disables or enables the graph view, double clicking select only that interface.
Top Users

The top 25 users are shown for a selected interface, both for ports and ips within the previously selected date range.
Interface Top

Select the interface to see the top 25 users.
Port Pie Chart

The port pie chart shows the percentage per port/application. One can change the view by clicking or double clicking on one of the shown port names/numbers.

Clicking on a piece of the pie will open a detailed view for further analysis.
../../_images/pie_piece.png ../../_images/pie_details.png
IP Addresses Pie Chart

The IP addresses pie chart works the same as the ports pie chart and shows the percentage per IP number. One can change the view by clicking or double clicking on one of the shown IP numbers.

Clicking on a piece of the pie will open a detailed view for further analysis.
Interface Totals

Not shown in the screenshot but latest version also includes a Total for the selected interface, shown are Packets (In, Out, Total) and Bytes (In, Out, Total).
Details View

One can open the details view by clicking on one of the pieces of a pie chart or click on the tab Details.

When opening the details view by clicking on the tab one can make a new query.
../../_images/insight_details_view.png

After selecting a valid date range (form/to) and interface one can further limit the output by filtering on port or IP address. Select the refresh icon to update the detailed output. Leave Port and Address empty for a full detailed listing.
../../_images/insight_full_details.png
Export View

The Export view allows you to export the data for further analysis in your favorite spreadsheet or other data analysis application.
../../_images/insight_export_view.png

To export data, select a Collection :

    FlowSourceAddrTotals - Totals per source address

    FlowInterfaceTotals - Totals per interface

    FlowDstPortTotals - Totals per destination port

    FlowSourceAddrDetails - Full details per source address

Select the Resolution in seconds (300,3600,86400)

Then select a date range (from/to) and click the export button.
../../_images/insight_export.png


Netflow Export & Analyses
../_images/netflow_analyzer_insight.png

Netflow is a monitoring feature, invented by Cisco, it is implemented in the FreeBSD kernel with ng_netflow (Netgraph). Since Netgraph is a kernel implementation it is very fast with little overhead compared to softflowd or pfflowd.

While many monitoring solutions such as Nagios, Cacti and vnstat only capture traffic statistics, Netflow captures complete packet flows including source, destination IP and port number.

OPNsense offers full support for exporting Netflow data to external collectors as well as a comprehensive Analyzer for on-the-box analysis and live monitoring.

OPNsense is the only open source solution with a built-in Netflow analyzer integrated into its Graphical User Interface. It can be accessed via Reporting ‣ Netflow.
Supported Versions

OPNsense support both Netflow version 5 (IPv4) and version 9 (IPv4 & IPv6).
Netflow Basics

For analyzing the flow data it is important to understand the difference between ingress and egress traffic.
Ingress

Traffic to or coming from the firewall.
Egress

Traffic passing trough the firewall.
Ingress + Egress = Double flow count

When enabling both ingress and egress, traffic gets counted double due to Network Address Translation as all packets going to the WAN coming from the LAN pass the Network translation of the firewall therefor also creating an ingress flow.

If you are not interested in ingress traffic then OPNsense offers the option to filter this traffic. When utilizing a proxy on the same device its important to capture the ingress flows as well, otherwise all proxy traffic won’t be visible. Downside is of course that all traffic not passing the proxy will be counted twice due to the mentioned NAT effect.
Netflow Exporter

OPNsense Netflow Exporter supports multiple interfaces, filtering of ingress flows and multiple destinations including local capture for analysis by Insight (OPNsense Netflow Analyzer).
../_images/netflow_exporter1.png
Netflow Analyzer - Insight

OPNsense offers a full Netflow Analyzer with the following features:

    Captures 5 detail levels

            Last 2 hours, 30 second average

            Last 8 hours, 5 minute average

            Last week, 1 hour average

            Last month, 24 hour average

            Last year, 24 hour average

    Graphical representation of flows (stacked, stream and expanded)

    Top usage per interface, both ips and ports.

    Full in/out traffic in packets and bytes

    Detailed view with date selection and port/ip filter (up to 2 months)

    Data export to csv for offline analysis

            Selectable Detail Level

            Selectable Resolution

            Selectable Dat range

../_images/netflow_insight_details.png
Configuration
Setup Netflow Exporter

See Configure Netflow Exporter
Setup Insight

See Using Insight - Netflow Analyzer


Reporting Settings

Some basic reporting settings and options can be found under Reporting ‣ Settings.

Unbound DNS is capable of collecting statistics for insight into DNS traffic. This behaviour is not enabled by default, but can be enabled in this page. You can also clear any collected data using the “Reset DNS data” button.

The Health reporting uses RRD collection, for which you can disable the statistics collection process, in cases where monitoring is not relevant or causes too much stress on the system. The option to collect statistics is enabled by default.

For both health monitoring (rrd) and network insights (netflow) statistics could be reset in this form.


Reporting: Traffic

Under Reporting ‣ Traffic you will find a traffic monitor which show the current amount of data flowing through your firewall, measured in bps (bits per second).
Graph
../_images/reporting_traffic_sample.png

The top area of the screen shows an overview of all network adapters for both in- and outgoing traffic. You can select the desired polling resolution with the dropdown left of the interface selection dropdown.

The graph below shows the top consumers over the same timespan, when you point to a dot it will show you the measured bandwith for the selected host (the color matches the interface).
Top talkers

Although the graphical overview also shows the most active clients on the network, sometimes it is more convenient to see the list of addresses and their current activity in a grid type overview. This is where the “Top talkers” tab comes into play, the information is quite comparable to what a command line tool as iftop would display:
../_images/top_talkers.png

When opening this tab you will be presented with the most active addresses, including the amount of traffic passed when measured and the last time traffic was seen from or to that address.

Every time the graph is updated, the grid will also be populated with new information.


Reporting: Unbound DNS

Starting from OPNsense 23.1, users are able to gain insight into DNS traffic passing through their Unbound DNS resolver using the reporting tool under Reporting ‣ Unbound DNS.

All data presented here is kept on the system for a total of 7 days, creating a rolling window into DNS traffic without allowing the system to take up boundless storage space.
Overview

The overview tab shows high-level DNS traffic data.

Counters

    The total amount of queries Unbound has handled, starting from the moment as reported above the counters. This will either be from the moment the gathering of statistics has been enabled, or up until the last 7 days. Keep in mind that the counter is as seen from the incoming side, and will increase regardless of the type of response returned.

    The amount of queries Unbound has successfully resolved. This counter does not distinguish between forwards or recursion, and excludes every other response type, such as responses from cache, local-data or a local policy such as a blocklist.

    The amount of queries Unbound has blocked. This is either because a queried domain was part of a blocklist, or part of a user-configured exact match as configured in Services ‣ Unbound DNS ‣ Blocklist.

    The size of the current blocklist (if any). This will equal the total amount of domains listed inside all the active blocklists.

Every query counter shows the percentage as part of to the total amount of queries.

Note

Adding up both the blocked and resolved queries does not equal the total amount, since the amount of responses from cache, local-data and other possible sources such as Unbound itself on e.g. a SERVFAIL are not shown.

Graphs

Also included in the report are two DNS traffic graphs, the first one being the query graph, and the second one being the client graph. Both graphs show the amount of incoming queries over a selectable span of time. The query graph also shows the amount of blocked queries. You can hover over the dots in the client graph to see which client it is, as well as the amount of queries associated with this client. If you proceed to click on this point of data, you will be referred to the Details grid containing every query within this time interval made by this client.

Both the query and client graph have the option to display the data on a logarithmic scale in order to catch outliers properly while preserving your perspective of the normal flow of traffic.

Top domains

On the bottom of the page the top 10 of both passed and blocked queries are shown. This includes the amount a domain has been requested, as well as a percentage of passed or blocked requests respectively. If you have blocklists enabled, you are also able to explicitly block or whitelist a specific domain from this top list with the click of a button. The relevant domains will show up in Services ‣ Unbound DNS ‣ Blocklist, under “Whitelist Domains” or “Blocklist Domains”.
Details

The details tab shows a livefeed of completed queries along with reply information. You can refresh the list by clicking the refresh button on the top right of the screen. In it you can find:

    Which client queried which domain with its associated DNS record type.

Note

It’s possible that a queried domain with a record type other than a CNAME (e.g. A or AAAA) might show as blocked with a CNAME as the record type in the details table. This is because a response to a query can contain CNAME records which ultimately point to the queried record type within the same answer (try doing a dig on www.azure.com for example). If any of these CNAME records contain domain names that occur within the configured blocklists, the blocklist system will also block this query, but can only do so after Unbound has resolved the relevant domain. The resolve time will therefore be higher on these types of block actions.

    The action taken by Unbound, this can either be pass, block or drop. The latter only occurs when a query could not be serviced due to an internal error. “Internal error” can be anything, ranging from a loss of internet connectivity to a crash of Unbound. The common factor is that Unbound marks the return code as SERVFAIL. If the Unbound logs do not show any reason for a drop occuring, the most likely candidate will be a loss of connectivity.

    The source of the response. This can be either Recursion, Local, Local-data or cache. ‘Local’ refers to a decision made by Unbound to either block or drop the query. ‘Local-data’ refers to the custom host overrides and its associated aliases or internal local-data entries generated by the system. ‘Cache’ shows responses to clients utilizing the cache.

    The return code of the DNS query. Refer to the IANA DNS Parameters for its meaning.

    If recursion is involved, how long in milliseconds it took to resolve a domain.

    The TTL of the final answer. Answers from recursion will always contain an upstream-defined TTL value, while answers from cache will show a snapshot of the remaining cache TTL value before recursion would have to take place again. Please note that TTL behaviour can be largely dependent on the settings used in Services ‣ Unbound DNS ‣ Advanced.

    The blocklist used if a query was blocked.

    Either a block or whitelist action button, which can be used in the same way as described above for the “Top domains” in the overview section. Please note that this column will not appear if blocklists are disabled.


Configure Netflow Exporter
../../_images/netflow_exporter.png

Configuring the Netflow Exporter is a simple task. Go to Reporting ‣ NetFlow.

Select all Interfaces you want to collect/export data from, usually one would select all available interfaces here.

If you do not want to record traffic originating or going to the firewall itself then add the interfaces to Egress only to prevent double counting of the same traffic flow (See also Netflow Export & Analyses for more information).

For local analysis using Insight also enable Capture local.

Depending on the application you would like to use select Version 5 or 9. Remember that version 5 does not support IPv6.

Add your Destinations (ip:port then enter) local IP will be added automatically if Capture local is selected.


System
_images/control-data-device-270700.jpg

The system section in the menu houses all general settings for your firewall needed for its operation. This includes options like administrative access, network routing and diagnostics features to debug your devices current activities.

    Access / User Management
        Users & Groups
        Access / Servers / LDAP
        Access / Servers / Radius
        Two-factor authentication
    Configuration
        Cloud Backup
        Traceability of configuration changes using Git
    Firmware
    Gateways
    Gateway groups / Multi WAN
        Multi WAN
    High Availability
    Routes
    Settings
    Trust
    Log Files
    Diagnostics

Setup guides

    Configure 2FA TOTP & Google Authenticator
    Setup Self-Signed Certificate Chains with OPNsense


Access / User Management
../_images/user_manager.png

The user manager of OPNsense allows for controlling access to the different part (pages) of the configurator as well as controlling access to particular services on a per user bases.
Authentication

OPNsense offers integration with external servers for services that require user authentication. These services include:

    IPsec

    OpenVPN

    Captive Portal

    Proxy

Integrated into OPNsense are the Local User Database and Voucher Server. The Voucher Server is intended to be used with the Captive portal.

External services currently supported are:

    LDAP (OpenLDAP, MS Active Directory, Novell eDirectory)

    Radius

Authorization

Besides authenticating, user authorization to access parts of the configuration can also be setup with an external server, but in order to grant the appropriate privileges to the users they need to exist in OPNsense’s local user manager. This way one can validate a user against its externally stored password and have a fine grained control over the configuration pages that user may access.

Note

As local users are local (bsd) system users, their naming scheme matches FreeBSD’s in terms of length (33 characters) and reserved characters.
Users, Groups & Privileges

When using the local user manager, either stand alone or on combination with an external authentication server one can define groups to combine a set of privileges for a specific user group. A user should be an individual, a group needs to be specific in such a way that anyone of that group can be granted the same access rights, called privileges.
Authentication services

Authentication services can be configured using the settings in System ‣ Access ‣ Servers. This includes both local accounts and remote authentication.

By default, OPNsense GUI login will use local accounts. This can be changed, however, by going to System ‣ Settings ‣ Administration, scrolling down to the “Authentication” group, and changing the ‘Server’ option.
Local account configuration

Settings for handling login via local accounts can be set by going to System ‣ Access ‣ Servers, then clicking the ‘Edit’ icon (a pencil) for ‘Local Database’. Here, you can improve security of local user accounts by setting password length and complexity constraints.

An overview of available settings:

Policy
	

Enable password policy constraints.

Duration
	

[Policy] Password duration, optionally define how often the user should change his or her password.

Length
	

[Policy] Minimum password length to require.

Complexity
	

[Policy] Enforce password complexity checks.

Compliance
	

[Policy] Require SHA-512 password hashing instead of Blowfish

Tip

When using One Time Passwords in combination with the local database, the same policy constraints apply as configured in “Local Database”.

Note

Our default Blowfish is not part of AES and is not considered compliant with any Federal Information Processing Standards (FIPS). Although more secure than SHA-512, its use may not be permitted in some environments.
Configuration

    Users & Groups
    Access / Servers / LDAP
    Access / Servers / Radius
    Two-factor authentication

Note

When using external authentication services (such as ldap), the firewall needs a route to the configured target machine in order to function properly. Specifically when the server is only reachable over a classic IPsec tunnel (non VTI), a static route might be needed to guide the packets into the right tunnel matching the policy. (for example when a policy for LAN exists, add a gateway pointing to our own address and a static routing pusing traffic to the other end).

A quick test if the routes are properly setup can always be performed using ping from the default source address.


Users & Groups
../../_images/usermanager_groups.png

With the local user manager in OPNsense one can add users and groups and define the privileges for granting access to certain parts of the GUI (Web Configurator).
Adding Users

To add a new user go to System ‣ Access ‣ Users and click on the + sign at the bottom right corner of the form.

Disabled
	

Unchecked
	

Can be used to (temporarily) disable an account

Username
	

John
	

A unique username

Password
	

secret
	

A strong password

Full name
	

John Doe
	

Optional, Full username, for reference only

E-Mail
	

a@b.com
	

Optional, users email, for reference only

Comment
		

Optional, comment field, for reference only

Preferred landing page
	

ui/page
	

Optional, landing page to visit after login

Login shell
	

/bin/csh
	

The shell to use when logging in via the console.

Expiration date
		

Optional, if account should expire enter as mm/dd/yyy

Group Membership
		

Optional, select one or more groups

Effective Privileges
		

Optional, additional grants for this user, usually these are being handled via a group

User Certificates
		

Optional, check if a user certificate should be created

API keys
		

Optional, when planning to use the API from another application, create keys for this user

OTP seed
		

Optional, enter or generate a OTP seed (base32)

Authorized keys
		

Optional, paste ssh key for ssh console access
Creating Groups

Go to System ‣ Access ‣ Groups and click on the + sign in the lower right corner of the form.

Enter a Group name and a Description and add users to the group.

When users should access resources on this firewall via a group, connect the relevant ones via Assigned Privileges.


Access / Servers / LDAP

LDAP is the lightweight directory access protocol used by Microsoft Active Directory (AD), OpenLDAP and Novell eDirectory, to name a few.

OPNsense can use an LDAP server for authentication purposes and for authorization to access (parts) of the graphical user interface (web configurator). When using LDAP for the GUI the privileges have to be defined with the local user manager, to do so an (automated) import of the users from the LDAP source is required.

In this how-to we will show you how to configure both using Microsoft Active Directory Server. If you only need LDAP for services like VPN, then you can skip steps 3-5.

Tip

LDAP can also be combined with Two-factor authentication
Prerequisites

A functional LDAP server (example is based on MS AD) is required. Your OPNsense firewall needs to be fully configured and able to access the LDAP server.
Step 1 - Add New LDAP server

To add a new LDAP server as authentication source, go to System ‣ Access ‣ Servers and click on Add server in the top right corner, just above the form.

Enter the following information:

Descriptive name
	

ws2012
	

Enter a descriptive name

Type
	

LDAP
	

Select LDAP

Hostname or IP address
	

10.10.10.1
	

Enter the IP address of you LDAP Server

Port value
	

389
	

Enter the port number, 389 is default

Transport
	

TCP - Standard
	

Select Standard or Encrypted

Protocol version
	

3
	

Select protocol version

Bind credentials
		

User DN:
	

cn=testusr,CN=Users, DC=opnsense,DC=local
	

Enter your credentials

Password:
	

secret
	

alway use a strong password

Search scope
	

Entire Subtree
	

Select Entire Subtree to retrieve all

Base DN:
	

DC=opnsense,DC=local
	

Enter the Base DN

Authentication containers
	

Select
	

Click & Select the containers from the list

Extended Query
	

&(objectClass=Person)
	

Extend query, e.g. limit results to Persons

Initial Template
	

MicrosoftAD
	

Select your LDAP Server Type

User naming attribute
	

samAccountName
	

Auto filled in based upon Initial Template

Read properties
		

Fetch account details after successful login

Synchronize groups
		

Enable to Synchronize groups, requires the option above

Constraint groups
		

Only consider groups inside the Authentication containers

Limit groups
		

Select list of groups that may be considered during sync*

Automatic user creation
		

When groups are automatically synchronized, this offers the ability to automatically create the user when it doesn’t exist.

Match case insensitive
		

Allow mixed case input when gathering local user settings.

Note

When clicking on the Select button right next to Authentication containers, something similar to the following will show up:
../../_images/ldap_selectcontainer.png

Note

When using SSL/TLS, make sure the certificate authority of the remote server is configured in the System -> Trust section.

Tip

The Extended Query can be used to select users who are member of a specific group (only relevant for external services, when not using the local user database). One can use something like this: &(memberOf=CN=myGroup,CN=Users,DC=opnsense,DC=local) to select only members of the group “myGroup”. To add a user to a specific group under Windows just edit the groups properties and select Add… to add the user under the tab Members.
../../_images/ldap_mygroup_properties.png

Tip

In some cases local naming doesn’t match server naming when it comes to users, the case insensitive option can be used in that case to ignore case on login. Microsoft Access Directory for example doesn’t match case sensitive, in which case UsEr equals user (our system is case sensitive)
Step 1.1 (optional) Synchronize groups.

When using the local database to import users, you can also synchronize configured LDAP groups when the remote server supports this. To use this feature, enable Read properties and Synchronize groups.

Note

This feature needs the remote LDAP server to respond with memberOf when queried, how to enable this on various LDAP providers lies outside the scope of this manual.

Note

Groups will be extracted from the first CN= section and will only be considered when already existing in OPNsense. Group memberships will be persisted in OPNsense (you can always check which rights the user had the last time he or she successfully logged in).
Step 2 - Test

To test if the server is configured correctly, go to System ‣ Access ‣ Tester and select your LDAP server and enter a valid username + password. Click on Test and if everything is set up correctly it will show:
../../_images/ldap_testok.png

Note

When limited to just one group, the group name will not be shown in the listing.

If not (or your entered invalid credentials) it shows:
../../_images/ldap_testfail.png

Tip

When Read properties is enabled, you should also see all properties returned by the server in the tester. This helps to identify if your server support group sync support (find memberOf in the list).
Step 3 - Enable the authentication server

Go to System ‣ Settings ‣ Administration and under the Authentication section at the bottom, change the Server dropdown to your newly added LDAP server and save.

Warning

Before changing the gui access to require LDAP, make sure at least one user is allowed to access the firewall with remote credentials. This can be achieved either by adding the All pages privilege to the user or making sure the user is member of a group with that privilege.

To prevent being locked out, you can add “Local Database” as secondary option during your test.
Step 4 - Import Users

If you would like to give LDAP/Active Directory users access to the GUI, you need to import the users into the local user manager. Go to System ‣ Access ‣ Users you will see a cloud import icon at the lower right corner of the form.
../../_images/user_cloudimport.png

Click on the cloud import icon to start importing users.

A new form will be show with the individual users, select the ones you like to import.

Note

The Automatic user creation option replaces manual imports in cases where account details can be retrieved from the remote LDAP server. Users created with this option should be removed manually from the firewall when they are removed from (one of) the LDAP server(s), which is the same as they would be maintained locally on manual imports.

As of version business edition 21.10, the system will automatically query the LDAP servers and remove non-existing users. (not available in the community version of OPNsense)
Step 4a - Update LDAP user privileges

Now if you go to System ‣ Access ‣ Users you will see all users including the newly imported LDAP users. You can create a specific group for these users to easily manage the privileges or use one of your earlier created groups.

When opening a LDAP user (edit) via the pencil icon right next to the name, you will notice the difference as the User Distinguished name will be shown from the LDAP server, just like this:
../../_images/user_ldap_distinguishedname.png

Tip

See Users & Groups for more information on User, Groups and privileges.


Access / Servers / Radius

Configuring a Radius server for user authentication in services like vpn or captive portal is easy just go to System ‣ Access ‣ Servers and click on Add server in the top right corner.

Fill in the form:

Descriptive name
	

radius_test
	

Enter a descriptive name

Type
	

Radius
	

Select Radius

Hostname or IP address
	

10.10.10.1
	

Enter the IP of your Radius server

Shared Secret
	

secret
	

Shared secret for your Radius server

Services offered
	

Authentication
	

Select Authentication,for Captive portal + accounting

Authentication port value
	

1812
	

Port number, 1812 is default; for accounting it’s 1813

Authentication Timeout
	

5
	

Timeout for Radius to respond on requests

Synchronize groups
		

Enable to Synchronize groups, requires the option above

Limit groups
		

Select list of groups that may be considered during sync*

Automatic user creation
		

When groups are automatically synchronized, this offers the ability to automatically create the user when it doesn’t exist.

Use the tester under System ‣ Access ‣ Tester to test the Radius server.

If you want to use the FreeRADIUS plugin set up the server as 127.0.0.1 and don’t forget to add a Client in the FreeRADIUS configuration.


Two-factor authentication
../_images/two_factor_authentication.png

Two-factor authentication also known as 2FA or 2-Step Verification is an authentication method that requires two components, such as a pin/password + a token.

OPNsense (version >=16.1.14) offers support for Two-factor authentication throughout the entire system, with one exception being console/ssh access.

Supported services are:

    OPNsense Graphical User Interface

    Captive Portal

    Virtual Private Networking - OpenVPN & IPsec

    Caching Proxy

New authentication servers can be added via System -> Access -> Servers, which supports both local users and users synchronised via ldap.
Time-based One-time Password

TOTP is an algorithm that computes a one-time password from a shared secret key and the current time. OPNsense supports RFC 6238.
Google Authenticator

OPNsense fully supports the use of Google’s Authenticator application. This application can generate tokens on Android, iOS and BlackBerry OS. The usage of this application is free and very simple to setup using OPNsense.
Other TOTP tokens

The 2FA feature can be used with any time based one-time password token, although it may be necessary to convert the tokens seed to the used format (base32).
Configuration & Setup

To setup see: Configure 2FA TOTP & Google Authenticator.


Configuration

The configuration section contains some tools to keep track of your setup.
Backup

You can backup and restore your machines configuration using the System ‣ Configuration ‣ Backups section. When performing a local backup, you can choose to protect it with a password and decide whether or not you would like to store rrd statistics as well (in which case they will be stored in the same export xml file).

Warning

The configured console settings of a machine may not be applicable to the situation of other (virtual) hardware platforms. To avoid losing console access to the firewall in these cases, the configuration restore will not apply the backups’ console settings by default. To disable this behaviour, uncheck Exclude console settings from import.

Note

Due to the sensitive nature of your configuration data, its advisable to protect backups with a strong password when storing them or distributing them to others.

Note

RRD statistics are used in System Health

Restoring backups can either be performed partially or for the complete configuration. Since configurations usually have various components that depend on each other, it’s most safe to restore a complete configuration.

Warning

Partial restores can lead to unexpected behavior, use with care. Future versions might not support this feature due to consistency reasons. (not all components can be partially exported)

Note

If restoring a backup on a different (virtual) machine and the hardware interface names do not match, a reboot will not automatically take place, instead you will be prompted to fix the interface assignments.

    Cloud Backup
    Traceability of configuration changes using Git

Defaults

With the defaults tool you can reset your firewall back to firmware defaults and shutdown when done.
History

The history menu helps you track changes between modifications and offer the opportunity to download older versions of your settings.

When OPNcentral is installed on the firewall and backups are being performed, there will be a host selector at the top of the page to select which host should be inspected.

Each backup preserved on this machine will be presented as an item in the dropdown, when selecting an item, the previous backup (when availabe) will be selected automatically as comparison target. The final pane on the screen contains the changes between both selected versions in unified diff format.

The following buttons are available in the “backups (compare)” pane:
	Revert to this backup (this firewall only), keep in mind no services will be restarted after this action, for a clean state a reboot might be required
	Remove this backup (this firewall only)
	Download the selected backup (in left dropdown)

Tip

You can specify the number of backups to keep in the backups menu (System ‣ Configuration ‣ Backups), which can be quite practical when a higher level of auditability is required.

Cloud Backup
Google Drive and Nextcloud

Google Drive is a digital file storage and management service by the information technology company Google. Amongst other features, like collaborative editing of documents, spreadsheets, and presentations, it allows signed up users with an account to store and share files in the digital cloud.

Nextcloud is also an online storage but in contrast to Google Drive it is intended for self hosting. You can download it freely from their website and install it on your webserver.

The OPNsense configuration can be stored as a backup file in XML format, to your PC on an USB stick or remotely in the digital Google Drive cloud.
Free online storage

Because Google officially offers a free storage of 15 GB and nearly unlimited traffic, a remote backup of an OPNsense configuration file is free of charge, the only thing you need is an account at Google (Google Drive Signup) .
Easy API

An application programming interfaces (API) for Google Drive was released in 2013. This API empowers third-party developers to easily write apps for Google Drive.

Nextcloud is using WebDAV which works without a special library so data can be sent directly to the server without a special client library (for example, a file upload is just a HTTP PUT call).
Remote backup

In OPNsense1 you can backup your configuration directly and automatically to Google Drive and Nextcloud, using the new backup feature. Every backup to Google Drive will be encrypted with the same algorithm used in the manual backup so it’s quite easy to restore to a new installed machine.

After set-up, the backup feature will run a first backup of the OPNsense configuration file. Then, if the configuration is subsequently changed, a new backup will be run once per day early in the morning.

You may consider specifying additional Cronjobs when more frequent remote backups or remote backups at different times of the day would be required.
Setup Google API usage

The instructions below apply to a standard Google account. Some of the settings appear slightly differently for Google Workspace (formerly G Suite) accounts.

A standard Google account can be created here.
1. Set up a Google Project

First you need to set up a project in the Google developer console.

    Go to the developer console and log into your Google account.

    On the “Manage resources” page that appears, click on the + CREATE PROJECT button:

        ../../_images/google_manage_resources.png 

    On the next page enter a name for your project, for example “OPNsense Backups”. You may leave it as the default name (“My Project #####”), as it does not really matter. Then click on the CREATE button:

        ../../_images/google_create_project.png 

    Now enable the Google Drive API for your project. In the search bar at the top of the page, search for “Google Drive API” and click on the corresponding search result:

        ../../_images/google_drive_api.png 

    On the next page, make sure your project name (for example “OPNsense Backups”) is displayed at the top of the page - if not, select it in the dropdown. Then click the ENABLE button:

        ../../_images/google_drive_enable.png 

    Now create a service account for your project. In the search bar at the top of the page, search for “service accounts” and click on the corresponding search result:

        ../../_images/google_select_service_account.png 

    Click on the + CREATE SERVICE ACCOUNT button:

        ../../_images/google_create_service_account_button.png 

    Enter an account name (for example “OPNsense”) and a description (for example “OPNsense Backups service account”), then click the CREATE button:

        ../../_images/google_create_service_account.png 

    Click the CONTINUE button on the next page:

        ../../_images/google_service_account_continue.png 

    Then click the DONE button:

        ../../_images/google_service_account_done.png 

    On the next page, take a note of the email address for your new service account - you will need it later. Then click on the three vertical dots under the Actions heading for your service account, then click on Create key:

        ../../_images/google_service_account_actions.png 

    In the popup screen, select P12, and click CREATE:

        ../../_images/google_service_account_create_key.png 

    You will be prompted to download the key. Do so, and then click CLOSE in the popup screen.

    Now click on the newly created Service Account:

        ../../_images/google_service_account.png 

    Write down the Unique ID of the Service Account. This ID will be your Client-ID in the OPNSense Google Drive backup:

        ../../_images/google_service_account_details.png 

2. Set up a Google Drive folder

The next thing is to create a folder in Google Drive and share it to the service account you’ve just created.

    Go to https://drive.google.com. You should be still logged into your Google account, otherwise log in.

    Click + New (upper left of the screen) and select Folder in the dropdown menu that appears:

        ../../_images/google_drive_new.png 

    Enter a name for the folder (for example “OPNsense Backups”, it doesn’t really matter) and then click the CREATE button:

        ../../_images/google_drive_folder.png 

    Right-click the newly created folder and click Share in the dropdown menu that appears:

        ../../_images/google_drive_share.png 

    Paste the email address for the service account into the “Add people and groups” box, press Enter and then click the Send button that appears:

        ../../_images/google_drive_send.png 

    Now double-click on the folder to open it and take a note of the folder ID from the URL - you will need it later. The folder ID is the last piece of the URL after /folders/:

        ../../_images/google_drive_folder_id.png 

3. Set up the account in OPNsense

Now put it all together in OPNsense.

    Log into your OPNsense firewall and go to the backup feature. It is located at System ‣ Configuration ‣ Backups.

    Scroll down to the Google Drive section and and enter the following values:

        Enable
        	

        checked

        Email Address
        	

        enter the Unique ID number of the service account you created

        P12 key
        	

        click the Choose file button and select the P12 key you saved earlier to upload it

        Folder ID
        	

        paste the Google Drive folder ID that you copied earlier

        Prefix hostname to backupfile
        	

        checked or unchecked as desired (useful if you have multiple OPNsenses)

        Backup Count
        	

        enter the number of backups you want to keep

        Password
        	

        choose a strong password to encrypt the backup

        Confirm
        	

        re-enter the strong password

    Then click the Setup/Test Google Drive button. OPNsense will automatically save and test your settings and you will receive either an error (connectivity issues) or a message saying “Backup successful” with a list of files currently in the backup.

The moment the feature is enabled, it will do a daily compare of the last file in backup and the current configuration and create a new backup when something has changed.
Setup Nextcloud API usage
1. Step Create a new user

Click on the user icon top right and click “Users”. In the new page, enter an username and a password into the boxes and click create to create a new user.
2. Step Create an Access Token

Close the modal dialog and remove the default files. Then open the Settings menu (also in the menu top right). Switch to security and generate a App password.
../../_images/nextcloud_create_token.png

Copy and store the generated password.
3. Step Connect OPNsense with Nextcloud
../../_images/nextcloud_config.png

Scroll to the Nextcloud Section in System ‣ Config ‣ Backup and enter the following values:

Enable
	

checked

URL
	

Base URL of your Nextcloud installation like https://cloud.example.com

User
	

your choosen username

Password
	

paste your app password from step 2

Backup Directory
	

a name consisting of alphanumeric characters (keep default)
4. Step Verify the Configuration Upload

When everything worked, you will see the newly created directory after saving the settings:
../../_images/nextcloud_directory.png

If you open it, you will see at lease a single backed up configuration file:
../../_images/nextcloud_backups.png


Traceability of configuration changes using Git

When seeking a solution to keep full traceability of configuration changes made by (various) users on your firewall, the git-backup plugin might be a useful addition to your setup.

In order to use this feature, one has to install the git-backup plugin first (in System->Firmware->Plugins search for os-git-backup).
Concept

Since git backup is a little bit different than the standard backup options available, we will explain briefly how it works using the diagram below.

When config.xml changes happen due to user or api interaction, an event is triggered to which handlers can subscribe (using syshook). Our git-backup plugin subscribes to these events in order to add the received backups and commits these with information extracted from the received xml file. To prevent the system to lock during backups, we choose this loosely coupled method. Events which are yet unprocessed are being left in the (existing) backup directory.

Note

Events are processed from the moment the initial backup is configured, when disabling backups, the (local) changelog itself remains active.

Git backup will push collected commits to the upstream repository nightly. To shorten this default interval, a custom cronjob (see Settings) can be set up, selecting Remote Backup as the Command. The regular backup procedure (which is also being triggered using the test button in the user interface) is responsible for initialising the empty local repository and configuring the upstream target.

Note

One can always change the upstream target, as long as the newly configured one is either “bare” (empty) or containing the exact same content (/change history) as the one used on this firewall.
Initial setup

The configuration part of this plugin is quite basic and offers two types of transport modes, https using a username and password combination or ssh using public key infrastructure.

Enable
	

Enable backup to the upstream target

URL
	

Target location, which defined transport protocol, options as ssh://server/project.git or https://server/project.git are allowed here.

Branch
	

The branch to push your commits to on the configured url

SSH private key
	

When using ssh, make sure to add a private key here

User Name
	

Username, when using gitlab and ssh, the default is git here (most of these providers use a single user and identify the user by it’s key)

password
	

When using https authentication, choose a password here.

Make sure to push to a “bare” upstream repository, when pressing “Setup/Test Git” the initial commits should be send to your git server.
SSH Setup

If you use GitHub, then your only option for git-backup, is to configure it for SSH access since GitHub has removed the ability for external applications to log into your account via your username and password.

The fields in OPNSense under System / Configuration / Backups / Git should contain the following:

    URL absolutely MUST follow this format when using GitHub and GitLab: ssh://github.com/user_name/repo_name.git. Any URL string that does not follow this pattern will not work.

    SSH Private key (discussed below)

    User Name should ONLY contain the word git

    password: leave this field empty

You need to create your repository BEFORE enabling git-backup. Do not add any files or READMEs to the repository. In other words, create a BLANK repository.

Next, create a new SSH key specifically for git-backup (only generate the private / public keys per that document and skip the rest). It is imperative that you do not add a password to your key, or your backups will fail with authentication errors.

You should set up SSH access to just your repository by assigning your SSH public key to the repository instead of assigning it to your GitHub / GitLab account. Doing this ensures that you don’t arbitrarily expose more of your git resources to OPNSense than is absolutely necessary for git-backup to work properly.

If you use GitHub, you can add your SSH public key by going to your repository, then click on settings, then Deploy keys. Or you can go straight to the URL using this format: https://github.com/USER_NAME/REPOSITORY_NAME/settings/keys/new.

    Check the box Allow write Access.

Make sure the fields are populated as stated above and that the Enable box is checked, then click on Setup / Test Git and you should see a message come back at the top of the page indicating that the first backup was successful.

Tip

When choosing an non-existing remote branch one will be created automatically. An existing one needs to be empty (blank) on order to use it, which in practice is only possible when creating the repository for the first time.
Conflict resolution

From the user interface no conflict resolution is offered, you need to configure an upstream repository and stick to it for the lifetime of the firewall. When for some reason a backup needs to be restored and one would like to stick to the same git repository, manual conflict resolution might be an option. Support on these scenario’s is not offered.

The repository is available on the OPNsense machine in the following directory /conf/backup/git.

Note

Conflict resolution can complicate the solution a lot (merging, fast-forward, ….), for this reason we will not accept feature requests trying to push to existing (used) repositories.
Error handling

When errors occur these will be written to the normal system logging, search for git-backup in the general system logging (System -> Log Files -> General).

Some standard errors might be returned via the test button, which should provide a clear direction, known ones are:

    authentication failure -> username/password combination is not valid or the provided ssh key doesn’t match the expected one

    ssh hostkey changed -> it looks like a man-in-the-middle attack is happening, if that’s not the case and the remote identification changed for valid reasons, manual intervention is required (remove the offensive key from /root/.ssh/known_hosts)

    git out of sync -> unable to synchronize, see “Conflict resolution” for additional info.

Cleanup

The repository is saved locally on the firewall in /conf/backup/git, if for some reason one would like to remove the collected history and start over from scratch, one can safetly remove this directory.

Login using a (ssh) console and remove the git directory in that case (rm -rf /conf/backup/git)

Note

As long as the plugin is installed and /conf/backup/git contains a git repository, the changes will be captured (also without an upstream). One could use this knowledge as well to keep a local (only) repository by creating a repository without assigning an upstream and leave the backup option disabled.

Tip

The firewall contains a local backup of the most recent changes (configured in System -> Configuration -> History) which the config changed event handler uses to feed to the consumers. If after a cleanup one would like to flush the collected changes again to the upstream provider, the /conf/event_config_changed.json could be removed to “forget” about the already handled config events (in which case all backups will be signaled again to all config syshook handlers)


Firmware

In the firmware section you can keep your OPNsense up to date and have the ability to install additional software.
Updates

How to install updates and information about our versioning can be found in the Installation and setup section, which can be found in the Updates document
Plugins

Plugins are additional software packages that are available for OPNsense, usually they come with their own frontend components to setup the software underneath. Here you can find community support plugins, such as bind, c-icap, freeradius and others. Usually there is also a -devel version available, which contains features still under development (master branch on GitHub versus release).

Note
You can use the symbol to install the package.

Tip
Use the info button to display information about the package and to find the active maintainer of this piece of software.
Packages

The packages tab contains the installed ports packages, here you can check licenses, force reinstalls or lock versions.
Changelog

If you would like to read about the changes in (past) releases, you can do so in the Changelog tab.
Settings

The settings menu contains all available mirrors and options which you can choose for your installation. Usually the default options are good enough here, but if you want to choose a mirror more close to home you can do so here.

Tip

The settings menu also provides the option to test development versions, which can be practical when testing features that are planned for release. Just change the release type to Development.

Note

Although OPNsense does not support the configuration of a proxy server, for services like the firmware updater it is possible to add these settings manually in our configd service. For more information we refer to the envronment section in our development docs.
Activate the Business Edition

When you have purchased a license for the Business Edition or received it pre-installed on an appliance, you will have to enable the license first.

In order to do so, please choose the following settings:

Mirror:
	

Deciso (HTTPS,NL,Commercial)

Flavour:
	

OpenSSL

Type:
	

Business

Subscription:
	

XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX (the activation key for the product)
../_images/quickstart_be.png

After save, go back to the status tab and click Check for updates

Note

Upgrading to OPNsense BE is only possible when the installed community version number is lower than the last available business edition. E.g. you can upgrade 22.7.x to 22.10.x, but you can not upgrade 23.1 to 22.10. You can always re-install using the installer found on the business mirror


Gateways

Gateways define the possible routes that can be used to access other networks, such as the internet. All different paths that are available to your firewall can be managed from this page, which can be found at System->Gateways->Configuration.

You can either define these gateways yourself, or they can be provided automatically from dynamical configured interfaces (e.g. dhcp), in which case they won’t have a predefined address.

When a gateway is generated automatically, you still have the ability to change its settings. Automatically generated gateways usually have names like WAN_DHCP.

In cases where you need to forward specific networks to a specific target, you can use static routes, which can be configured in System->Routes->Configuration and depend on the entries shown in the gateway page.

A specific kind of route is the default route, this is where all traffic is being send when no other static route is configured. There can only be one default at a time per ip protocol (ipv4, ipv6) in the system routing table.
Default gateways

Since there can only be one active default gateway, we need a method to figure out which one to use. For both ip protocols (ipv4, ipv6), this is determined equally.

Gateways have priorities, ranging from 1 [very important] to 255 [least important], automatically generated gateways will receive a low priority by default (which you can change manually).

Next there is a setting called upstream, which marks the gateway as favourable for default gateway selection, there can be more than one upstream configured at the same time.

When choosing a default, the algorithm will always sort upstream gateways higher (more attractive) and will use the priority next. If none of the gateways is explicitly chosen as upstream, the first non upstream is chosen.

In cases where gateway monitoring is configured, choosing a gateway also involves testing its current status and act accordingly when the monitored address is not reachable.

By default the system only chooses a (new) default gateway on startup or when an interface is connected or disconnected. In many cases you might want the default gateway also changed when the current gateway is not reachable anymore (via configured monitoring), in which case you can enable “Gateway switching” in System->Settings->General

Tip

In case you have multiple (dynamic) gateways, which should fall over in a specific order on failure, just set a priority and upstream flag. (e.g. favour fiber optics above 4g) Your choices should be reflected accordingly in the gateway grid (most important first).
Overview page

The overview page (System->Gateways->Configuration) shows all currently known gateways and their statuses in order of importance (most important on top). When a gateway is considered “default” it will show (active) behind the name.

Note

The (active) status shown in the list reflects the current calculated default, which might differ from the machine routing if gateway switching is not enabled. You can always check the current active default in System->Routes->Status

Tip

When debugging dynamic gateway issues, always check if your expected gateway is actually in the list. The system will only consider items shown here.
Settings

Below you will find the most important settings that are available for a gateway item.

Disabled
	

(temporary) disable this item

Name
	

Unique name for this gateway

Description
	

Optional description for this item

Interface
	

The interface this gateway is connected to

Address Family
	

IP family (v4 or v6)

IP address
	

Address of our gateway, empty/dynamic when dynamically generated.

Upstream Gateway
	

Upstream gateway, consider this gateway as default gateway candidate

Far Gateway
	

Checkbox to allow the gateway to exist outside of the interface subnet.

Disable Gateway Monitoring
	

Disable monitoring (consider online)

Disable Host Route
	

Do not create a dedicated host route for this monitor.

Monitor IP
	

Alternative address to monitor, always make sure the address is actually reachable and using this interface (via a static gateway)

Mark Gateway as Down
	

Consider this gateway as down, so it can’t be considered as default gateway

Priority
	

Prioritizes this gateway, a lower value means more important.
Troubleshooting
Missing dynamic gateway

Most dynamic interface types write their current gateway into a file named /tmp/[interface]_router or /tmp/[interface]_routerv6. When the expected gateway is not listed in the page, there might be an issue with the interface type (for example the remote server isn’t providing one at the moment).

Note

Some VPN types support sending traffic to the interface without knowing an intermediate gateway, to enable this check “Dynamic gateway policy” in the interface settings.
Gateway marked offline

When a gateway is marked offline, always check if the monitor address is reachable via the correct interface first. You can use Interfaces->Diagnostics->Ping to test connectivity. In case the monitor address is not in the same subnet as the interface, also check if there’s a static route (System->Routes->Status) available which sends the requested traffic to the correct upstream gateway.

There should always be a dpinger process active, which you can check on the services page (System->Diagnostics->Services), finally if all seems to be running you can deep dive into the packets leaving the interface, if dpinger is active, there should be ICMP packets heading to your monitor address, which you can inspect using Interfaces->Diagnostics->Packet Capture.


Gateway groups / Multi WAN

Multi WAN scenarios are commonly used for failover or load balancing, but combinations are also possible with OPNsense.

The technology used to offer multiwan is called “policy based routing” or “source routing” and depends on the firewall functionality of OPNsense.

Note

Currently it’s not possible to use gateways without an address (Interface option “Dynamic gateway policy”) inside a group. This is due to the fact that the firewall requires an address of the right family (IPv4 / IPv6) to be present on the interface, which can not be guranteed based on its configuration at the moment.
Terminology

When configuring gatew groups, there is a limited number of options and terms being used. Besides the name of the group, one can find the following terms on the page:

Gateway Priority
	

If a gateway is configured for a group, the ‘when’ part is divided into ‘tiers,’ with lower numbers (starting at 1) indicating higher importance. When no usable gateways are present within a peer, the next one is considered.

Trigger Level
	

When a gateway inside the tier is considered offline, either when its fully down, has loss or increased latency.

Pool Options
	

Usually left to default, but can influence stickyness for sources on a per group basis.
Roles

Using ‘tiers’, multiple scenarios can be constructed, by grouping gateways inside the same tier or choosing to move them to different ones. Below the most common scenarios.
WAN Failover

WAN failover automatically switches between WAN connections in case of connectivity loss (or high latency) of your primary ISP. As long as the connection is not good all traffic will be routed of the next available ISP/WAN connection and when connectivity is fully restored so will the routing switch back to the primary ISP.
WAN Load Balancing

Load balancing can be used to split the load between two (or more) ISPs. This enhances the total available bandwidth and/or lowers the load on each ISP.

The principle is simple: Each WAN connection (gateway) gets a portion of the traffic. The traffic can be divided equally or weighted.
Combining Balancing & Failover

It is also possible to combine Load Balancing with Failover in such scenarios you will have 2 or more WAN connections for Balancing purposes and 1 or more for Failover. OPNsense offers 5 tiers (Failover groups) each tier can hold multiple ISPs/WAN gateways.
Configuration

For a how to configure read:

    Multi WAN


Multi WAN

Multi WAN scenarios are commonly used for failover or load balancing, but combinations are also possible with OPNsense.
Configure Failover

To setup Failover the following step will be taken:

    Add monitor IPs to the gateways

    Add a gateway group

    Configure DNS for each gateway

    Use policy based routing to utilize our gateway group

    Add a firewall rule for DNS traffic that is intended for the firewall itself

Tip

Did you know you can browse quick and easy to the right page by using the search box in the top right corner of your screen? Like this:
../../_images/quick-navigation.png
Example configuration

Our example utilized two previous configured WAN gateways that both are confirmed to function separately. As DNS’s and monitor IPs we will utilize google’s DNS services 8.8.8.8 and 8.8.4.4, of course you can use your own ‘known good’ setting.

We defined WAN and WAN2, where WAN will be our primary (default) gateway.

Note

Before diving into the gateway group settings, make sure to check if both interfaces are connected to a gateway in Interfaces -> [XX] when using static assignments. On a default setup, these settings are responsible for creating outbound nat rules when traffic leaves the interface and handle the return path using policy base routing rules (reply-to, route-to).
Step 1 - Add monitor IPs

You may skip this step if you already have setup the monitoring IP and both gateways are shown as online.

To add a monitoring IP go to System ‣ Gateways ‣ Configuration and click on the first pencil symbol to edit the first gateway.

Now make sure the following is configured:

Disable Gateway Monitoring
	

Unchecked
	

Make sure monitoring is enabled

Monitor IP
	

8.8.8.8
	

We use Google’s DNS

Mark Gateway as Down
	

Unchecked
	

Then click on the second pencil symbol to edit the second gateway.

Now make sure the following is configured:

Disable Gateway Monitoring
	

Unchecked
	

Make sure monitoring is enabled

Monitor IP
	

8.8.4.4
	

We use Google’s second DNS

Mark Gateway as Down
	

Unchecked
	
Step 2 - Add Gateway Group

Go to System ‣ Gateways ‣ Group and press + Add Group in the upper right corner.

Use the following settings:

Group Name
	

WANGWGROUP
	

Enter a name for the gw routing later on

Gateway Priority
	

WANGW / Tier 1
	

Select the first gateway and Tier 1

..
	

WAN2GW / Tier 2
	

Select the second gateway and Tier 2

Trigger Level
	

Packet Loss
	

Select the trigger you want to use

Description
	

Failover Group
	

Freely chosen description

Tip

Trigger Level Explained

    Member Down

        Triggers when the gateway has 100% packet loss.

    Packet Loss

        Triggers when the packet loss to a gateway is higher than the defined threshold.

    High Latency

        Triggers when the latency to a gateway higher than its defined threshold.

    Packet Loss or High Latency

        Triggers for either of the above conditions.

Step 3 - Configure DNS for each gateway

Go to System ‣ Settings ‣ General and make sure each gateway has its own DNS setup: like this:

DNS servers

8.8.8.8
	

WANGW

8.8.4.4
	

WAN2GW
Step 4 - Policy based routing

Go to Firewall ‣ Rules

For our example we will update the default LAN pass rule. Click on the pencil next to this rule (Default allow LAN to any rule).

Now under Gateway change selection to WANGWGROUP.

Save and Apply changes

Note

This rule will utilize the gateway group for all traffic coming from our LAN network. This also means that traffic intended for the firewall itself will be routed in this (wrong) direction. That is why Step 5 is needed for our DNS traffic going to and coming from our DNS forwarder on the firewall itself.

Tip

Policy-based routing skips normal system routing. Since the default “allow LAN to any” rule has “any” set as destination, any traffic headed towards other internal networks (as is often the case with VPN tunnels) that trigger this rule will be routed through the gateway group as well. To avoid this, you can create an explicit rule before this default rule to allow traffic to those networks without a gateway set.
Step 5 - Add allow rule for DNS traffic

Add a rule just above the default LAN allow rule to make sure traffic to and from the firewall on port 53 (DNS) is not going to be routed to the Gateway Group that we just defined.

Start with pressing the + icon in the bottom left corner.

Enter the following details:

Action
	

Pass
	

Allow this traffic to pass

Interface
	

LAN
	

TCP/IP Version
	

IPv4
	

For our example we use IPv4

Protocol
	

TCP/UDP
	

Select the right protocol

Source
	

any
	

Destination
	

Single host or Network
	

Destination
	

192.168.1.1/32
	

IP of the firewall only hence /32

Destination port range
	

DNS - DNS
	

Only DNS

Category
	

DNS
	

See Organize PF Rules by Category

Description
	

Local Route DNS
	

Freely chosen description

Gateway
	

default
	

Select default

Note

When using Unbound for DNS resolution you should also enable Default Gateway Switching via System->Settings->General, as local generated traffic will only use the current default gateway which will not change without this option.
Advanced Options

For each gateway there are several advanced options you can use to change the default behavior/thresholds. These option can be changed under System ‣ Gateways ‣ Configuration, press the pencil icon next to the Gateway you want to update.

The current options are:

        Latency thresholds

            Low and high thresholds for latency in milliseconds.

        Packet Loss thresholds

            Low and high thresholds for packet loss in %.

        Probe Interval

            How often that an ICMP probe will be sent in seconds.

        Down

            The number of seconds of failed probes before the alarm will fire.

        Avg Delay Replies Qty

            How many replies should be used to compute average delay for controlling “delay” alarms?

        Avg Packet Loss Probes Qty

            How many probes should be used to compute average packet loss.

        Lost Probe Delay

            The delay (in qty of probe samples) after which loss is computed.

Configure Load Balancing

To setup load balancing follow the same configuration procedure as for Failover, but in step 2 choose same Tier for both Gateways.

This will change the behavior from failover to equal balancing between the two gateways.

Note

When using multiple Gateways with the same Tier, you need to disable shared forwarding in Firewall ‣ Settings ‣ Advanced.
Sticky Connection

Some web sites don’t like changing request IPs for the same session, this may lead to unexpected behavior. To solve this you can use the option Sticky Connections, this will make sure each subsequent request from the same user to the same website is send through the same gateway.

To set this option can be set under Firewall ‣ Settings ‣ Advanced.
Unequal Balancing (Weight)

If you have a non symmetric setup with one ISP having a much higher bandwidth than the other then you can set a weight on each gateway to change the load balance. For instance if you have one line of 10 Mbps and one of 20 Mbps then set the weight of the first one to 1 and the second one to 2. This way the second gateway will get twice as many traffic to handle than the first.

To do so, go to System ‣ Gateways ‣ Configuration and press the pencil icon next to the Gateway you want to update. The weight is defined under the advanced section.
Combining Balancing & Failover

To combine Load Balancing with Failover you will have 2 or more WAN connections for Balancing purposes and 1 or more for Failover. OPNsense offers 5 tiers (Failover groups) each tier can hold multiple ISPs/WAN gateways.


High Availability

OPNsense utilizes the Common Address Redundancy Protocol or CARP for hardware failover. Two or more firewalls can be configured as a failover group. If one interface fails on the primary or the primary goes offline entirely, the secondary becomes active.

Utilizing this powerful feature of OPNsense creates a fully redundant firewall with automatic and seamless fail-over. While switching to the backup network connections will stay active with minimal interruption for the users.
../_images/light_bulbs.png
Workflow

Although its not required to synchronize the configuration from the master machine to the backup, a lot of people would like to keep both systems (partially) the same.

To prevent issues spreading over both machines at the same time, we choose to only update on command (see the status page).

Our workflow looks like this:

First commit all changes to the master, then update the backup while knowing the master is still properly configured.

Note

In case of an emergency, you should still be able to switch to the backup node when changes cause issues, since the backup machine is left in a known good state during the whole process.
Automatic replication

Although we advise to make sure to keep the backup machine intact during maintenance, some people prefer to keep the backup in sync on periodic intervals. For this reason we added a cron action which you can schedule yourself in System -> Settings -> Cron on the primary node.

To use this feature, add a new cron job containing the HA update and reconfigure backup command and a proper schedule, once a day outside office hours is usually a safe option.

Note

To prevent a non functional primary machine updating the active master, the HA update and reconfigure backup will only execute if all carp interfaces are in MASTER mode.
Settings
Automatic failover

Although not really a setting on the high availability setup page, it’s a crucial part of high available setups. Using CARP type virtual addresses, the secondary firewall will take over without user intervention and minimal interruption when the primary becomes unavailable.

Virtual IPs of the type CARP (Virtual IPs) are required for this feature.
Synchronized state tables

The firewall’s state table is replicated to all failover configured firewalls. This means the existing connections will be maintained in case of a failure, which is important to prevent network disruptions.

Note

As of OPNsense version 24.7 a “Sync compatibility” selector is offered in the high availability settings page. Make sure both nodes use the same version to prevent state synchronization issues.
Disable preempt

By default this option is deselected, which is the advised scenario for most common HA setups. The preempt option make sure that multiple carp interfaces will act as a group (all backup or master) at the same time, assuming no technical issues exist between both.
Disconnect dialup interfaces

When this device is configured as CARP backup it will disconnect all PPP type interfaces and try to reconnect them when becoming master again.
Configuration synchronization

OPNsense includes configuration synchronization capabilities. Configuration changes made on the primary system are synchronized on demand to the secondary firewall.
Configure HA CARP

For detailed setup guide see: Configure CARP
Status

The status page connects to the backup host configured earlier and show all services running on the backup server. With this page you can update the backup machine and restart services if needed.

Tip
Use the refresh button to update the backup node and restart all services at once.


Routes

Routing is one of the core features of your firewall, which is responsible for forwarding packets over the network based on (predefined) paths.

Within the routing section of your firewall you can keep track of configured routes and define static routes yourself to teach your firewall which path it should take when forwarding packets to a specific network.

When a client sends a packet to the firewall for a network not directly attached to it, the firewall would normally check its routing table to determine to which gateway (see Gateways) it should be send.

Tip

Use traceroute (Interfaces ‣ Diagnostics ‣ Trace Route) to verify which path traffic would follow to reach its destination.
Configuration

This is where you can setup static routes, looking at the diagram in the previous chapter, here you would define how [1] would access [2] using router [3].

The number of settings are obviously limited, we need to know the gateway and the target network.

Disabled
	

(temporary) disable this item

Network Address
	

Destination network to reach

Gateway
	

The gateway to use.

Description
	

Optional description for this item

Note

Some services are known to update the routing table themselves, in which case you shouldn’t add static routes manually (OpenVPN manages its own routes for example).
Status

The status page shows the current active content of the routing table.

Proto
	

Protocol (IPv4 or IPv6)

Destination
	

Destination network

Gateway
	

Where to send the packet for this destination network

Flags
	

Routes have associated flags which influence operation of the protocols when sending to destinations matched by the routes. See the Flags table below for details.

Use
	

Counts the number of packets sent via this route

MTU
	

The MTU set for this route

Netif
	

Interface to use for this route

Netif (name)
	

Name of the interface if found

Expire
	

The time at which this route should expire, or zero if it should never expire. It is the responsibility of individual protocol suites to ensure that routes are actually deleted once they expire.
Flags

The following flags are supported by the kernel.

Letter / Flag
	

Description

1 [RTF_PROTO1]
	

Protocol specific routing flag

2 [RTF_PROTO2]
	

Protocol specific routing flag

3 [RTF_PROTO3]
	

Protocol specific routing flag

B [RTF_BLACKHOLE]
	

Just discard pkts (during updates)

b [RTF_BROADCAST]
	

The route represents a broadcast address

C [RTF_CLONING]
	

Generate new routes on use

c [RTF_PRCLONING]
	

Protocol-specified generate new routes on use

D [RTF_DYNAMIC]
	

Created dynamically (by redirect)

d [RTF_DONE]
	

Message confirmed

G [RTF_GATEWAY]
	

Destination is a gateway

H [RTF_HOST]
	

Host entry (net otherwise)

L [RTF_LLINFO]
	

Valid protocol to link address translation

M [RTF_MODIFIED]
	

Modified dynamically (by redirect)

R [RTF_REJECT]
	

Host or net unreachable

S [RTF_STATIC]
	

Manually added

U [RTF_UP]
	

Route usable

X [RTF_XRESOLVE]
	

External daemon resolves name
Logs

Route related logging, like radvd and rtsold for IPv6 write messages to this logging section which can be used for debugging purposes.


Settings

Besides the configuration options that every component has, OPNsense also contains a lot of general settings that you can tweak. This page contains an overview of them.
Administration

The settings on this page concerns logging into OPNsense. The “Secure Shell” settings are described under Creating Users & Groups.
Listen interfaces

Warning

Before considering the use of manual selected interfaces, make sure to read this chapter so you are aware of the pitfalls upfront. Misconfigurations likely lead to a non accesible web interface and/or missing ssh access.

Both the WebUI and the Secure Shell server support the option to only listen on specific interfaces, the use of this option however comes with clear warnings which you do need to be aware of before deciding to use this option.

By default (our recommended settings), these services listen on all addresses (interfaces).

If for whatever reason, you do need to listen only on specific interfaces, the following rules apply:

    The interface must always be available, so do not try to bind to vpn instances of any kind (OpenVPN, Wireguard, …)

    The addressing must be fully static, so no IPv6 tracking configured for example

As the webgui is not able to predict with 100% certainty that these rules do apply, it is possible to select interfaces that don’t support binding for these services.

Note

When facing issues with the webgui (and/or ssh) and the above rules are not met, please do not bother to open a ticket as these are unsupported scenario’s.

Tip

In case (for any service) one would like to prevent binding on all interfaces, it is possible to add a loopback interface (Interfaces->Other Types->Loopback), assign an ip address and bind to that.

If traffic is being routed through the firewall, the “loopback ip” (some private addres, not in the loopback range) should be directly accessible from the network behind it. For example use an address like 192.192.192.192/32 to access the web interface while your own network is using 192.168.1.0/24.

Technologies like Network Address Translation can also be combined if the other end is not aware of the route to this single address.
Web GUI

Protocol
	

It is strongly recommended to leave this on “HTTPS”

SSL Certificate
	

By default, a self-signed certificate is used. Certificates can be added via System ‣ Trust ‣ Certificates.

SSL Ciphers
	

Can be used to limit SSL cipher selection in case the system defaults are undesired. Note that restrictive use may lead to an inaccessible web GUI.

HTTP Strict Transport Security
	

Enforces loading the web GUI over HTTPS, even when the connection is hijacked (man-in-the-middle attack), and do not allow the user to trust an invalid certificate for the web GUI.

TCP port
	

Can be useful if there are other services that are reachable via port 80/443 of the external IP, for example.

HTTP Redirect
	

If you change the port, a redirect rule from port 80/443 will be created. Check this option to disable the creation this automatic redirect rule.

Login Messages
	

If checked, disable the successful login messages in the web GUI.

Session Timeout
	

Time in minutes to expire idle management sessions.

DNS Rebind Check
	

OPNsense contains protection against DNS rebinding by filtering out DNS replies with local IPs. Check this box to disable this protection if it interferes with web GUI access or name resolution in your environment.

Alternate Hostnames
	

Alternate, valid hostnames (to avoid false positives in referrer/DNS rebinding protection).

HTTP Compression
	

Reduces size of transfer, at the cost of slightly higher CPU usage.

Access log
	

Log all access to the Web GUI for debugging/analysis.

Server Log
	

Display all web GUI errors in the main system log.

Listen interfaces
	

Can be used to limit interfaces on which the Web GUI can be accessed. This allows freeing the interface for other services, such as HAProxy.

HTTP_REFERER enforcement check
	

The origins of requests are checked in order to provide some protection against CSRF. You can turn this off of it interferes with external scripts that interact with the Web GUI.
Secure Shell

User accounts can be used for logging in to the web frontend, as well as for logging in to the console (via VGA, serial or SSH). The latter will only work if the user shell is not set to /sbin/nologin.

In order to access OPNsense via SSH, SSH access will need to be configured via System ‣ Settings ‣ Administration. Under the “Secure Shell” heading, the following options are available:

Secure Shell Server
	

Enable a secure shell service

Login Group
	

Select the allowed groups for remote login. The “wheel” group is always set for recovery purposes and an additional local group can be selected at will. Do not yield remote access to non-administrators as every user can access system files using SSH or SFTP.

Permit Root Login
	

Root login is generally discouraged. It is advised to log in via another user and switch to root afterwards.

Permit password login
	

When disabled, authorized keys need to be configured for each User that has been granted secure shell access.

SSH port
	

Port to listen on, default is 22

Listen Interfaces
	

Only accept connections from the selected interfaces. Leave empty to listen globally. Use with extreme care.

Key exchange algorithms
	

The key exchange methods that are used to generate per-connection keys

Ciphers
	

The ciphers to encrypt the connection

MACs
	

The message authentication codes used to detect traffic modification

Host key algorithms
	

Specifies the host key algorithms that the server offers

Public key signature algorithms
	

The signature algorithms that are used for public key authentication
Console

In case of an emergency, it’s always practical to make sure to configure a console to be able to access the firewall when network connectivity is not possible.

Tip

After initial installation, always make sure to test if the console actually works. When concluding the console is not functional when you need it can be very unpractical.

Use the virtual terminal driver (vt)
	

When unchecked, OPNsense will use the older sc driver. |

Primary Console
	

The primary console will show boot script output. All consoles display| OS boot messages, console messages, and the console menu. |

Secondary Console
	

See above. |

Serial Speed
	

Allows adjusting the baud rate. 115200 is the most common. |

Use USB-based serial ports
	

Listen on /dev/ttyU0, /dev/ttyU1, … instead of /dev/ttyu0.|

Password protect the console menu
	

Can be unchecked to allow physical console access without password. | This can avoid lock-out, but at the cost of attackers being able to | do anything if they gain physical access to your system. |
Authentication

The authentication section of the Administrationm settings offers general security settings for users logging into the firewall.

Server
	

Select one or more authentication servers to validate user | credentials against. Multiple servers can make sense with remote | authentication methods to provide a fallback during connectivity | issues. When nothing is specified the default of “Local Database” | is used. |

Disable integrated authentication
	

When set, console login, SSH, and other system services can only use | standard UNIX account authentication. |

Sudo
	

Permit sudo usage for administrators with shell access. |

User OTP seed
	

Select groups which are allowed to generate their own OTP seed on the | password page. |
Cron

Cron is a service that is used to execute jobs periodically. Cron jobs can be viewed by navigating to System ‣ Settings ‣ Cron. New jobs can be added by click the + button in the lower right corner.

When adding a new job or modifying an existing one, you will be presented with fields that directly reflect the cron file syntax and that mostly speak for themselves. A job needs a name, a command, command parameters (if applicable), a description (optional, but recommend) and most importantly, a schedule. All time-related fields share the same syntax:

    An asterisk (*) can be used to mean “any”

    Specifying multiple values is possible using the comma: 1,4,9

    Ranges can be specified using a dash: 4-9

Available cron jobs are registered in the backend to prevent command injection and privilege escalation. These can be found under Command and may allow an additional Parameter. Restart and reload actions are self-explanatory. They take no parameters and will restart (usually slower stop and start of a process) or reload (usually a faster SIGHUP) the respective service. The availability of restart and reload is subject to their respective services as not all software will support a reload for implementational reasons.

The most common core commands are as follows:

Command in GUI
	

Command in shell
	

Supported parameters
	

Background information

Update and reload firewall aliases
	

configctl filter refresh_aliases
	

No parameters
	

Updates IP aliases for DNS entries and MAC addresses as well as URL tables.

Firmware update check
	

configctl firmware poll
	

No parameters
	

Refresh current update status from firmware mirror for e.g. remote status check via API. Note this utilizes a skew interval of 25 minutes.

Firmware changelog update
	

configctl firmware changelog cron
	

No parameters
	

Refresh current changelog status from authoritative firmware location to preview changelogs for new versions. Note this utilizes a skew interval of 25 minutes and is also performed by the firmware update check.

Automatic firmware update
	

configctl firmware auto-update
	

No parameters
	

Perform a minor update if applicable.

Update and reload intrusion detection rules
	

configctl ids update
	

No parameters
	

Fetches remote rules and reloads the IDS instance to make use of newly fetched rules.

Periodic interface reset
	

configctl interface reconfigure [identifier]
	

identifier: Internal name of the interface as shown in assignments or overview page, e.g. “lan”, “wan”, “optX”.
	

Cycle through an interface reset that removes all connectivity and reactivates it cleanly.

Download and reload external proxy ACLs
	

configctl proxy fetchacls
	

No parameters
	

Fetch and activate the external ACL files for configured blocklists.

Remote backup
	

configctl system remote backup
	

No parameters
	

Trigger the remote backup at the specified time as opposed to its nightly default.

Issue a reboot
	

configctl system reboot
	

No parameters
	

Perform a reboot at the specified time.

HA update and reconfigure backup
	

configctl system ha_reconfigure_backup
	

No parameters
	

Synchronize the configuration to the backup firewall and restart its services to apply the changes.

Update Unbound DNSBLs
	

configctl unbound dnsbl
	

No parameters
	

Update the the DNS blocklists and apply the changes to Unbound.

ZFS pool trim
	

configctl zfs trim [pool]
	

pool: ZFS pool name to perform the action on
	

Initiates an immediate on-demand TRIM operation for all of the free space in a pool. This operation informs the underlying storage devices of all blocks in the pool which are no longer allocated and allows thinly provisioned devices to reclaim the space.

ZFS pool scrub
	

configctl zfs scrub [pool]
	

pool: ZFS pool name to perform the action on
	

Begins a scrub or resumes a paused scrub. The scrub examines all data in the specified pools to verify that it checksums correctly. For replicated (mirror, raidz, or draid) devices, ZFS automatically repairs any damage discovered during the scrub.
General

The general settings mainly concern network-related settings like the hostname. The general setting can be set by going to System ‣ Settings ‣ General. The following settings are available:

Setting
	

Explanation

System

Hostname
	

Hostname without domain, e.g.: firewall

Domain
	

The domain, e.g. mycorp.com, home, office, private, etc. Do not use ‘local’ as a domain name. It will cause local hosts running mDNS (avahi, bonjour, etc.) to be unable to resolve local hosts not running mDNS.

Time zone
	

Set the time zone closest to you.

Language
	

Default language. Can be overridden by users.

Theme
	

More themes can be installed via plug-ins.

Networking

Prefer to use IPv4 even if IPv6 is available
	

By default if a hostname resolves IPv6 and IPv4 addresses, the IPv6 will be used. If checked, then IPv4 addresss will be used instead of IPv6.

DNS servers
	

A list of DNS servers, optionally with a gateway. These DNS servers are also used for the DHCP service, DNS services and for PPTP VPN clients. When using multiple WAN connections there should be at least one unique DNS server per gateway.

Allow DNS server list to be overridden by DHCP/PPP on WAN
	

If this option is set, DNS servers assigned by a DHCP/PPP server on the WAN will be used for their own purposes (including the DNS services). However, they will not be assigned to DHCP and PPTP VPN clients.

Do not use the local DNS service as a nameserver for this system
	

When enabling local DNS services such as Dnsmasq and Unbound, OPNsense will use these as a nameserver. Check this option to prevent this.

Allow default gateway switching
	

If the link where the default gateway resides fails switch the default gateway to another available one.
Tunables

Tunables are the settings that go into the loader.conf and sysctl.conf files, which allows tweaking of low-level system settings. They can be set by going to System ‣ Settings ‣ Tunables.

Here, the currently active settings can be viewed and new ones can be created. A list of possible values can be obtained by issuing sysctl -a on an OPNsense shell. Additional tunables may exist depending on boot loader capabilities and kernel module support.
Miscellaneous

As the name implies, this section contains the settings that do not fit anywhere else.

Setting
	

Explanation

Cryptography settings
	

Hardware acceleration
	

Select your method of hardware acceleration, if present. Check the full help for hardware-specific advice.

Thermal Sensors
	

Hardware
	

Select between No/ACPI thermal sensor driver and processor-specific drivers.

Periodic Backups
	

Periodic RRD Backup
	

Periodically backup Round Robin Database.

Periodic DHCP Leases Backup
	

Periodically backup DHCP leases.

Periodic NetFlow Backup
	

Periodically backup Netflow state.

Periodic Captive Portal Backup
	

Periodically backup Captive Portal state.

Power Savings
	

Use PowerD
	

PowerD allows tweaking power conservation features. The modes are maximum (high performance), minimum (maximum power saving), adaptive (balanced), hiadaptive (balanced, but with higher performance).

On AC Power Mode
	

Set power mode when on AC (on grid). Default option is: hiadaptive.

On Battery Power Mode
	

Set power mode when on battery. Default option is: hiadaptive.

On Normal Power Mode
	

Set power mode the power utility can not determine the power state. Default option is: hiadaptive.

Disk / Memory Settings
	

Swap file
	

Create a 2 GB swap file. This can increase performance, at the cost of increased wear on storage, especially flash.

/var RAM disk
	

This can be useful to avoid wearing out flash storage. Everything in /var, including logs will be lost upon reboot.

/tmp RAM disk
	

See above.

System Sounds
	

Disable the startup/shutdown beep
	

Disable beeps via the built-in speaker (“PC Speaker”)
Logging

Local log settings can be found at System ‣ Settings ‣ Logging, tab “Local”.

The regular log files will use the following standard pattern on disk /var/log/<application>/<application>_[YYYYMMDD].log (one file per day). Our user interface provides an integrated view stitching all collected files together. Available settings may change the appearance on disk depending on space and time constraints for log rotation.

Many plugins have their own logs. In the UI, they are grouped with the settings of that plugin. They mostly log to /var/log/ in text format, so you can view or follow them with tail.

An overview of the local settings:

Setting
	

Explanation

Enable local logging
	

Disable to avoid wearing out flash memory when applicable and set up remote logging instead.

Maximum preserved files
	

Configures the number of days to keep logs or the number of files if “maximum file size” option is used.

Maximum file size
	

Limit the file size of the logs instead of keeping one log per day.

Tip

When using (very) small file size limits, it is possible to schedule the rotate action more frequently using cron (System ‣ Settings ‣ Cron). Seek for an action named Rotate log files in the list in that case.

Remote log settings can be found at System ‣ Settings ‣ Logging, tab “Remote”.

Add a new Destination to set up a remote target destination.

Setting
	

Explanation

Enabled
	

Master on/off switch.

Transport
	

Protocol to use for syslog.

Applications
	

Select a list of applications to send to remote syslog. Leave empty for all.

Levels
	

Choose which levels to include, omit to select all.

Facilities
	

Choose which facilities to include, omit to select all.

Hostname
	

Hostname or IP address where to send logs to.

Port
	

Port to use, usually 514.

Certificate
	

Client certificate to use (when selecting a tls transport type)

Description
	

Set a description for you own use.

Note

When using syslog over TLS, make sure both ends are configured properly (certificates and hostnames), certificate errors are quite common in these type of setups. On OPNsense the general system log usually contains more details. When it comes to tracking syslog-ng messages, this is usually a good resource.

A reconfigure doesn’t always apply the new tls settings instantly, if that’s not the case best stop and start syslog in OPNsense (using the gui).

To activate any changed settings use the “Apply” button below.

To clear all the logs on the system use the “Reset Log Files” button.


Trust

In OPNsense, certificates are used for ensuring trust between peers. To make using them easier, OPNsense allows creating certificates from the front-end. In addition to that, it also allows creating certificates for other purposes, avoiding the need to use the openssl command line tool. Certificates in OPNsense can be managed from System ‣ Trust ‣ Certificates.

Examples of OPNsense components that use certificates:

    OpenVPN

    IPsec

    Captive Portal

    Web Proxy

Certificate types

The following types of certificate can be generated in OPNsense:

    Client

    Server

    Combined Client/Server

    Certificate Authority

In addition to this, OPNsense can generate a Certificate Signing Request (CSR). This can be used if you want to create a certficate signed by an external CA.

Warning

Make sure that you select the correct certificate type, as many clients will refuse connection (or at least show errors) if an incorrect certificate type is used. For example, you can use either a server certificate or a combined client/server certificate to secure the connection to the web interface, but not a CA or client certificate.
Revoke certificates
Certificate Revocation Lists

A Certificate Revocation Lists (CRL) is a list of certificates that have been revoked by the certificate authority. Some services in OPNsense can use these to validate if a certificate is still valid to use even though it might not be expired.

Defining a CRL in OPNsense is not very complicated, just go to System ‣ Trust ‣ Revocation and click on the [+] sign for your (local) certficate authority to create a new CRL. When a CRL exists, you may edit it and add or remove certificates in it (using the pencil icon).

Note
If you wish to use a CRL for external tools you can download it using the button

One of the downsides of a CRL is that they don’t scale very well, each consumer of the list should download the full list in order to know if a certificate can still be trusted. Information often is less accurate as these lists usually are only generated on certain intervals.

When using a CRL for a local authority on OPNsense itself the scaling part usually isn’t a large issue as the number of certificates is usually limited (for example to the number of employees in your organisation).

To manually verify the created certificates using openssl commands, you need the following ingredients:

    The CA certificate chain which signed the certificates (export “cert” from Authorities menu)

    The CRL created in OPNsense (export “crl” from Revocation menu)

    A revoked certificate (export “cert” from Certificates menu)

    A non expired or revoked certificate

First we concatenate both the CA chain and the CRL into a single “chain” file:

# cat ca_chain.crt ca_crl.crl > my_chain.pem

Then validate a revoked certificate using the following openssl command:

# openssl verify -crl_check -CAfile my_chain.pem revoked_cert.crt
C=NL, CN=my_cert
error 23 at 0 depth lookup: certificate revoked
error ocsp_user_cert2.crt: verification failed

And a valid certificate:

# openssl verify -crl_check -CAfile my_chain.pem ok_cert.crt
ocsp_server_cert.crt: OK

Online Certificate Status Protocol

The Online Certificate Status Protocol (OCSP) offers similar functionality as the CRL’s described earlier, but validates certificates “online” and offers a whitelising instead of a blacklisting method. Certificates are checked against an online known set of certificates after which the server responds with ‘good’, ‘revoked’, or ‘unknown’. Only good responses are considered valid.

In order to explain the client verifying a certificate where to check it’s validity, the AuthorityInfoAccess extenstion should be provided in the certificate authority (The parameter OCSP uri adds this to the certificate in OPNsense).

Tip
You can use the button to find the ocsp uri when available.

The OCSP responder (server) which validates the ‘OCSP request’ needs a special signing certificate, which can be created in OPNsense via System ‣ Trust ‣ Authorities, issued by the same CA which created the user and/or server certificates.

OPNsense does not implement an OCSP responder, but to test the concept, we can use the openssl-ocsp command.

Note

openssl-ocsp is only intended to be used for test and demonstration purposes.

In order to test the concept, we need the following ingredients:

    The CA certificate chain which signed the certificates (export “cert” from Authorities menu)

    The OCSP signer certificate (export “cert” and “key” from Authorities menu for the signer)

    An index file for openssl-ocsp (export index from Revocation menu) as specified in https://pki-tutorial.readthedocs.io/en/latest/cadb.html

    A serial number of a revoked certificate (use the info button to find the serial number)

    A serial number of a non expired or revoked certificate

First start the server in a console:

# openssl ocsp -index index.txt -port 8081 -rsigner ocsp_signer.crt -rkey ocsp_signer.key -CA ca.crt -ignore_err -text

Then verify a known good certificate (with serial number 1):

# openssl ocsp -url http://127.0.0.1:8081 -CAfile ca.crt -issuer ca.crt -serial 1
Response verify OK
1: good
        This Update: Jan  6 13:33:59 2024 GMT

A revoked one:

# openssl ocsp -url http://127.0.0.1:8081 -CAfile ca.crt -issuer ca.crt -serial 2
Response verify OK
2: revoked
    This Update: Jan  6 13:34:54 2024 GMT
    Revocation Time: Jan 1 21:31:08 2024 GMT

And an unknown certificate

# openssl ocsp -url http://127.0.0.1:8081 -CAfile ca.crt -issuer ca.crt -serial 9999
Response verify OK
9999: unknown
    This Update: Jan  6 13:36:51 2024 GMT

Usage examples

In Setup Self-Signed Certificate Chains with OPNsense you will find examples of how to setup certificate chains yourself.

Log Files

When troubleshooting problems with your firewall, it is very likely you have to check the logs available on your system. In the UI of OPNsense, the log files are generally grouped with the settings of the component they belong to. The log files can be found here:

System Log
	

System ‣ Log Files ‣ General
	

Most of all system related events go here

Backend / config daemon
	

System ‣ Log Files ‣ Backend
	

Here you can find logs for config generation of API usage

Web GUI
	

System ‣ Log Files ‣ Web GUI
	

Lighttpd, the webserver of OPNsense itself, logs here

Firmware
	

System ‣ Firmware ‣ Log File
	

Updates from the packaging system go here

Gateways
	

System ‣ Gateways ‣ Log File
	

Lists Dpinger gateway tracking related log messages

Routing
	

System ‣ Routes ‣ Log File
	

Routing changes or interface events


Diagnostics
Activity

The activity module shows current active processes and their details, you can search within the list of activities, fetch general information (like load averages, number of processes, etc.) using the info button in the footer of the grid.

PID
	

The process id of this process

USERNAME
	

Username executed this process

PRI
	

Current priority of the process

NICE
	

NICE is the nice amount (in the range -20 to 20)

SIZE
	

Total size of the process (text, data, and stack)

RES
	

Current amount of resident memory, RAM currently in use by the process

C
	

is the processor number on which the process is executing (visible only on SMP systems)

TIME
	

The number of system and user cpu seconds that the process has used

WCPU
	

Weighted cpu percentage

COMMAND
	

Command string
Services

The services page shows the configured services and status, you can stop/start/restart all of them here.


Configure 2FA TOTP & Google Authenticator

This how-to will show you how to setup a One-time Password 2 Factor Authentication using OPNsense and Google’s Authenticator. All services of OPNsense can be used with this 2FA solution.
../../_images/two_factor_authentication.png

Note

To use the same feature with any time based one-time password token just enter the seed into the field in step 3 instead of creating a new seed. The seed needs to be in base32 format.
Step 1 - Add New Authentication Server

To add a TOTP server go to System ‣ Access ‣ Servers and press Add server in the top right corner. Then fill in the form as follows:

Descriptive name
	

TOTP Server
	

Choose a server name

Type
	

Local+Timebased One Time Password
	

Select the TOTP server Type

Token length
	

6
	

6 for Google Authenticator

Time window
		

Leave Empty for Google Authenticator

Grace period
		

Leave Empty for Google Authenticator
Step 2 - Install Google Authenticator

Go to the App Store of your platform and search for Google Authenticator. Install using the normal procedure for your device.
Step 3 - Add or modify user

For this example we will create a new user, go to System ‣ Access ‣ Users and click on the plus sign in the lower right corner.

Enter a Username and Password and fill in the other fields just as you would do for any other user. Then select the Generate new (160bit) secret under OTP seed.

When done press Save.
Step 4 - Activate Authenticator for this OTP seed

To activate your new OTP seed on the Google Authenticator, first reopen the user you just created by clicking on the pencil icon.
../../_images/OTP_seed.png

Now it will show a QR code:
../../_images/otp_qr_code.png

Warning

Be very careful with the seed or QR code as this is the only thing you need to calculate the token. KEEP YOUR SEED/QR CODE SAFE !

Now open your Google Authenticator compatible application and select the option to start the configuration and then scan the QR code or alternatively enter the seed directly.

In case of SailOTP the configuration works like this:
../../_images/sailotp_menu.jpg

Pull down to open the application menu and choose the entry to add a new Token.
../../_images/sailotp_scan_qr.jpg

In the next step, you have to scan the previously created QR code by clicking on the screen.
../../_images/sailotp_scanresult.jpg

When the QR code is scanned, a new view will open where you can see the details of the result. This view can be used to check if the generated key and OTP settings of the scan results do match your settings. Confirm if everything is ok by clicking “Add”.

After this step, you will be back on the home screen of the app and will get a Token for 30 Seconds.

Please note that there are many apps to generate the token. Some well known are:

Name
	

Platform
	

URL

FreeOTP
	

Android, iOS
	

https://freeotp.github.io/

Google Authenticator
	

Android, iOS
	

https://www.google.com/landing/2step/
Step 5 - Test the token

For testing the user authentication, OPNsense offers a simple tester. Go to System ‣ Access ‣ Tester

Select the Authentication server you have configured, and enter the user name. Then enter the *token + password, remember the order is token and then password in the same field.

Note

Password field should be used to enter both token and your password, like: Password: 123456PASSWORD when the default configuration is used. The OTP authentication server can also be configured to have it in the reverse order like PASSWORD123456.

Hit the test button and if all goes well you should see successfully authenticated.
../../_images/system_access_tester.png
Step 6 - Enable authentication server

Per default the system validates user credentials against the “Local Database”. In System ‣ Settings ‣ Administration, section Authentication you should change this to your newly added authentication server to make sure no local user can gain access without 2FA.

Note: Make sure you’ve tested your token!
../../_images/auth_server.png
Step 7 - Using the token

To use the token in any application/service that you have configured, just open the Google Authenticator and add the created token/key before your regular password.

Warning

Remember, you need to enter the token before or after you password (depending on your configuration)! And the password field should be used to enter both token and your password, like: Password: 123456PASSWORD

The code will change every 30 seconds. Sample code:
../../_images/google_token_sample.png


Setup Self-Signed Certificate Chains with OPNsense

This how-to describes the process of creating self-signed certificate chains with the help of OPNsense which has all the tools available to do so.

Chains give the possibility to verify certificates where a single one is nothing more than that, a single certificate.

Look at the default install, one certificate is created for the webgui/dashboard. There is nothing wrong with that certificate if we use a real world CA, but we do not. We create our own chain so that one has no purpose once done.

Should you even consider using self-signed certificate chains in this age of free available certificates?

        Self-signed certificate are just as secure as real world certificates.

        They are trustworthy chains, you know all parties.

        Intranets are often set up with these chains.

        Depending on what you do with your network/servers this is a good solution.

        Creating your own chain will give some insight in the process.

        Only use them if you are sure you can. Read about the concept in common there is a lot of info on the net.

        They are required for intercepted connections (see proxy chapter)

What you should not do with a self-signed chain:

        Use them for a web-facing server.

        Intercept encrypted traffic on a public wireless network (for example if you provide access in a hotel)

What you should know about self-signed certificates:

        They are only as trustworty as the person, company or organization signing it, this is also true for trusted certificates.

A chain will need at least a CA and certificate; an intermediate CA is not needed, but in case of a compromise the CA key would be compromised too. The CA private key should be stored offline on an USB stick/HD and put in a safe, not reachable by malicious software or criminals/burglers. The intermediate CA, which is intended for a shorter lifetime can be kept on the firewall host.

The chain we are going to create will be made with the following ingredients:

        CA = certificate authority = root certificate --> signs intermediate certificates

        Intermediate CA = subordinate certificate = signed by CA --> signs certificates

        Certificate = signed by Intermediate CA = can be used for different services

Please backup before you proceed.
Create a Chain for OPNsense
The Authority

The first certificate to create is the CA. The only thing this CA does is sign the intermediate CA next in the line of trust.

Note

Self-signed root CA’s anchor trust chains, they are vital and OpenSSL requires them for your chain of trust.

Go to Trust/Authorities
../../_images/trust.png

Some entries in the form are showed here. Click on the thumbnail for a picture.

When you are done save the form, the CA is now generated.

Descriptive name
	

opnsense-ca
	

Choose a name that makes sense to you

Method
	

create an internal ca
	

Main purpose of CA

Common Name
	

internal-ca
	

Default is fine, change to liking

Lifetime(days)
	

3650
	

Longer is also no problem for CA
../../_images/CA.png

Tip

Always use valid email addresses for your certificates. Bogus addresses can pose a security risk - and not only for certificates. F.I.: If one should use user@example.com and someone claims example.com mail will be send there!
The Intermediate

Time to create the second CA, which is an intermediate CA. This certificate will be signed by the root CA we just created. In return it will sign the sever certificate for OPNsense.

Go to Trust/Authorities

Have a look at the form, create an intermediate CA and save it.

Descriptive name
	

opnsense-ca-intermediate
	

Choose a name that makes sense to you

Method
	

create an intermediate ca
	

Main purpose of CA

Common Name
	

intermediate-ca
	

Default is fine, change to liking
../../_images/CA-inter.png
The Certificate

The third certificate will be a server certificate signed by the intermediate CA we just created. This will also be the last one we create for this chain.

Go to Trust/Certificates

Have a look at the next form and notice the common name, create a server certificate and save it.

Descriptive name
	

opnsense-ca-intermediate
	

Choose a name that makes sense to you

Method
	

create a server certificate
	

Main purpose of certificate

SAN
	

opnsense.localdomain
	

This should reflect the FQDN see Tip
../../_images/webgui-cert.png

Tip

When creating the server certificate make sure the SAN - Subject Alternative Name is in fact the the FQDN - Fully Qualified Domain Name. You can find it on Linux/Unix with this command hostname -f

Now we need to start using the chain:

        Download the intermediate CA.

../../_images/export_CA_cert.png

        Open your browser and go to Preferences/Certificate/Authorities

        Import the downloaded CA.

        Go back to the dashboard & open System/Settings/Administration

        Set SSL-Certificate to use the new server certificate.

Open your browser and open the OPNsense/webgui page. You should be presented with a certificate that is verified by your intermediate CA.
A Chain for Your Local Nextcloud Server

The local chain for Nextcloud server so we can use OPNsense backup to Nextcloud.

Go ahead and create a new chain CA – intermediate CA – server cert..
The Nextcloud Authority

Go to Trust/Authorities create a new CA for Nextcloud and save it.
../../_images/trust.png

Descriptive name
	

nextcloud-ca
	

Choose a name that makes sense

Method
	

create a ca
	

Main purpose of CA

Common Name
	

nextcloud-ca
	

Change to liking

Lifetime(days)
	

3650
	

Longer is also no problem for CA
../../_images/CA-cloud.png
The Nextcloud Intermediate CA

Next in line will be the intermediate CA which will be signed by the root CA we did just create. This intermediate CA will sign the Nextcloud server certificate.

Go to Trust/Authorities and create an intermediate CA.

Descriptive name
	

nextcloud-intermediate-ca
	

Choose a name that makes sense to you

Method
	

create an intermediate ca
	

Main purpose of CA

Common Name
	

cloud.localdomain
	

Change to liking
../../_images/CA-cloud-inter.png

Download the intermediate CA and install it to your browser:

        Head to the webgui Trust/Authorities export nextcloud-intermediate-ca.crt

        Back to the browser, open Preferences/Certificate/Authorities

        Import the intermediate CA into the certificate store from your browser.

The Nextcloud Server Certificate

Next we create the server certificate for the Nextcloud server.

Go to Trust/Certificates create a server certificate.

Descriptive name
	

cloudserver-cert
	

Choose a name that makes sense to you

Method
	

create a server certificate
	

Main purpose of certificate

SAN
	

cloud.localdomain
	

Should reflect the FQDN
../../_images/cloud-cert.png

We need to install this certificate and key to our Nextcloud server, two ways are shown here.

        Upload the *.p12 archive to your Nextcloud server in a safe way.

        Extact the archive into a single PEM file and create a certificate and a key.

        Use the following commands for a key and certificate:

openssl pkcs12 -in nextcloud-crt.p12 -nodes -out nextcloud.key -nocerts
openssl pkcs12 -in nextcloud-crt.p12 -clcerts -nokeys -out nextcloud.pem
cp nextcloud.pem nextcloud.crt

        Or download the key and certificate separately from OPNsense.

        If SSH is used ‘-i private-key’ is not needed.

scp -i ~/id_ed25519 /path/to/private/nextcloud.key /etc/ssl/keys/nextcloud.key
scp -i ~/id_ed25519 /path/to/nextcloud.pem /etc/ssl/localcerts/nextcloud.pem

        Or use the next quick and dirty method for a single key/certificate file:

        Upload the *.p12 archive to your Nextcloud server, in a safe way..

        Extact the archive into a single PEM file and create a certificate.

openssl pkcs12 -in nextcloud-crt.p12 -out nextcloud-crt.pem -nodes
cp nextcloud-crt.pem nextcloud-crt.crt

        /etc/ssl/localcerts will be alright for the certificate or choose your own prefered location.

        If the key was extracted separatly, /etc/ssl/private would be a good choice.

        Be sure to set sane permissions on the private directory, 755 would do it.

        You could set umask too (see) man umask - on your Linux box.

        Edit the webserver config to use the certificate and key or single key-cert file.

        Sane permissions, 400 read only owner is sufficent.

You should now be able to backup to Nextcloud and have a verified page.

        Cloud Backup

    After setting up the Nextcloud backup everything should work.

Chain for the Local Webserver

This following chain we create is basically the same as the previous chain for Nextcloud server.

If needed use the pictures from the Nextcloud chain.

Create a chain for your server CA - intermediate CA - server cert.

Once done go through the following points:

        Download the server.p12 archive.

        Upload it to the server and extract the archive.

        Store the certificate and key respectively in /etc/ssl/localcerts and /etc/ssl/private

        Use the following commands for that:

openssl pkcs12 -in server.p12 -nodes -out server.key -nocerts
openssl pkcs12 -in server.p12 -clcerts -nokeys -out server.pem
cp server.pem server.crt

        Or download the key and certificate separately from OPNsense.

        If SSH is used ‘-i private-key’ is not needed.

scp -i ~/id_ed25519 /path/to/private/server.key /etc/ssl/keys/server.key
scp -i ~/id_ed25519 /path/to/server.pem /etc/ssl/localcerts/server.pem

        Or if you want to use a single file:

openssl pkcs12 -in some-server-crt.p12 -out some-server-crt.pem -nodes
cp some-server-crt.pem some-server-crt.crt

        Some sane permissions on them.

        Set the server to use the installed certificate.

        Download the intermediate CA.

        Install it in your browser.

        Head to the webservers page and be presented with a verified certificate.


Interfaces
_images/blur-close-up-connection-1624895.jpg

All traffic flowing through your appliance is using (virtual) interfaces, this is where you manage most settings.

    Interface configuration
    Overview
    Settings
    Neighbors
    Virtual IPs
    Wireless
        Interfaces: Wireless Networks (INTERNAL)
    Other Types
    IPv6 setup
    Diagnostics
    Log Files

Setup guides

    Configuring Cellular Modems
    IPv6 For Zen UK
    Configure IPv6 for generic DSL dialup
    Configure IPv6 behind an AVM Fritz!Box
    Configure IPv6 Tunnel Broker
    How to set up a LAN Bridge
    Transparent Filtering Bridge
    Interfaces: Wireless Networks (INTERNAL)
    Deutsche Telekom Germany IPTV (Magenta TV) setup
    Orange France FTTH IPv4 & IPv6
    Orange France IPTV setup
    SFR/RED France FTTH IPv4 & IPv6 & Phone
    Setup for Sky UK ISP


Interface configuration

All traffic in OPNsense travels via interfaces. By default, WAN and LAN are assigned, but many more are possible, like GUESTNET (captive portal) and PFSYNC (high availability).

Note

For legacy compatibility WAN interfaces set to type DHCP or interfaces with a Gateway Rules selection send reply packets to the corresponding gateway directly, also when the sender is on the same interface. This will break connectivity in some rare scenarios and can be disabled via Firewall->Settings->Advanced->Disable reply-to.
Assignments

Most interfaces have to be assigned to a physical port. By default, LAN is assigned to port 0 and WAN is assigned to port 1. Assignments can be changed by going to Interfaces ‣ Assignments. This lists existing interfaces, with the interface name on the left and the physical port selected in the dropdown. New ones can be created here as well, using a non-occupied physical port.

When creating a new interface or changing an existing one (which can be done by clicking its name in the overview), the following options are available:

Option
	

Explanation

General configuration
	

Enable interface
	

Disable the interface without needing to remove its assignment altogether.

Prevent interface removal
	

Avoids accidentally removing an interface (has to be turned off and saved before an interface can be removed).

General configuration
	

Description
	

A short description for clarification, if the name does not suffice.

Block private networks
	

Block traffic claiming to come from private addresses. On WAN interfaces, this kind of traffic should not happen legitimately.

Block bogon networks
	

Block traffic claiming to come from invalid or reserved addresses (Martian packets). Note that this also includes multicast traffic using OSPF and RTMP.

IPv4 Configuration type
	

How to obtain the IPv4 address for this connection.

IPv6 Configuration type
	

How to obtain the IPv6 address for this connection.

MAC Address
	

Can be used to spoof the MAC address. Can usually be left blank (in which case it will use the actual MAC address of the hardware).

MTU
	

Maximum Transfer Unit.

MSS
	

Maximum Segment Size.

Speed and duplex
	

It is recommended to leave this on the default, unless you know what you are doing and the setting you pick matches the one on the physical port.

Dynamic gateway policy
	

If the destination is directly reachable via an interface requiring no intermediary system to act as a gateway, you can select this option which allows dynamic gateways to be created without direct target addresses. Some tunnel types support this.

Note

When configuring VPN clients without static tunnel addresses, you can use the “Dynamic gateway policy” option to automatically generate gateways to the device (without address).

In addition to these settings, the following blocks will be enabled depending on what is configured under “IPv4 Configuration type” and “IPv6 Configuration type”.

For IPv4:

Option
	

Explanation

Static IPv4 configuration
	

IPv4 address
	

IPv4 gateway rules
	

When a gateway is set here, packets entering the interface will also sent out on the same interface when replied. In addition outbound NAT will be set up automatically when mode is set to Automatic or Hybrid.

DHCP client configuration
	

Configuration Mode
	

Alias IPv4 address
	

Used as a fixed alias IPv4 address by the DHCP client.

Reject Leases From
	

Can be used to ignore DHCP leases from ISP-issued modems, for example.

Hostname
	

This value is sent as the DHCP client identifier and hostname when requesting a DHCP lease. Some ISPs may require this (for client identification).

Override MTU
	

An ISP may incorrectly set an MTU value which can cause intermittent network disruption. By default this value will be ignored. Unsetting this option will allow to apply the MTU supplied by the ISP instead.

PPP configuration
	

Service Provider
	

By selecting a country, provider and plan here, OPNsense can fill in the other fields for you. If your provider or plan not in the list, you have to set them manually.

Username
	

Password
	

Phone number
	

Access Point Name (APN)
	

Modem port
	

Advanced PPP
	

Will take you to the Point-to-Point device settings.

PPPoE configuration
	

Username
	

Password
	

Service name
	

Leave blank unless specified by provider.

Host-Uniq
	

See above.

Dial-on-demand
	

Only connect when traffic is sent over the interface

Idle timeout (seconds)
	

Advanced and MLPPP
	

Will take you to the Point-to-Point device settings.

PPTP/L2TP configuration
	

Username
	

Password
	

Local IP address
	

Remote IP address
	

Dial-on-demand
	

Only connect when traffic is sent over the interface

Idle timeout (seconds)
	

Advanced
	

Will take you to the Point-to-Point device settings.

For IPv6:

Option
	

Explanation

Static IPv6 configuration
	

IPv6 address
	

IPv6 gateway rules
	

When a gateway is set here, packets entering the interface will also sent out on the same interface when replied.

Use IPv4 connectivity
	

Set the IPv6 address on the IPv4 PPP connectivity link.

DHCPv6 client configuration
	

Configuration Mode
	

Setting this to “Advanced” will make the settings below “Use VLAN priority” visible.

Request only an IPv6 prefix
	

Only request an IPv6 prefix; do not request an IPv6 address.

Prefix delegation size
	

The delegated prefix length provided by the DHCPv6 server. Normally specified by the ISP.

Send IPv6 prefix hint
	

Send an IPv6 prefix hint to indicate the desired prefix size for delegation

Use IPv4 connectivity
	

Set the IPv6 address on the IPv4 PPP connectivity link.

Use VLAN priority
	

Certain ISPs may require that DHCPv6 requests are sent with a specific VLAN priority.

Interface Statement
	

Click the “i” to see what the four subfields do.

Identity Association
	

Prefix Interface
	

Authentication
	

Keyinfo
	

SLAAC configuration
	

Use IPv4 connectivity
	

Set the IPv6 address on the IPv4 PPP connectivity link.

6RD Rapid Deployment
	

6RD prefix
	

The 6RD IPv6 prefix assigned by your ISP. e.g. ‘2001:db8::/32’

6RD Border Relay
	

The 6RD IPv4 gateway address assigned by your ISP

6RD IPv4 Prefix length
	

The 6RD IPv4 prefix length. Normally specified by the ISP. A value of 0 means we embed the entire IPv4 address in the 6RD prefix.

6RD IPv4 Prefix address
	

The 6RD IPv4 prefix address. Optionally overrides the automatic detection.

Track IPv6 interface
	

IPv6 Interface
	

This selects the dynamic IPv6 WAN interface to track for configuration.

IPv6 Prefix ID
	

The delegated IPv6 prefix ID. This determines the configurable /64 network ID based on the dynamic IPv6 connection.

Manual Configuration
	

If this option is set, you will be able to manually set the DHCPv6 and Router Advertisements service for this interface. Use with care.
Mobile Networking
../_images/OPNsense_4G_new.png

OPNsense supports 3G and 4G (LTE) cellular modems as failsafe or primary WAN interface. Both USB and (mini)PCIe cards are supported.
Supported Devices

While all devices supported by FreeBSD will likely function under OPNsense their configuration depends on a AT command string that can differ from device to device. To make thing easier some of these strings are part of a easy selectable profile.

Tested devices by the OPNsense team include:

    Huaweu M909S-120 (device cuaUx.0) (Requires separate SIM card holder/adapter) [Tested: OPNsense 21.1]

    Huawei ME909u-521 (device cuaUx.0)

    Huawei E220 (device cuaUx.0)

    Sierra Wireless MC7304 (device cuaUx.2) [as of OPNsense 16.7]

Note

If you have tested a cellular modem that is not on this list, but does work then please report it to the project so we can list it and inform others.
Configure Cellular modems

Setting up and configuring a cellular modem is easy, see: Configuring Cellular Modems
3G - 4G Cellular Failover

To setup Cellular Failover, just follow these two how-tos:

    Configuring Cellular Modems

    Multi WAN

Note

Treat the cellular connection the same as a normal WAN connection.


Overview

The interfaces overview contains an extended version of ifconfig that’s available on most systems.

You can use this page to check the current assigned addresses, interface status, link status and other details.

When an interface is configured using DHCP, you can also reload/release an address here.


Settings

There are some advanced settings, which you can alter in Interfaces ‣ Settings, most of the time you should leave these settings default, but advanced scenarios may require specific settings.

The settings on this page will be applied after reboot or a reconfiguration of each interface.

Note

When using VLAN’s make sure to assign the parent interface as well as hardware settings are configured on the device itself.
Hardware CRC

Disable hardware checksum offloading, which is checked by default, controls if user-configurable checksum offloading might be handled by the network card. Not all technologies support this (IPS for example) and some drivers have issues when enabled. We generally advise to keep this disabled, the performance gain is debatable as well.

(the ifconfig settings in the OS related to this setting are txcsum , rxcsum , txcsum6 , rxcsum6)
Hardware TSO

Disable hardware TCP segmentation offload, also checked by default, prevents the system to offload packet segmentation to the network card. This option is incompatible with IPS in OPNsense and is broken in some network cards.

(the ifconfig settings in the OS related to this setting are tso , tso4 , tso6)
Hardware LRO

Disable hardware large receive offload, which is checked by default, prevents the network card from aggregating incoming packets into a larger buffer before passing it further on the network stack (in order to decrease the number of packets to process).

For routing traffic its usually advisable to disable options which queue traffic in the network card to prevent additional latency.

Enabling LRO might degrade routing performance or for some drivers is incompatible with packet-forwarding at all.

(the ifconfig setting in the OS related to this setting is lro)
VLAN Hardware Filtering

Set usage of VLAN hardware filtering. This hardware acceleration may be broken in some device drivers, our advice is to keep this setting on “Disable VLAN Hardware Filtering”, which is the default as of 20.7. In some cases (pre 20.7) we have seen random disconnects when the driver is forced into a mode it was not set at by default.

(the ifconfig settings in the OS related to this setting are vlanhwtag, vlanhwcsum , vlanhwfilter , vlanhwtso)
ARP Handling

By default the kernel logs movement of ip addresses from one hardware address to another and when an arp request is received on the wrong interface. When checking this option, it will stop doing so, which is practical if multiple interfaces reside on the same broadcast domain.

(for a more detailed description, see man arp and search log_arp_wrong_iface and log_arp_movements)
Allow IPv6

By default selected, when deselected IPv6 related configuration will be ignored and a firewall rule will be generated blocking all transit IPv6 traffic on this machine. The floating firewall section will display this rule when “Automatically generated rules” is expanded.
Prevent release

Do not send a release message on client exit to prevent the release of an allocated address or prefix on the server.
Log level

Modify log level for IPv6 clients. Info will give status, interface leases and addresses. Debug will give full diagnostics.
DHCP Unique Identifier

This option can be used to enter an explicit DUID for use by IPv6 DHCP clients, the different types are detailed in section 11 of rfc8415

When not set, the dhcp v6 client (dhcp6c) will assign one automatically.


Neighbors

The neighbors section (available as of 24.1) allows the definition of static IPv4 and IPv6 addresses on your network.

For IPv4 entries will be saved into the ARP table, IPv6 uses NDP to register machines mac addresses to IP addresses.

These tables determine to which (physcal) machine an IP address is connected, which can be practical when arp messages are not being received or we want to force the ip/mac combination for specific clients.

When opening the page it will show a grid containing all static entries defined, these may also originate from other components (such as dhcp), in which case you cannot edit them. Entries defined here do contain the following options:

Ether Address
	

Hardware MAC address of the cllient (format xx:xx:xx:xx:xx:xx)

IP address
	

IP address to assign to the provided MAC address, which will either end up in the arp (IPv4) or ndp (IPv6) table

Description
	

Description for internal use

Tip

To analyse the current contents of the ARP or NDP tables, use the interface diagnostics menu detailed in the diagnostics document.


Virtual IPs

When using additional addresses for features like NAT or binding services to different interfaces, you can add extra addresses to already defined interfaces using Virtual IPs.

Note

Virtual IPs also play a vital role in high availability setups
Types and their usage

OPNsense supports different types of virtual addresses all with their specific purposes, which we will explain below.
IP Alias

A standard extra address, which you can use to bind services to or use in NAT rules.

The address will act like a normal interface address, which means it will respond to ICMP ping requests and will generate ARP traffic (OSI layer 2).

Additionally you can add an alias into an existing CARP group (by setting its VHID). See the CARP VIP type below for more information.

Usually the subnet mask should match the interfaces or be defined as a single address (/32 or /128).
CARP

Specifies an address for use in a high availability cluster, acts like a regular address when the node is in MASTER state.

A VHID Group number must be specified. The “Select an unassigned VHID” button allows you to automatically select an available VHID number. The usual approach to selecting a VHID is to use a different number per interface, but this is not a strict requirement, since the underlying protocol only requires a VHID to be unique within the broadcast domain of the specified interface. However, to ease management and debugging it is recommended to keep a separate VHID per interface.

Internally a custom mac address is generated needed for the protocol. More information about CARP can be found in our high availability section.

Note

The virtual MAC address of a CARP interface is 00:00:5e:00:01:XX, where the last two digits will be populated by its vhid.

Note

CARP uses IP protocol number 112 (0x70), to detect priority it will send out advertisements using 224.0.0.18 or FF02::12. As of OPNsense 24.7 it’s also possible to use unicast when infrastructure in between filters multicast packets.

Note

The source address CARP packets use can not be influenced from the firewall (usually it’s the first address on the interface), when there’s some filtering performed between both firewalls (e.g. a cloud portal), make sure to allow carp traffic from the actual sending address. You can use the packet capture when in doubt which address it is using.

Tip

Although we generally prefer multicast packets (default) for advertisements, as of OPNsense 24.7 unicast may also be chosen. Just make sure to enter a non carp target address on both machines.

Tip

If you’re debugging a CARP setup, consider raising the CARP system logging verbosity. This can be done by adding the net.inet.carp.log with value 2 tunable in System -> Settings -> Tunables. The logs can be seen in System -> Log Files -> General (kernel process) or by using dmesg.

Combining CARP virtual IP types with IP aliases

In cases where there is a need for multiple IP aliases on a single interface which should be shared by a CARP cluster, you can assign a single CARP VIP with a specific VHID in combination with regular IP alias types, setting the VHID field to the same number as the initial CARP VIP VHID:

    The entire set of configured virtual IP addresses are now considered a single host (VHID).

    Only this VHID will send out advertisement packets.

    The set of IP addresses for this VHID are hashed and inserted in the advertisement packets. This hash is compared to the same VHID hash on the peer on reception of CARP advertisements. If they do not match, the peer will assume the master role as the configuration is out of sync.

Note

See Adding multiple CARP IPs for more information and the proper procedure to add IP aliases to a running CARP cluster.

Warning

While technically it is possible to assign multiple CARP VIPs on the same interface, but with separate VHIDs, this has no benefit and is not recommended. The CARP traffic and system procedures for failover will increase linearly in noise per virtual IP. Since the primary purpose of CARP is to react to link state changes, a single VHID acting for a single interface is the most efficient way to use the protocol.
Proxy ARP

Does not add a real address to an interface, instead it will use choparp to reply to arp requests on the network. This can sometimes be practical in situations where clients should be let to believe an address is local.
Other

The other type won’t respond to ICMP ping messages or reply to ARP requests, it merely is a definition of an address (or range) which can be used in NAT rules. This is convenient when the firewall has a public IP block routed to its WAN IP address, IP Alias, or a CARP VIP.
Settings

The interface should validate suitable combinations of settings, below you will find a detailed explanation for everyone of them.

Mode
	

The type of address, as defined in Types.

Interface
	

The interface this address belongs to.

Type
	

Either Network or Single address, only has affect when creating NAT rules, where Proxy ARP and Other combined with Expansion will generate separate addresses for all items in the netmask.

Address
	

The address and netmask to assign, when assigning multiple addresses in the same network, the masks usually should match.

Deny service binding
	

Assigning services to the virtual IP’s interface will automatically include this address. Check to prevent binding to this address instead.

Peer (ipv4, ipv6)
	

(OPNsense version >= 24.7) CARP Destination address to use when announcing, defaults to multicast, but can be configured as unicast address when multicast can not be used (for example with cloud providers)

Gateway
	

Only applies to IP Alias types, usually this field should be empty, except some tunnel devices (ppp/pppoe/tun) expect the gateway address to be defined.

Disable Expansion
	

Disable expansion of this entry into IPs on NAT lists (e.g. 192.168.1.0/24 expands to 256 entries).

Virtual IP Password
	

The password used to encrypt CARP packets over the network, should be the same on preferred master and backup node(s).

VHID Group
	

The Virtual Host ID. This is a unique number that is used to identify the redundancy group to other nodes in the group, and to distinguish between groups on the same network. Acceptable values are from 1 to 255. This must be the same on all members of the group.

Advertising Frequency
	

Defines how often is advertised that this interface is part of a group (Base defined in seconds) and how much to skew when sending advertisements. A higher skew means less preferred.

Description
	

User friendly description of this VIP
Status

The status page shows all configured carp VHID groups and their active status. Our status screen also offers some buttons to disable carp or force a node into maintenance mode.

All different statuses are detailed below.
INIT

Usually this indicates there is an issue with the interface, often this relates to not disconnected interfaces or other technical problems.
BACKUP

In backup state this interface is part of a cluster and listening to advertisements. If for some reason it won’t receive advertisements for a short period of time, it will transition to master.
MASTER

Marks the active node, while listening to advertisements seen on the network. If another node is seen with a better advertisement it might transition to backup (depending on preempt setting, found on the System ‣ High Availability ‣ Settings page).
DISABLED

Displayed when Temporarily Disable CARP is clicked on this page.


Wireless

Although wireless networks are supported in OPNsense, result may vary.

In our experience most companies use separate access points to facilitate WiFi, for reasons as supported technology (nowadays most devices expect wireless-ac, which isn’t supported), stable hardware and often the location where the firewall is installed plays an important role (signal strength issues).

Our documentation on the subject is limited, contributions will be shown below.

    Interfaces: Wireless Networks (INTERNAL)


Interfaces: Wireless Networks (INTERNAL)

This page is about setting up a wireless interface in access point mode to create your own WLAN. In this mode, your Laptops and handhelds can connect to your OPNsense without an external access point for home and enterprise environments. For home networks step over step two and don’t setup the 802.1X service in the network settings. For external access point, just create a cabled network (usually Ethernet) and connect the access point to the other end.

Warning

FreeBSD supports wireless adapters in access point (infrastructure) mode, but this functionality is limited to some drivers and there may be some, which do not support all options available via the web interface. Please make sure that you buy a wireless card that is supported to avoid these problems.

Note

This guide requires the FreeRADIUS plugin to be installed and enabled (via System ‣ Firmware ‣ Plugins and Services ‣ FreeRADIUS ‣ General) .
Configuration
Step 1

Create a wireless clone interface and assign it.
Step 2 - Prepare RADIUS
../../_images/interface_wireless_radius_2.png

Create a new client, which is the AP. For example, name it localhost, choose a secret and the CIDR 127.0.0.0/8. The secret is later used in the wireless settings.
../../_images/interface_wireless_radius_4.png

Next, switch to the users menu and create a new user (for example for yourself). The username and the password are used to authenticate later. The rest of the settings can be left on their defaults.
Step 3 - Prepare WLAN
../../_images/interface_wireless_radius_1.png

Enable
	

Check

Description
	

WLAN

IPv4 Configuration Type
	

Static IPv4

IPv4 address
	

A network

IPv4 Upstream Gateway
	

WLAN

Persist common settings
	

Check (save for all clones)

Standard
	

802.11g or another standard your adapter supports

Regulatory settings
	

Choose your country

Mode
	

Access Point

SSID
	

Name of the wireless network

WEP
	

Unchecked

WPA
	

Checked with your PSK (WLAN password if wanted)

WPA Mode
	

WPA2

WPA Key Management Mode
	

Extensible Authentication

Authentication
	

Open System Authentication

WPA Pairwise
	

AES

Enable IEEE802.1X Authentication
	

Check if you want to use RADIUS authentication

802.1X Server IP Address
	

127.0.0.1 (if you want RADIUS)

802.1X Server Port
	

1812 (if you want RADIUS)

802.1X Server Shared Secret
	

The password you configured in step 2 (if you want RADIUS)
Step 4 - Connect

Note

This is system specific - this screenshot is for a Linux distribution with KDE Plasma Workspaces 5, with the system language set to German.
../../_images/interface_wireless_radius_3.png

To connect to the network, set the security setting to “WPA/WPA2 Enterprise” and the authentication setting to “Protected EAP (PEAP)”. The inner authentication should be set to MSCHAPv2, and the username and password are the ones you set up in the RADIUS plugin.


Other Types

Besides wired, wireless and VPN interfaces, there are also some other, virtual interfaces, as well as some miscellaneous interface-related. These options can be found under Interfaces ‣ Other types. This document briefly explains these options.
Bridge

Bridging allows to create a connection between separate networks, allow traffic on network A destined for network B (where both networks are connected to your OPNsense device) to reach it via this bridge. Note that this does not include DHCP services—this needs to set using DHCP relaying.

A bridge works like a (layer-2) switch, forwarding traffic from one interface to another. Multicast and broadcast packets are always forwarded to all interfaces that are part of the bridge. For unicast traffic, the bridge learns which MAC addresses are associated with which interfaces and will forward the traffic selectively.

Optionally a bridge can be configured to support (Rapid) Spanning Tree Protocol (RSTP/RTP) to prevent loops in the network topology. These options are provided in the “advanced” section of the configuration and include the following settings:

Option
	

Description

Enable
	

Enable the (Rapid) Spanning Tree Protocol

Protocol
	

Protocol to use, rapid or regular spanning tree

STP interfaces
	

The interfaces tith [R]STP enabled, from the ones in the bridge

Valid time (maxage)
	

Set the time that a Spanning Tree Protocol configuration is valid. The default is 20 seconds.

Forward time (fwddelay)
	

Set the time that must pass before an interface begins forwarding packets when Spanning Tree is enabled. The default is 15 seconds.

Hello time (hellotime)
	

Set the time between broadcasting of Spanning Tree Protocol configuration messages. The hello time may only be changed when operating in legacy STP mode. The default is 2 seconds.

Priority
	

Set the bridge priority for Spanning Tree. The default is 32768. The minimum is 0 and the maximum is 61440.

Hold count (holdcnt)
	

Set the transmit hold count for Spanning Tree. This is the number of packets transmitted before being rate limited. The default is 6. The minimum is 1 and the maximum is 10.

[interface] Priority (ifpriority)
	

Set the Spanning Tree priority of interface to value. The default is 128. The minimum is 0 and the maximum is 240. Increments of 16.

[interface] Path cost (ifpathcost)
	

Set the Spanning Tree path cost of interface to value. The default is calculated from the link speed. To change a previously selected path cost back to automatic, set the cost to 0. The minimum is 1 and the maximum is 200000000.

Other advanced options available in the bottom section of the screen and include the following settings:

Option
	

Description

Cache size (maxaddr)
	

Set the size of the bridge address cache to size. The default is 2000 entries.

Cache entry expire time (timeout)
	

Set the timeout of address cache entries to this number of seconds. If seconds is zero, then address cache entries will not be expired. The default is 1200 seconds.

Span port
	

Span ports transmit a copy of every frame received by the bridge. This is most useful for snooping a bridged network passively on another host connected to one of the span ports of the bridge.

Edge ports
	

Set interface as an edge port. An edge port connects directly to end stations and cannot create bridging loops in the network; this allows it to transition straight to forwarding.

Auto Edge ports
	

Allow interface to automatically detect edge status. This is the default for all interfaces added to a bridge, selecting interfaces will disable auto mode.

PTP ports
	

Set the interface as a point-to-point link. This is required for straight transitions to forwarding and should be enabled on a direct link to another RSTP-capable switch.

Auto PTP ports
	

Automatically detect the point-to-point status on interface by checking the full duplex link status. This is the default for interfaces added to the bridge, selecting interfaces will disable auto mode.

Sticky ports
	

Mark an interface as a “sticky” interface. Dynamically learned address entries are treated as static once entered into the cache. Sticky entries are never aged out of the cache or replaced, even if the address is seen on a different interface.

Private ports
	

Mark an interface as a “private” interface. A private interface does not forward any traffic to any other port that is also a private interface.
GIF

GIF (gif(4), Generic Tunnel Interface) can be used to tunnel IPv6 via IPv4 connections. A common use for this is the IPv6 tunnel of Hurricane Electric (he.net).

Note

In Configure IPv6 Tunnel Broker you can find information on how to setup a tunnel using Hurricane Electric

As with all tunnel types, the most important settings relate to how both ends connect and which addressing will be used to route traffic over the tunnel. The rest of the settings usually are best left to their defaults.

Option
	

Description

Parent interface
	

Actually the source address the tunnel will use to connect from.

GIF remote address
	

Peer address where encapsulated gif packets will be sent.

GIF tunnel local address
	

The tunnel’s local address which will be configured on the interface.

GIF tunnel remote address
	

The tunnel’s remote address which will be configured on the interface.

Disable Ingress filtering
	

Ingress filtering on outer tunnel source can break tunnel operation in an asymmetrically routed networks, in which case this can be disabled by marking this option.

ECN friendly behavior
	

Note that the ECN friendly behavior violates RFC2893. This should be used in mutual agreement with the peer.

Description
	

User friendly description for this tunnel
GRE

GRE (gre(4), Generic Routing Encapsulation) is used to create a virtual point-to-point connection, through which encapsulated packages can be sent. This can be used to utilise (OSI-layer 3) protocols between devices over a connection that does not normally support these protocols.

Since the GRE protocol was designed by Cisco, it is often used as default tunnel technology when using their solutions.

A common use-case of GRE is also to forward (no routable) multicast traffic, although this will need additional software such as IGMP-proxy or PIMD, which are less commonly used on OPNsense.

The available settings are similar to those described for the GIF tunnel type:

Option
	

Description

Parent interface
	

Actually the source address the tunnel will use to connect from.

GRE remote address
	

Peer address where encapsulated gif packets will be sent.

GRE tunnel local address
	

The tunnel’s local address which will be configured on the interface.

GRE tunnel remote address
	

The tunnel’s remote address which will be configured on the interface.

Description
	

User friendly description for this tunnel
LAGG

LAGG (lagg(4)) allows for link aggregation, bonding and fault tolerance. This works best if your network switches support. Only unassigned interfaces can be added to LAGG.

The userinterface supports the following options:

Option
	

Description

Parent interface
	

Members of the link aggregation

Lag proto
	

Protocol to use for aggregation, available options are described in the next table. LACP is most commonly used.

Description
	

User friendly description for this interface

Fast timeout
	

Enable lacp fast-timeout on the interface.

Use flowid
	

Use the RSS hash from the network card if available, otherwise a hash is locally calculated. The default depends on the system tunable in net.link.lagg.default_use_flowid.

Hash Layers
	

Set the packet layers to hash for aggregation protocols which load balance.

Use strict
	

Enable lacp strict compliance on the interface. The default depends on the system tunable in net.link.lagg.lacp.default_strict_mode.

MTU
	

MTU size, when unset the smallest mtu of this laggs children will be used.

Available protocols

Name
	

Description

failover
	

Sends and receives traffic only through the master port. If the master port becomes unavailable, the next active port is used. The first interface added is the master port; any interfaces added after that are used as failover devices.

fec
	

Supports Cisco EtherChannel. This is a static setup and does not negotiate aggregation with the peer or exchange frames to monitor the link.

lacp
	

Supports the IEEE 802.3ad Link Aggregation Control Protocol (LACP) and the Marker Protocol. LACP will negotiate a set of aggregable links with the peer in to one or more Link Aggregated Groups. Each LAG is composed of ports of the same speed, set to full-duplex operation. The traffic will be balanced across the ports in the LAG with the greatest total speed, in most cases there will only be one LAG which contains all ports. In the event of changes in physical connectivity, Link Aggregation will quickly converge to a new configuration.

loadbalance
	

Balances outgoing traffic across the active ports based on hashed protocol header information and accepts incoming traffic from any active port. This is a static setup and does not negotiate aggregation with the peer or exchange frames to monitor the link. The hash includes the Ethernet source and destination address, and, if available, the VLAN tag, and the IP source and destination address.

roundrobin
	

Distributes outgoing traffic using a round-robin scheduler through all active ports and accepts incoming traffic from any active port.

none
	

This protocol is intended to do nothing: It disables any traffic without disabling the lagg interface itself.
Loopback

Loopbacks are logical virtual interfaces which emulate real interfaces and can be used for different setup scenario’s, which require always-on interfaces. Below you will find some scenario’s for which these types of interfaces are used.

    Administrative access to services on your machine, which can bind to an address configured on top of the loopback.

    Using loopback addresses as router IDs for OSPF or BGP, which helps to identify your nodes and eases administration

VLAN

VLANs (Virtual LANs) can be used to segment a single physical network into multiple virtual networks. This can be done for QoS purposes, among other things. For this reason, most ISP-issued IPTV devices utilise VLANs.

The following settings are available for these interface types:

Name
	

Description

Device
	

Device name of this virtual interface, usually starts with vlan or qinq depending on the type

Parent interface
	

The interface to use as parent which it will send/receive vlan tagged traffic on

VLAN tag
	

802.1Q VLAN tag (between 1 and 4094)

VLAN priority
	

802.1Q VLAN PCP (priority code point)

Description
	

User friendly description for this interface

Note

802.1ad , also known as QinQ, is supported via the VLAN configuration in which case you would stack a vlan on top of a vlan, the device name should start with qinq in that case.
VXLAN

Virtual eXtensible Local Area Networks (VXLANs) are used to overlay virtualized layer 2 networks over layer 3 networks as described by rfc7348.

Tunnels can be setup in point to point (parameter Remote address) or multicast (parameters Multicast group and Device). The Source address must be an existing (statically assigned) address assigned at this firewall, which will be used as source in the encapsulating IPv4/IPv6 header.

Note

Since the vxlan interface encapsulates the Ethernet frame with an IP, UDP, and vxlan header, the resulting frame may be larger than the MTU of the physical network. The vxlan specification recommends the physical network MTU be configured to use jumbo frames to accommodate the encapsulated frame size. Alternatively, the MTU size on the vxlan interface might be reduced to allow the encapsulated frame to fit in the current MTU of the physical network.


IPv6 setup
../_images/IPv6.png
Introduction

To this day IPv6 remains an elusive topic. IPv6 has long been shipped as a default option in OPNsense and received gradual improvements over the years, but configuration complexity, ISP problems and sometimes also software bugs can cause connectivity to fail or not establish at all. This guide aims to provide groundwork for how IPv6 can be configured and how to spot known mistakes and troubleshoot connectivity.

When talking about external and internal interfaces this guide uses “WAN” and “LAN”, not excluding the possibility for multiple interfaces on each side being used at the same time.

Note this guide will not cover NAT on IPv6 for simplicity’s sake.
IPv6 Modes

Depending on the IPv6 mode selected IPv6 behaviour differs in outcome. The matching mode must be selected for your ISP. If in doubt ask for assistance via your ISP or ask on the forum how other users of your ISP configured it successfully.
None

This mode turns off IPv6 connectivity for this particular interface. Use this mode when the default mode (DHCPv6) does not work or causes broken connectivity with your ISP. It does not prohibit IPv6 globally and some services might even locally require IPv6 in order to communicate to itself (such as Squid web proxy for example).

Note

You can use this mode for WAN and LAN connections.
Static IPv6

When the ISP offers a static address block you can assign one /64 network to your WAN interface and other /64 networks to your LANs. You can even delegate bigger networks within your prefix to downstream routers via DHCPv6 which is generally available in static mode. Note that you need to create and set a gateway address for this mode to connect to your next gateway hop which your ISP should provide to you as well.

Note

You can use this mode for WAN and LAN connections.

Tip

In PPPoE IPv4 mode the “Use IPv4 connectivity” option will assign the IPv6 on the PPPoE device itself instead of the parent device. The use of this option depends on your ISP.
DHCPv6

For dynamic address offerings (that most likely are also shifting the prefix) this mode is the most common configuration and therefore also the default setting for a preset WAN. In this mode a prefix will be acquired if offered, either with or without an additional IP address for your WAN. Note that the interface will not assign a /64 to itself from the prefix in contrast to static IPv6. Internally, a single globally unique address is either acquired via DHCP or SLAAC (not to be confused with SLAAC mode) but in general a ISP-provided link-local address is automatically used for the connectivity to the next hop gateway. Setting “Request only an IPv6 prefix” may be required in case the ISP refuses to hand out an address and/or prefix.

In PPPoE IPv4 mode the “Use IPv4 connectivity” option will acquire address information on the PPPoE device itself instead of the parent device. The use of this option depends on your ISP. Note that in this mode PPPoEv6 is also enabled as some ISPs require it for IPv6 functionality.

Note

You can use this mode for WAN connections only.
PPPoEv6

In PPPoEv6 mode a single address is acquired via the PPPoE IPv4 connection. WAN connectivity to the next gateway hop is established automatically if supported by the ISP.

Note

You can use this mode for WAN connections only.
SLAAC

Use “Stateless Address Autoconfiguration” for the IPv6 connectivity only. In cases where Static IPv6 or DHCPv6 not available this mode may still provide ISP connectivity.

In PPPoE IPv4 mode the “Use IPv4 connectivity” option will acquire address information on the PPPoE device itself instead of the parent device. The use of this option depends on your ISP.

Note

You can use this mode for WAN connections only.
6to4 Tunnel

This is an IPv6 over IPv4 tunnelling mode as specified in RFC3056 over a fixed IPv4 router address. It does not require any client side configuration, but is not being used much anymore due to 6rd.

Note

You can use this mode for WAN connections only.
6rd Tunnel

6rd means “IPv6 Rapid Deployment” which is a generalised form of 6to4 connectivity where a variable prefix can be obtained through configuration. Some ISPs may still use this mode although it’s not very popular in general. The configuration for 6rd may be delivered by IPv4 DHCP connectivity, but is currently not being parsed and presented to the user.

Note

You can use this mode for WAN connections only.
Track Interface

This mode uses a WAN DHCPv6 interface to assign a single /64 network to your LAN interfaces. The “Manual configuration” option switches from automatically configuring router advertisements and DHCPv6 (including prefix delegation if the prefix is big enough) to how Static IPv6 configured devices are able to use it from the menu (off by default).

Note

You can use this mode for LAN connections only.
Basic setup and troubleshooting

There are two steps for providing IPv6:

    Provide IPv6 to your WAN and the firewall itself.

    Provide IPv6 to your LAN including the clients behind it.

For step 1 start with selecting the appropriate IPv6 mode, reconfigure the WAN interface and try to ping an IPv6 address or host from the firewall itself, e.g.:

Test if ping over IPv6 to Internet is successful (also possible via Interfaces‣Diagnostics‣Ping).

# ping -6 heise.de

Test if IPv6 default route exists (also possible via System‣Routes‣Status and search for default).

# netstat -nr6 | grep default

Note

If one or both of these do not work you are looking at a configuration problem on the WAN side or your ISP does not support IPv6 for you at this point. Do not try to debug step 2 at this point wondering why clients cannot connect.

For step 2 static and tracking modes are what can be used on a LAN to provide attached clients with IPV6 connectivity.

Tracking mode is enabled by default and the DHCPv6 on the WAN automatically sets up both Router Advertisements and DHCPv6 server including the use of prefixes being delegated to clients if the present prefix has enough room left to delegate.

When using static mode or the “Manual configuration” setting in tracking you can configure both Router Advertisements and DHCPv6 server from the menu, but defaulting to off. Most endpoint devices work fine with only Router Advertisements set, but if you deal with downstream routers it can be beneficial to set up DHCPv6 server as well to delegate part of the prefix.

Note

Note that certain network stack implementations such as Android phones only support Router Advertisement configuration via SLAAC and DCHPv6 leases do not work there.

Make sure to test the following on multiple different clients to see if connectivity can be established at all or not:

    https://test-ipv6.com/

    https://ipv6-test.com/

These two pages can help you diagnose remaining issues as well. Make sure to set up both DHCPv6 server and Router advertisements during testing when debugging IPv6 connectivity. If you eventually do not have any need for one or the other it’s also ok to disable them. A completely static setup is also possible.
Dynamic address assignments

When not using static addresses on the clients, there are some very important differences between IPv4 and IPv6. In case of IPv4, addresses are being provided using a dhcp server, which usually also propagates a default route to the client.

For IPv6 the first service to look at for autoconfigurating clients is the Router Advertisements daemon, which defines how clients receive their routes and how they will receive an addresss. The available options are provided in the referred document.

The DHCPv6 server, when used, can be configured in a similar way as when using IPv4.
Configuration examples

    IPv6 For Zen UK

    Configure IPv6 Tunnel Broker

    Configure IPv6 for generic DSL dialup


Diagnostics

The interface diagnostics page contains various tools to help debug network issues.
ARP Table

The ARP table module shows all MAC addresses known by this firewall.

IP
	

IPv4 address

MAC
	

MAC address

Manufacturer
	

Manufacturer looked up with the mac address above

Interface
	

Associated interface

Interface name
	

The name of the interface if found

Hostname
	

In case of a DHCPv4 client, the hostname when found in the leases file
DNS Lookup

Perform a quick dns lookup from the firewall.
NDP Table

Show addresses learned by the Neighbor Discovery Protocol for IPv6.

IPv6
	

IPv6 address

MAC
	

MAC address

Manufacturer
	

Manufacturer looked up with the mac address above

Interface
	

Associated interface

Interface name
	

The name of the interface if found
Netstat

The netstat module contains a useful set of network status and statistics metrics, which are split into a number of topics.

Tip
Use the refresh icon in the tab to refresh the data in it (selection won't change).

In order of relevance you can find the following information here:
Interfaces

This section contains all (physical and virtual) attached interfaces to the system containing metrics like the number of packets and bytes send- and received per (hardware) address.
Protocol

Contains system wide statistics for each network protocol. Examples of statistics that can be found in this region are the number of tcp listening connections, sent packets, duplicate packets, etc, etc.
Sockets

Displays network and unix domain sockets, this basically combines netstat with sockstat on FreeBSD in order to provide insights into which process is listening were combined with metrics known by the system.
Netisr

Show statistics from the kernel network dispatch service, known as netisr(9).
Memory

Show statistics recorded by the memory management routines (mbuf(9)). The network manages a private pool of memory buffers.
Bpf

Show statistics about bpf(4) peers. This includes information like how many packets have been matched, dropped and received by the bpf device, also information about current buffer sizes and device states.
Packet capture

The packet capture module can be used to deep dive into traffic passing a (or multiple) network interfaces. It has some options you can choose from, which are detailed below.

Interface
	

List of interfaces to start a capture on. A tcpdump process is started on each selected interface

Promiscuous
	

When set, the system will capture all traffic present on the interface in stead of the traffic heading to the firewall.

Address Family
	

Capture IPv4, IPv6 or both

Invert Protocol
	

Select all but the protocol selected below

Protocol
	

The protocol to filter on

Host Address
	

This value is either the Source or Destination IP/MAC address or subnet in CIDR notation. The packet capture will look for this address in either field. Matching can be negated by preceding the value with “not”. Multiple IP addresses or CIDR subnets may be specified as boolean expression. If you leave this field blank, all packets on the specified interface will be captured. Example: not 10.0.0.0/24 not and not 11.0.0.1 or 00:0a:01:02:03:04

Invert Port
	

Select all but the port selected below

Port
	

Port number to filter on (e.g. 443 for standard https, 22 for ssh)

Packet Length
	

The Packet length is the number of bytes of each packet that will be captured. Default value is 0, which will capture the entire frame regardless of its size.

Count
	

This is the number of packets the packet capture will grab (per selected interface). Default value is 100. Enter 0 (zero) for no count limit.

Description
	

Description to be displayed in “jobs” tab

Packet capture uses tcpdump and runs in the background. After a capture is performed you can either look into it using the View capture button in the jobs tab or download the pcap file(s) to inspect it in an external tool, such as Wireshark.

The jobs tab contains all running or executed captures, the following options are available per capture job:

    Shows the capture is currently active
    Remove capture (stops capture when currently active)
    Stop the current capture
    (Re)starts the current capture, removes previous results when executed before
    Download a zip file containing all captured pcap files and a json file with selected options
    View capture in high detail
    View capture in medium detail
    View capture in standard detail

Tip

All view buttons can be used when the capture is still active, they will just show the details collected until now.
Ping

Use ping to establish if a remote host can be reached using ICMP echo requests. It’s one of the most used tools to validate basic connectivity.

Hostname or IP
	

Hostname or IP address to send the icmp packet too

Address Family
	

Send using IPv4 or IPv6

Source address
	

Source address to use, can be any address configured on this firewall

Packet size
	

Specify the number of data bytes to be sent. Keep in mind this is the payload size, an IP and ICMP header are added.

Do not fragment
	

Set DF bit.

Description
	

Description to be displayed in “jobs” tab

Tip

To locate MTU (Maximum transmission unit) issues, use the “Do not fragment” option to force a packet of certain size to travel the network

Tip

When the default ping is not able to reach the target, but one with a preset source address is, one usally needs to add a static route to force traffic using the correct source address. This is for example common for IPsec policy based tunnels which install a kernel trap on the specified source network.

The jobs tab contains all running or executed pings, the following options and properties are available per job:

    Shows the ping is currently active
    Remove ping (stops capture when currently active)
    Stop the current ping
    (Re)starts the current ping, removes previous results when executed before

description
	

Job description

hostname
	

Target hostname or ip address

source_address
	

Source address (default empty)

send
	

Number of packets send

received
	

Number of packets received

min
	

min time to live (ms)

max
	

max time to live (ms)

avg
	

average time to live (ms)

loss
	

loss percentage

last_error
	

last found ping error
Port Probe

Test if a host has a certain TCP port open and accepts connections on it.
Trace Route

Use traceroute / traceroute6 to measure the path traffic would follow when trying to reach a specific host.

Hostname or IP
	

Target hostname or ip address

Address Family
	

Address family to use

Protocol
	

Protocol to use for the trace, by default UDP is used, if this doesn’t work, ICMP is available as alternative

Source address
	

Source address (default empty)

Tip

The result grid also contains the autonomous system number which can be practical if you want to filter traffic to or from a specific party. Use Firewall ‣ Aliases to collect the associated networks and add them in rules.

Log Files

When troubleshooting problems with your firewall, it is very likely you have to check the logs available on your system. In the UI of OPNsense, the log files are generally grouped with the settings of the component they belong to. The log files can be found here:

Wireless
	

Interfaces ‣ Wireless ‣ Log File
	

When using wireless features of OPNsense you find the logs here

Point-to-Point
	

Interfaces ‣ Point-to-Point ‣ Log File
	

PPP dialup logs like PPPoE are found here


Configuring Cellular Modems

OPNsense supports a wide range of USB and miniPCIe cellular modems that can be used as primary internet (WAN) connection or as failover for a fixed/ethernet connection.

With this guide we show you how to easily add a new modem and configure it to be used as primary WAN connection.
Supported devices

In general, OPNsense should support all cellular modems that are supported by the respective FreeBSD kernel. However, not all devices behave the same way, you might have to tweak your card with specific AT commands, for example in the init string.

The screenshots in this guide are for a Huawei ME909u-521 miniPCIe cellular modem.
Choosing the right hardware

Depending on the country you want to use the modem in, you might need a different cellular modem. mPCIe cards are rather expensive so make sure you get a device that supports the LTE bands of the country and provider you want to work with. Use websites like FrequencyCheck to find the frequency band(s) used and get a cellular modem that supports these frequencies.

You should also buy an appropriate pigtail antenna cable and LTE antenna. Note that LTE antennas often have different connectors than Wi-Fi antennas, chose your equipment accordingly. Getting the right antenna has a big impact on the quality of your signal. For LTE, MIMO (multiple input, multiple output) antennas should be considered, see for example this guide.

Note

Make sure to connect the antenna to the cellular modem once you start configuring the modem in OPNsense. There is little chance that you get any signal without antenna.
Step 1 - Talking to the cellular modem

First, we need to figure out what device is accepting AT commands on your modem. For the Huawei modem used in this example the device is /dev/cuaU0.0, other modems might provide the AT interface on another device.

On FreeBSD, /dev/cuauN devices are call-out ports that are used for modems instead of terminals, see section 26.2.1 in the FreeBSD manual.

The best way to locate the correct port is to send AT commands to it. This can be tested using the utility cu:

cu -l /dev/cuaU0.2
Connected
AT (<-type that)
OK

Once you see Connected type AT. If you do not get an OK back, enter ~. to quit and try the next device. In this particular example, a Sierra Wireless MC7430 card was used and /dev/cuaU0.2 is the only device where we get OK back.

Now, check if a SIM card is available and can be accessed:

cu -l /dev/cuaU0.2
Connected
AT+CPIN?
+CPIN: READY

There are multiple things that can go wrong here, the SIM card might not have been detected or you might have a pin on the SIM.

Once the SIM card is ready, quit cu with ~..

Note

To get rid of the pin, first check if it is valid with AT+CPIN="1234" where 1234 is the pin of your SIM card. To get rid of the pin, enter AT+CLCK="SC",0,"1234". The pin should now be gone.

Note

If you never get a READY after AT+CPIN? you might want to play with the different mPCIe slots on your system. In my case on a PC Engines APU board and a Sierra Wireless card I had to switch slots until the SIM card was detected properly. The middle one did the trick for me, if someone understands how or why this is happening, please add your findings to this documentation. Also, APU boards have more than one SIM slot, try both slots in case the first option did not work.
Step 2 - Configure Point to Point device

Go to Interfaces ‣ Point-to-Point ‣ Devices and click on Add in the upper right corner of the form.

Fill in the form like this (Example is for Dutch Mobile 4G KPN Subscription):

Link Type
	

PPP

Link interface(s)
	

/dev/cuaU0.0 ( HUAWEI Mobile Connect - Modem)

Description
	

4G Cellular Network

Service Provider
	

Select Country, Provider & Plan for auto configuration

Username
	

Leave Empty (for NL KPN)

Password
	

Leave Empty (for NL KPN)

Phone Number
	

*99# (for NL KPN)

Access Point Name (APN)
	

fastinternet (for NL KPN 4G)

If you need to enter a PIN number, then click on Advanced Options

Click Save to apply the settings.
../../_images/4g_configure_ppp.png ../../_images/ppp_celular_configured.png
Step 3 - Assign the WAN interface

To assign the interface go to Interfaces ‣ Assignments in our case we will make this our primary internet connection and change the WAN assignment accordingly.

To do so just change the Network port for WAN to ppp0 (/dev/cuaU0.0) - 4G Cellular Network.

No click Save below the form.

If everything went fine, then you are all set, and the default gateway will be the one of you cellular connection.
../../_images/Interface_assignment_4g.png
Step 4 - Troubleshooting

In case it still does not work, first look at the log of the cellular device’s PPP connection, to do so go to: Interfaces ‣ Point-to-Point ‣ Log File. If you are lucky you can see what went wrong directly in the log. Unfortunately, the PPP log is not very informative so it might not help at all.

If you can’t figure out what is wrong, then a reboot to reinitialize the device can sometimes help. This seems particularly true on embedded devices, better reboot once too much and if you got lost in the options, a factory reset to start from scratch is a good idea too. In our experience playing with SIM cards from different providers required factory resets (for whatever reason) to get them to work properly.

Note

As mentioned above, the SIM card needs to be available. See the hints in the first step of this tutorial to make sure everything is prepared properly.

Note

Some Sierra Wireless modems still seem to need a specific init string to work properly. One that seems to work for multiple users and LTE cards is &F0E1Q0 +CMEE=2. In any case you should first try without init string and only give it a try if you could not get any connection without. You can add this in Interfaces ‣ Point-to-Point ‣ Devices ‣ Your particular device ‣ Advanced Options ‣ Init String.

When the device seems to work properly then checkout if the interface was assigned an IP address, go to Interfaces ‣ Overview and click on the WAN interface to see the details.

You should see an IP address, Gateway IP and ISP DNS server(s). If all is filled in, then either your firewall is blocking the traffic or the network connection is not working well.

In case you were not successful, you might have to check manually what is going on. Read the Troubleshooting PPP Connections section in the FreeBSD manual for more information and consult the OPNsense support forum.


IPv6 For Zen UK

Original Author: Martin Wasley
Introduction

Zen provide two methods of setting up IPv6.

The first method is a simple DHCP method which should suffice most users, the second allows you to set up static IPv6 on LAN. In either case the addresses and prefixes are constant and even under DHCP will not change. Currently Zen provide a /64 WAN address and a /48 prefix allocation. These will have been given to you by Zen when you request IPv6.
Setting up IPv6 using DHCPv6
WAN Interface

Zen use PPPoE in the initial V4 connection, so enter PPPoE as the V4 connection type and set the username and password for the PPPoE connection, for IPv6 using DHCP, select DHCPv6 in the IPv6 connection as shown below.
../../_images/ZenUK_image1.png

The next step is to configure the parameters required for DHCPv6, these are located in the DHCPv6 client configuration section of the WAN interface shown below.
../../_images/ZenUK_image2.png

As stated before, Zen provide a /48 prefix, so select the prefix size accordingly.

The only other requirement in this section is to select ‘Use IPv4 connectivity’, this is because the IPv6 traffic is routed over the PPPoE link.

Click ‘Save’ and then ‘Apply’.
LAN Interface

All that is required now is to set the LAN interface to use assigned IPv6 prefix.

Select Interfaces ‣ [LAN] and set the IPv6 Configuration Type to ‘Track Interface’
../../_images/ZenUK_image3.png

Finally, set the Track IPv6 Interface to WAN, unless there is a special requirement which this document does not cover, set the IPv6 Prefix ID to 0.
../../_images/ZenUK_image4.png

Click ‘Save’ and then ‘Apply’.

It is advisable at this point to reboot the system.
Setting up IPv6 using Static Assignment

Although slightly more complex, this option gives you greater control over LAN DHCP6 server, as this can be tailored to specific needs.

Note: The previous version of this guide provided instructions to configure WAN interface statically. Zen have advised that they are now phasing out static configuration and therefore recommend customers to switch to DHCPv6 for WAN interface.
WAN Interface

Zen use PPPoE in the initial V4 connection, so enter PPPoE as the V4 connection type and set the username and password for the PPPoE connection, for IPv6 using DHCP, select DHCPv6 in the IPv6 connection as shown below.
../../_images/ZenUK_image1.png

The next step is to configure the parameters required for DHCPv6, these are located in the DHCPv6 client configuration section of the WAN interface shown below.
../../_images/ZenUK_image2.png

As stated before, Zen provide a /48 prefix, so select the prefix size accordingly.

The only other requirement in this section is to select ‘Use IPv4 connectivity’, this is because the IPv6 traffic is routed over the PPPoE link.

Click ‘Save’ and then ‘Apply’.
LAN Interface

The LAN interface is very simple to set up, all we need to do is set the IPv6 Configuration Type to Static, and enter our static address.
../../_images/ZenUK_image5.png

Zen give us a /48 prefix to use on the LAN, so pick an address from that range. For example our prefix is:

2a02:8242:55AB::

So

2a02:8242:55AB:0:4:3:2:1 would suffice.
../../_images/ZenUK_image6.png

We want to use a /64 prefix on this interface.

Tip Use the same address as found when setting the system up to use DHCPv6.

Click Save and Apply.
DHCPv6 Server

When using DHCPv6 on the WAN, our DHCPv6 LAN server is set automatically, however when using statics, we need to set it up. Go to Services ‣ DHCPv6[LAN].

Firstly, enable the server.
../../_images/ZenUK_image7.png

You will notice that the subnet already has a range, and the subnet mask is the /64 we set on the LAN. There is also a range we must use, the available range tells us what that can be.

Enter the lower – start range that the server will use

2a02:8231:d256::eeee:0000:0000:0001

Enter the upper – end range that the server will use.

2a02:8231:d256::eeee:ffff:ffff:ffff
../../_images/ZenUK_image8.png

This should cover most LAN subnets, the range given here gives 281,474.976.710,655 addresses.

We can also set up a prefix delegation range, this is used where we have sub routers or VLAN’s that need their own range. In the case of prefixes, we are only interested in the upper 64 bits, as in this example we will only be giving out 64 bit prefixes. We know we have been given a /48 prefix by Zen, so we enter our prefix range like this:
../../_images/ZenUK_image9.png

Our prefix range is the upper 48 bits, plus some of the next 16 bits, but we must not cross into the range we have used for our LAN addresses. In the example above I have allowed for up to 254 /64 subnets.

Once these details have been entered, click save.


Configure IPv6 for generic DSL dialup
Introduction

This short article shows how to setup IPv6 on a standard DSL connection and how to handover the delegated prefix from your provider in your local LAN.

It’s compatible and tested for but not limited to:

    Deutsche Telekom

Step 1 - General Settings

Go to System ‣ Settings ‣ General and check that Prefer IPv4 over IPv6 is not ticked. This value is default so just check if it has been touched.

Also enable Allow DNS server list to be overridden by DHCP/PPP on WAN at the bottom, so you get the correct DNS servers if you just use IPv4 ones.
Step 2 - Allow IPv6

Next go to Interfaces ‣ Settings and verfiy that Allow IPv6 is enabled.
Step 3 - Interface Configuration

In Interfaces ‣ [WAN] and set IPv6 Configuration Type to DHCPv6 and in section DHCPv6 client configuration at the bottom tick:

    Request only an IPv6 prefix

    Send IPv6 prefix hint

    Use IPv4 connectivity

Set the prefix size to the one your provider delegates, mostly /56 or 64, sometimes /48.

Then change to Interfaces ‣ [LAN] and set IPv6 Configuration Type to Track Interface. At the bottom in section Track IPv6 Interface choose IPv6 Interface as WAN and for IPv6 Prefix ID a value of 0 is perfectly fine.

Hit Apply and disable/enable the NICs of your internal systems. Depending on the system and vendor, also a reboot could be required.

If you experience problems with the 24h disconnect disrupting connectivity, it may help to set Prevent Release in section Interfaces ‣ Settings.


Configure IPv6 behind an AVM Fritz!Box

Original Author: Thomas Klein
Introduction

The AVM Fritz!Box, or FB for short, is a popular home router for DSL, Cable and Fiber in Germany. This guide will setup a OPNSense behind a FB, handover delegated prefixes from the provider and configure local interfaces on the OPNSense to cope with dynamically changing IPv6 prefixes.

This guide is based on a Vodafone Cable connection (formerly Kabel-BW) and an AVM Fritz!Box Cable 6591 running Fritz!OS 7.29.

The settings presented here should work for most other dial-up scenarios and FB models too. The size of the delegated subnet may differ.
The Scenario

This guide will configure a home network behind a common dial-up type ISP connection. The OPNsense has an interface pointing to the ISP named WAN and has three internal interfaces called DMZ, LAN and WLAN. Each of those internal interfaces will get a /64 subnet from the delegated IPv6 prefix. This way it is easy to control the dataflow between all four segments on the OPNsense.

In this example the dial-up ISP assigns a /59 prefix to the FB, so there are enough bits left for subnetting in a SOHO setup.
Step 1 - prepare the Fritz!Box

The AVM website has a knowledge base article about the basic settings required on each FB model to enable IPv6 on client devices. https://avm.de/service/wissensdatenbank/dok/FRITZ-Box-6591-cable/1239_IPv6-Subnetz-in-FRITZ-Box-einrichten/ The crucial setting is the checkbox allow other routers IPv6 prefixes. Without that the delegated internal prefixes will not be reachable from the Internet.

Also, not stated in above document, it is possible to modify the Internet - Permit Access settings for the OPNsense host. Select Internet ‣ Permit Access ‣ <your OPN Host> ‣ IPv6 Settings ‣ Open firewall for delegated IPv6 prefixes of this device in order to make your delegated internal subnets available via Internet.
Step 2 - configure the WAN interface

On the OPNSense go to Interfaces ‣ WAN and set the configuration type for IPv6 to DHCPv6. On the bottom part of the dialog in DHCPv6 Client configuration make sure to select

    checkbox: Request only an IPv6 prefix

    checkbox: Send IPv6 prefix hint

    dropdown: Prefix delegation size. For this example setup select 60

Note the following:

    the requested prefix differs by one bit compared to what the ISP delegated the FB (60 vs. 59)

    the setting Request only an IPv6 prefix is the important part. With this setting the FB acknowledges the OPNsense as a router and really delegates a prefix. The OPNSense will only get a link-local 0xfe80 address but that is fine. If this checkbox is not selected the FB considers the OPNsense as an end-user device and plainly refuses to delegate a prefix to it. The OPNsense end up with an valid IPv6 address but with /64 netmask so nothing to delegate into the internal network.

Step 3 - configure the internal DMZ / LAN / WLAN interfaces

Now it is time to set up the internal interfaces. The settings are more or less the same for all of them. Instead of DHCPv6 select Track Interface and on the bottom IPv6 dialog and choose the WAN interface for tracking. This is also the place to divide the delegated prefix into distinct subnets. Just specify an individual Interface prefix ID for each interface. In this example the FB gave us aaaa:bbbb:cccc:9410::/60 and we choose:

Interface
	

Interface prefix ID
	

result-prefix

DMZ
	

0x01
	

aaaa:bbbb:cccc:9411::

WLAN
	

0x02
	

aaaa:bbbb:cccc:9412::

LAN
	

0x03
	

aaaa:bbbb:cccc:9413::

The Interface prefix Id acts as the subnet extension (for lack of better wording) on top of the prefix provided by the FB. In this example we have a /60 prefix so effectively there are 4 bits left for subnetting. As a result valid values for Interface prefix Id are between 0x00 and 0x0f.

In order to being able to manually set up the router advertisements in the next step make sure to select the checkbox Allow manual adjustment of DHCPv6 and Router Advertisements for each of the internal interfaces. If the setting is not used the system tries to set sane defaults for both Router Advertisements and DHCPv6 server.
Step 3.1 - configure the Router Advertisements

With the new subnets in place it is time to configure the Router Advertisements. For this guide the following settings have been chosen:

Setting
	

Value
	

Comment

Router Advertisements
	

Assisted
	

this enables DHCPv6 and SLAAC

Router Priority
	

Normal
	

Default is high which would work too

Source Address
	

Automatic
	

the default

Advertise Default Gateway
	

checked
	

the default

Advertise Routes
	

empty
	

DNS options
	

empty
	

this gives away the OPNsense as DNS server with the current dynamic IP
Step 3.2 - configure the DHCPv6 service

The clients would now be able to grab an IPv6 via SLAAC, find their router and get a DNS resolver but not all clients do know SLAAC. Also there are valid reasons to assign fixed IPv6 address via DHCP to some clients for instance to make them available from the Internet.

In Services ‣ DHCPv6 ‣ [DMZ] (and similar for the other interfaces) the DHCPv6 settings can be configured. Initially the dynamically acquired subnet including the interface id and the available range is shown.

Consider assigning a suitable address pool for DHCP client leases. The target range for the DMZ looks like this: aaaa:bbbb:cccc:9411::1:0 –> aaaa:bbbb:cccc:9411::1:ffff.

But wait! The prefix is dynamic. How to deal with that?

Easy. Just omit the variable prefix and configure the DHCPv6 range to be ::1:0 –> ::1:ffff

OPNSense will automatically prefix this pattern with the dynamically acquired prefix.

Repeat for all the other subnets. Do not forget to configure the Domain search list to match the SOHO internal DNS domain if applicable.
Step 4 - setup Firewall rules

By default outgoing traffic should already be possible but traffic from the Internet to the internal server needs a firewall rule. There are different philosophies on how to manage firewall rules. Just use a similar strategy as with your IPv4 setup so rule management is consistent.

Keep in mind that the DMZ / LAN / WLAN prefix is dynamic. The build-in macros like DMZ net will work for the whole network. But if you need a rule for a single server your should setup an alias pointing to your (fixed) DHCP IP and use this instead.
Troubleshooting

While discovering the specifics of IPv6 behind a FB in combination with OPNsense the first point of debugging was always connecting via SSH to OPNsense on the CLI.

In the directory /tmp/ you will find several IPv6 related intermediate files. The most helpful here was /tmp/<interfacename>_prefixv6. In this file you will find the prefix delegated to you by your upstream router. If you are behind an FB and this file does not exist chances are you forgot to seth the Request only an IPv6 prefix setting on the WAN interface.

Another helpful command is radvdump. This tool dumps the output of the router advertisements in a nicely formatted way.


Configure IPv6 Tunnel Broker

Original Author: Shawn Webb
Introduction

OPNsense supports native IPv6 as well as tunneled IPv6. This article shows how to set up TunnelBroker, Hurricane Electric’s IPv6-in-IPv4 tunnel, with OPNsense. If you’re based in the US and you use Netflix, you might not want to follow these instructions. Netflix now blocks TunnelBroker.

If you use IRC or need access to SMTP over the TunnelBroker connection, Hurricane Electric requires you to go through their free IPv6 certification process. Their “sage” level is the highest level and will allow you to enable IRC and SMTP. Note that your OPNsense firewall must be directly connected to the Internet. Being behind a NAT will not work.

The rest of this article assumes you already have a TunnelBroker account. If not, sign up and go through the free IPv6 certification process. Screenshots are provided throughout this article.
Background

Enable ICMP on the WAN side of your OPNsense firewall. TunnelBroker’s UI will tell you an IP to use when you’re setting up your tunnel on their end.

Now add a tunnel. Make sure to add a routed /48 as we will need that to dish out individual /64 slices to each network. Once configured, your tunnel settings should look like this:
../../_images/tunnelbroker_setup.png
Step 1 - Add GIF tunnel

To configure OPNsense start with adding a new gif interface. Go to Interfaces ‣ Other Types ‣ GIF and click on Add in the upper tight corner of the form.

Use the following settings and copy in the IPv4&6 addresses from your TunnelBroker’s UI.

Parent interface
	

WAN

GIF remote address
	

Server IPv4 Address

GIF tunnel local address
	

Client IPv6 Address

GIF tunnel remote address
	

Server IPv6 Address/64

Route caching
	

disabled

ECN friendly behavior
	

disabled

Description
	

Tunnel Broker
../../_images/opnsense_add_gif.png
Step 2 - Configure the GIF tunnel as a new interface

The newly created GIF tunnel must now be assigned as a new interface. Go to Interfaces ‣ Assignments, select the GIF tunnel for New interface and click the + sign next to it.

Then under Interfaces ‣ [OPTX] (or Interfaces ‣ [TunnelBroker] depending on what you selected) check Enable Interface and change the description to e.g., TUNNELBROKER before hitting Save.

The newly created interface must now be set as the default IPv6 gateway under System ‣ Gateways ‣ Configuration by editing the new gateway entry TUNNELBROKER_TUNNELV6 and checking Upstream Gateway before saving.
Step 3 - Basic Firewall Rules

Now add basic firewall rules. Since I have a LAN network and a WLAN network, I allow WLAN to initiate connections to LAN, but not the other way around. I only have servers on LAN whereas most of my clients are on WLAN (Wireless LAN). I block all incoming to LAN and WLAN. Of course, outbound connections are fine.
../../_images/tunnelbroker_fw_rules.png
Step 4 - Configure LAN interface

Now configure your LAN interface. The static IPv6 address we’ll give it is a /64 address from your assigned /48. I won’t show the WLAN settings simply because it’s the very same. You’ll repeat the same process for further networks, but assigning the next interface a separate /64 address.
../../_images/tunnelbroker_configure_lan.png
Step 5 - Configure DHCPv6 SLAAC

We’ll next configure OPNsense for Stateless Address Auto Configuration (SLAAC). Go to Services ‣ Router Advertisements and choose an interface.

Set the Router Advertisements setting to Assisted and the Router Priority setting to Normal.
../../_images/tunnelbroker_dhcpv6.png

Save your settings.
Step 6 - Test your Configuration

You should now be set up for IPv6. To test your configuration, bring online an IPv6 machine, use your favorite tool to determine you have an IPv6 address. If you’re using SLAAC, it may take up to 30 seconds or more to get an IPv6 address. If you see that your interface has an IPv6 address, you can try going to an IPv6 only test site, such as http://6.ifconfig.pro/
Step 7 - Configure Endpoint Updates

If your IPv4 address is dynamic, it is important to keep your tunnel endpoint up to date to maintain IPv6 connectivity through the tunnel. We will configure automatic updates using ddclient.

First, install the os-ddclient plug-in under System ‣ Firmware ‣ Plugins. Once installed, refresh the UI and go to Services ‣ Dynamic DNS ‣ Settings. Add a new account, the fill in the following information, pulling from your Tunnelbroker’s tunnel settings where needed.

Service
	

he-net-tunnel

Username
	

Tunnelbroker account username

Password
	

Update Tunnel Key

Hostname(s)
	

Tunnel ID
../../_images/tunnelbroker_configuration_ddclient.png ../../_images/tunnelbroker_tunneldetails_id.png ../../_images/tunnelbroker_tunneldetails_key.png

For Check ip method, select any method that will return an IPv4 address (e.g., ipify-ipv4, Interface [IPv4], or ipv4only.me). If using “Interface [IPv4]”, also select the appropriate WAN interface to monitor.

Add a Description for your own use and leave all other options unchanged. Enable and save this account configuration, then enable and start the Dynamic DNS service.


How to set up a LAN Bridge

Original Author: Martin Wasley
Introduction

LAN Bridges should really only be used where the LAN secondary, tertiary and other interfaces are not heavily used, if that is the case then it is recommended that an external switch be used instead. That being said, if the CPU is fast enough then it will easily cope with the extra load placed upon it by the bridge.

When creating a LAN bridge it is essential that you have physical access to the device, you will need to swap the LAN connection at a certain point.
Step One

Configure OPNsense as normal, with a single LAN interface, make sure that it works correctly. It’s a good idea to add the extra NIC interfaces ( OPTx ) during installation.
Step Two

Create the bridge itself. Select Interfaces ‣ Other Types ‣ Bridge and ADD a new bridge. Select from the member interfaces the unused interfaces you wish to add to the bridge, OPT2,OPT3 etc.
../../_images/lan_bridge_1.png

Now Save the new bridge.

Note

It is imperative that the member interfaces have nothing set within them for IPv4 or IPv6, each member interface should be enabled and they should look like this:
../../_images/lan_bridge_2.png
Step Three

Select Interfaces ‣ Assignments and for the LAN interface, select the bridge previously created and Save.
../../_images/lan_bridge_3.png

At this point you will need to swap your LAN cable from the existing LAN connection to one of the NICs that were added to the bridge interface, once connected then you must wait, it can take some time for the interface to come back up, but keep refreshing the web interface until it does.
Step Four

The Original LAN interface is now unassigned and will need to be re-assigned. Go to Interfaces ‣ Assignments and in the New Interface box you will see the NIC itself ( igb*, em* ), select it and hit the ‘+’ button to add an assignment, then click Save.
../../_images/lan_bridge_5.png
Step Five

Select Interfaces ‣ Other Types ‣ Bridge and add the interface created in Step Four to the bridge and Save, remember to check the new interface and ensure it is enabled as in Step Two.
../../_images/lan_bridge_4.png
Step Six

We now need to make two changes to the System Tunables to ensure that filtering is carried out on the bridge itself, and not on the member interfaces. Go to System ‣ Settings ‣ Tunables and select using the pen button net.link.bridge.pfil_member and set the value to 0 (add a new record if this entry doesn’t exist on your installation).
../../_images/lan_bridge_6.png

Select the tunable net.link.bridge.pfil_bridge and set the value to 1
../../_images/lan_bridge_7.png
Final

Once complete, the Interface ‣ Assignments page should look similar to this:
../../_images/lan_bridge_8.png

Now reboot, when the system restores you should have a fully functional bridge interface.


Transparent Filtering Bridge
Warning

The Transparent Filtering Bridge is not compatible with Traffic Shaping. Do not enable the traffic shaper when using the filtering bridge.
Abstract

A transparent firewall can be used to filter traffic without creating different subnets. This application is called filtering bridge as it acts as a bridge connection two interfaces and applies filtering rules on top of this.

For more information on Filtering Bridged on FreeBSD, see filtering-bridges
Requirements

    For this howto we need a basic installation of OPNsense with factory defaults as a starting point.

    And an appliance with 2 physical interfaces.

Considerations

To create this howto version OPNsense 15.7.11 has been used. Some screenshots maybe outdated, but setting should apply up to at least 17.1.6. If you use a different version some options can be different.

Note

The Menu System of the User Interface has been updated with sub items. Where tabs are shown in screenshots, these are now likely visible as submenu.
Configuration in 10 easy steps

    1. Disable Outbound NAT rule generation

    2. Change system tuneables

    3. Create the bridge

    4. Assign a management IP/Interface

    5. Disable Block private networks & bogon

    6. Disable the DHCP server on LAN

    7. Add Allow rules

    8. Disable Default Anti Lockout Rule

    9. Set LAN and WAN interface type to ‘none’

    10. Now apply the changes

Warning

During the configuration you will be asked to “Apply” your changes several times, however this may affect the current connection. So don’t apply anything until completely finished! You need to Save your changes for each step.
1. Disable Outbound NAT rule generation

To disable outbound NAT, go to Firewall ‣ NAT ‣ Outbound and select “Disable Outbound NAT rule generation”.

Filtering Bridge Step 1.png
2. Change system tuneables

Enable filtering bridge by changing net.link.bridge.pfil_bridge from default to 1 in System ‣ Settings ‣ System Tuneables.

Filtering Bridge Step 2.png

And disable filtering on member interfaces by changing net.link.bridge.pfil_member from default to 0 in System ‣ Settings ‣ System Tuneables.

Filtering Bridge Step2a.png
3. Create the bridge

Create a bridge of LAN and WAN, go to Interfaces ‣ Other Types ‣ Bridge. Add Select LAN and WAN.

Filtering Bridge Step 3a.png

Filtering Bridge Step 3b.png
4. Assign a management IP/Interface

To be able to configure and manage the filtering bridge (OPNsense) afterwards, we will need to assign a new interface to the bridge and setup an IP address.

Go to Interfaces ‣ Assign ‣ Available network port, select the bridge from the list and hit +.

Filtering Bridge Step 4.png

Now Add an IP address to the interface that you would like to use to manage the bridge. Go to Interfaces ‣ [OPT1], enable the interface and fill-in the ip/netmask.
5. Disable Block private networks & bogon

For the WAN interface we nee to disable blocking of private networks & bogus IPs.

Go to Interfaces ‣ [WAN] and unselect Block private networks and Block bogon networks.

Filtering Bridge Step 5.png
6. Disable the DHCP server on LAN

To disable the DHCP server on LAN go to Services ‣ DHCPv4 ‣ [LAN] and unselect enable.

Filtering Bridge Step 6.png
7. Add Allow rules

After configuring the bridge the rules on member interfaces (WAN/LAN) will be ignored. So you can skip this step.

Add the allow rules for all traffic on each of the three interfaces (WAN/LAN/OPT1).

This step is to ensure we have a full transparent bridge without any filtering taking place. You can setup the correct rules when you have confirmed the bridge to work properly.

Go to Firewall ‣ Rules and add a rule per interface to allow all traffic of any type.

Filtering Bridge Step 7.png
8. Disable Default Anti Lockout Rule

After configuring the bridge the rules on member interfaces (WAN/LAN) will be ignored. So you can skip this step.

As we now have setup allow rules for each interface we can safely remove the Anti Lockout rule on LAN

Go to Firewall ‣ Settings ‣ Admin Access: Anti-lockout and select this option to disable
9. Set LAN and WAN interface type to ‘none’

Now remove the IP subnets in use for LAN and WAN by changing the interface type to none. Go to Interfaces ‣ [LAN] and Interfaces ‣ [WAN] to do so.

Filtering Bridge Step 9.png
10. Now apply the changes

If you followed each step, then you can now apply the changes. The Firewall is now converted to a filtering bridge.

Done.. ready to set your own filtering rules

Now you can create the correct firewall/filter rules and apply them. To acces the firewall you need to use the IP adress you configured for the OPT1 Interface.

Warning

Rules need to be configured on the bridge. Rules on member interfaces will be ignored!

Tip

Don’t forget to make sure your PC/Laptop is configured with an IP adress that falls within the IP range of the OPT1 subnet!


Deutsche Telekom Germany IPTV (Magenta TV) setup

Original Author: Jascha Kirchhoff
Introduction

This guide is for setting up Deutsche Telekom Germany IPTV (Magenta TV) and assumes you already have a working internet connection and the os-igmp-proxy plugin installed.

This is just a basic working setup. You can separate all IPTV traffic into a VLAN, if needed.

All network hardware between OPNsense and the Media Receiver or TV Box must support IGMP snooping. Without IGMP snooping enabled, the network gets flooded with multicast traffic and live tv starts stuttering.
IGMPproxy setup

Ensure you are running OPNsense 22.1 or later

Then configure IGMPproxy as follows
../../_images/dt_ger_iptv_01.png ../../_images/dt_ger_iptv_02.png

NOTE: downstream interface is LAN
../../_images/dt_ger_iptv_03.png
FIREWALL setup

We need to add two new rules for the WAN interface and modify one (the default IPv4 rule) on the LAN to get Magenta TV working. The key is to enable “allow options” in the Advanced Options for all three (!) rules, WAN and LAN.
../../_images/dt_ger_iptv_04.png

NOTE the Source is “*”
../../_images/dt_ger_iptv_05.png ../../_images/dt_ger_iptv_06.png ../../_images/dt_ger_iptv_05.png

And finally the outbound NAT
../../_images/dt_ger_iptv_07.png

I switched to Hybrid mode but it should also work in Automatic mode, because none of the outbound rules need to be modified.

Make sure you have clicked Save & Apply

It is advisable at this point to reboot the system.

Plug in your Media Receiver to one LAN port, turn on the receiver and after a few minutes you should see live TV. Also software updates should work out of the box. Update mode has been tested 2022-05, no additional settings are required.


Orange France FTTH IPv4 & IPv6

Authors: Kev Willers, David Néel
Introduction

This guide is for Orange France FTTP using DHCP to connect (this method currently excludes the users of the PRO package).

The guide deals with just the internet connection. Setting up of TV or Phone is not covered here.
Getting ready to make the connection

Orange requires that the WAN is configured over VLAN 832. So the first step is to set up the VLAN on the intended WAN nic as shown below Interfaces ‣ Other Types ‣ VLAN
../../_images/OF_image0.png

and the WAN interface assignment should hence look something like this.
../../_images/OF_image1.png

Finally, set the DUID for IPv6 WAN interface Interfaces ‣ Settings
../../_images/OF_image1.1.png

Note

You can use the mac address of the WAN interface (not necessarily the Livebox MAC address) - 00:03:00:01:01:XX:XX:XX:XX:XX:XX where XX is the MAC address
Configuring the WAN Interface

In order to establish the IPv4 and IPv6 connection Orange requires that the correct parameters are passed for the DHCP and DHCP6 requests respectively

select options DHCP and DHCPv6 in general configuration
../../_images/OF_image2.png

On the DHCP request it is a requirement to pass the following:

    dhcp-class-identifier “sagem”

    user-class “+FSVDSL_livebox.Internet.softathome.Livebox6”

    option-90 00:00:00:00:00:00:00:00:00:00:00:66:74:69:2f:65:77:74:FF:AB:XX:XX (hex conversion of the the userid supplied by Orange which looks like fti/xxxxxxx)

    dhcp-client-identifier 01:XX:XX:XX:XX:XX:XX (you MUST use the same MAC address for the XX:XX as the one use for the DUID above)

Note

You can use this tool to generate the option-90 chain : https://jsfiddle.net/kgersen/3mnsc6wy/

These parameters should be passed as comma separated options in the ‘Send Options’ area of their WAN DHCP request
../../_images/OF_image3.png

Note

It is necessary to specify the following ‘Request Options’

    subnet-mask

    broadcast-address

    dhcp-lease-time

    dhcp-renewal-time

    dhcp-rebinding-time

    domain-search, routers

    domain-name-servers

    option-90

    domain-name

    option-120

    option-125

These parameters should be passed as comma separated options in the ‘Request Options’ area of their WAN DHCP request

Orange require that the DHCP and DHCP6 requests are made with a VLAN-PCP of 6. This can be done via ‘Use VLAN priority’ interface settings. Make sure to set this for both DHCP and DHCP6 at the same time.
../../_images/OF_image4.png

On the DHCP6 request we need to use raw options

Firstly select ‘Basic’ and tick ‘Request only an IPv6 prefix’ and set ‘Prefix delegation size’ to 56
../../_images/OF_image5_1.png

Then select ‘Advanced’ and set ‘Use VLAN priority’ to ‘Internetwork Control (6)’
../../_images/OF_image5.png

then add the following options in the ‘Send Options’ field

    ia-pd 0

    raw-option 6 00:0b:00:11:00:17:00:18

    raw-option 15 00:2b:46:53:56:44:53:4c:5f:6c:69:76:65:62:6f:78:2e:49:6e:74:65:72:6e:65:74:2e:73:6f:66:74:61:74:68:6f:6d:65:2e:4c:69:76:65:62:6f:78:36

    raw-option 16 00:00:04:0e:00:05:73:61:67:65:6d

    raw-option 11 00:00:00:00:00:00:00:00:00:00:00:66:74:69:2f:65:77:74:FF:AB:XX:XX (hex conversion of the the userid supplied by Orange which looks like fti/xxxxxxx)

Note

Use the exact same chain for IPv6 raw-option 11 and IPv4 option-90

Finally set the Identity Association and Prefix interface as shown
../../_images/OF_image6.png

Click ‘Save’ and then ‘Apply’.

Update IPv6 Gateway

Select System ‣ Gateway ‣ Configuration and edit IPv6 gateway to add ‘fe80::ba0:bab’ as IP address
../../_images/OF_image6_1.png
LAN Interface

Select Interfaces ‣ [LAN] and set IPv4 to “Static IPv4” and IPv6 Configuration Type to “Track Interface”.
../../_images/OF_image7.png

Finally, set the Track IPv6 Interface to WAN and set the IPv4 address to your chosen address.

Tick ‘Manual Configuration’
../../_images/OF_image8.png

Click ‘Save’ and then ‘Apply’.

Select Services ‣ Router Advertisements On the Lan interface and set as below (use any IPv6 DNS)
../../_images/OF_image9.png

Click ‘Save’

It is advisable at this point to reboot the system.
Troubleshooting
getting the option-90 chain from the Livebox

Rarely, the authentication option from the generator doesn’t work, you can instead use the one from the Livebox

Plug the WAN interface of the Livebox in your network (green port) Use Wireshark on any other computer in the network and look for DHCP Discover packets
../../_images/OF_image10.png
decode DHCP packets

In this packet, look for Option: (90) Authentication
../../_images/OF_image11.png

You can copy paste the full option without the first 2 bytes (5a 46) in your WAN configuration


Orange France IPTV setup

Original Author: Kev Willers
Introduction

This guide is for setting up Orange France IPTV and assumes you already have a working internet connection and the os-igmp-proxy plugin installed.
Getting ready

Orange uses two VLANs for TV. VLAN 838 and 840 Create and assign them as shown.
../../_images/tv_image01.png

Take note of the PCP values

Assign the VLANs as shown and also assign TVLAN for use later.
../../_images/tv_image02.png

igb0 is the WAN in this example. Select the interface that corresponds to WAN in your setup.

TVLAN is assigned to a free port on your router which the TVDecoder is plugged into later.
VLAN 838 setup
../../_images/tv_image03.png ../../_images/tv_image04.png

SEND OPTIONS

dhcp-client-identifier 1:xx:xx:xx:xx:xx:xx, REPLACE xx with MAC Address of the Livebox (NOT the TVDecoder) the leading 1 is important

dhcp-class-identifier “sagem”,

user-class “‘FSVDSL_livebox.MLTV.softathome.Livebox3”. NOTE the leading ‘ before the string. Also although not strictky necessary Livebox3 part of the string is for LiveBox3 users if you are Livebox4 user change as required.

REQUEST OPTIONS

subnet-mask,routers, ntp-servers, www-server, classless-routes
VLAN 840 setup
../../_images/tv_image05.png ../../_images/tv_image06.png

The dummy IP address is important or IGMPproxy does not start
TVLAN setup

(not needed to make things work, but much neater config and prevents IGMPproxy warning messages on LAN)
../../_images/tv_image07.png ../../_images/tv_image08.png

Use a different subnet to current LAN

Turn on the DHCP service for TVLAN

NOTE YOU MUST specify the ORANGE DNS servers for the TV to work
../../_images/tv_image09.png

Now reboot and you should have an IP address on VLAN 838 of 10.x.x.x
IGMPproxy setup

Ensure you are running OPNsense 18.7.4 or later

Then configure IGMPproxy as follows
../../_images/tv_image10.png ../../_images/tv_image11.png

NOTE: downstream interface is TVLAN
../../_images/tv_image12.png
FIREWALL setup

We need to allow traffic to flow on the VLANs and TVLAN and also to connect with Orange servers
../../_images/tv_image13.png ../../_images/tv_image14.png

NOTE the Source is “*”
../../_images/tv_image15.png

And finally the outbound
../../_images/tv_image16.png

Make sure you have clicked Save & Apply

It is advisable at this point to reboot the system.

Plug in your TVDecoder to the port defined for TVLAN, turn on the decoder and after a few minutes you should see TV.


SFR/RED France FTTH IPv4 & IPv6 & Phone

Original Author: Philippe Gaultier
Introduction / Getting ready to make the connection

This guide is for SFR/RED France FTTH using DHCPv4 / DHCPv6 to connect.

The guide deals with internet connection and phone. Support for TV has not been tested.

Note

Before starting this guide, you should have the MAC address of your SFR/RED Box. In the guide you should replace xx:xx:xx:xx:xx:xx with your SFR/RED Box MAC address.

SFR/RED requires that the WAN interface assignment should look similar to this:
../../_images/SFRRED_assignations.png

    WAN interface has MAC xx:xx:xx:xx:xx:xx which is the original WAN MAC of the BOX (spoofed),

    LAN interface has MAC 00:11:22:33:44:55 which is the original MAC of the firewall,

    DUID is 00:03:00:01:xx:xx:xx:xx:xx:xx it’s derived from the original WAN MAC of the BOX (spoofed).

Configuring the WAN Interface

Select Interfaces ‣ [WAN]

In order to establish the IPv4 and IPv6 connection, SFR/RED requires that the correct parameters are passed for the DHCPv4 and DHCPv6 requests respectively.

Select options:

    IPv4 configuration: DHCPv4,

    IPv6 configuration: DHCPv6.

../../_images/SFRRED_WAN_configuration_1.png

On the DHCPv4 request it is a requirement to pass the following:
../../_images/SFRRED_WAN_configuration_2.png

Note

It is necessary to specify the following ”Send Options”:

    dhcp-class-identifier “neufbox_NB6VAC-FXC”

Note

It is necessary to specify the following ”Request Options”:

    subnet-mask, broadcast-address, time-offset, routers, domain-name, domain-name-servers, host-name, ntp-servers, nis-domain, root-path, merit-dump

On the DHCPv6 request we need to use raw options
../../_images/SFRRED_WAN_configuration_3.png

Note

It is necessary to specify the following ”Send Options”:

    ia-pd 1, raw-option 16 00:00:a0:0c:00:40:6e:65:75:66:62:6f:78:5f:4e:42:36:56:41:43:2d:46:58:43

Note

It is necessary to specify the following ”Request Options”:

    domain-name-servers, domain-name

Note

Set Identity Association options to:

    Delegate prefix: checked,

    id-assoc pd ID: 1,

    Prefix: ::/0.

Set Prefix Interface option to:

    Prefix Interface: 8.

Click ”Save” and then ”Apply”.
Configuring the LAN Interface
Interfaces / Parameters

Select Interfaces ‣ Parameters and set your DUID.
../../_images/SFRRED_interfaces_parameters.png

Note

The DUID is based on the SFR/RED Box MAC address : 00:03:00:01:xx:xx:xx:xx:xx:xx.

Click ”Save” and then ”Apply”
Interfaces / [LAN]

Select Interfaces ‣ [LAN] and set IPv4 to “Static IPv4” and IPv6 Configuration Type to “Track Interface”.
../../_images/SFRRED_LAN_configuration_1.png

And define the IPv6 Prefix ID to ”0” Finally, set the following parameters as shown:

    the IPv4 address to the one wanted,

    the IPv6 interfacet to ”WAN”,

    the IPv6 Prefix ID to ”0”.

../../_images/SFRRED_LAN_configuration_2.png

Click ”Save” and then ”Apply”

Note

It is advisable at this point to reboot the system. This will allow you to retrieve an IPv4 address which will be used in next part.
Configuring NGINX to provision the SFR/RED BOX

In order to set up the phone, as the SIP parameters (user/password) are not public, we will add the SFR/RED box in our LAN. This will allow us to plug our regular phone in the SFR/RED box.

Note

This how-to does not cover installation of NGINX nor the use of SSH / shell commands.

First SSH into your OPNSense firewall and create a folder /srv/sfrredbox. In this folder, we will add the scripts used to spoof the SFR/RED Box requests.

In this directory create a file index.php

$currentFirewall = 'firewall.localdomain.intra';
// can probably be replaced with
// $currentFirewall = exec('hostname');
if (isset($_GET['ip_dhcp'])) {
    // adjust re0 to your WAN interface
    $_GET['ip_dhcp'] = exec('ifconfig re0 | grep \'inet \' | cut -d\' \' -f2');
    // if the ifconfig command does not work, set the external IP manually
    // $_GET['ip_dhcp'] = 'your.external.ip.address';
}
$_SERVER['DOCUMENT_URI'] = str_replace('/index.php', '', $_SERVER['DOCUMENT_URI']);
$parameters = http_build_query($_GET);
$url = $_SERVER['REQUEST_SCHEME'].'://'.$_SERVER['HTTP_HOST'].'/'.trim($_SERVER['DOCUMENT_URI'], '/?') .'?'.$parameters;
$ch = curl_init();
curl_setopt($ch, CURLOPT_URL, $url);
curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
curl_setopt($ch, CURLOPT_HEADERFUNCTION, 'readHeaderLine');
$data = curl_exec($ch);
$data = preg_replace('/<proxy([^>]+)>([^<]+)<\/proxy>/', '<proxy$1>'.$currentFirewall.'</proxy>', $data);
curl_close($ch);
header('Content-Length: '.strlen($data));
header('Content-Type: application/xml');
echo $data;

Warning

Code cannot be copied / pasted as-is, you will have to adjust the parameters and make it consistent with your own settings.
Services / Nginx / Configuration

Select Services ‣ Nginx ‣ Configuration

Activate NGINX
../../_images/SFRRED_services_nginx_configuration_1.png
Services / Nginx / Configuration / HTTP(s)

Select Services ‣ Nginx ‣ Configuration ‣ HTTP(s)

Create a new config
../../_images/SFRRED_services_nginx_configuration_2.png

Note

Important settings are:

    Description,

    URL Pattern,

    File System Root,

    Pass Request To Local PHP Interpreter / Threat Upstream.

Services / Nginx / Configuration / HTTP(s) / URL Rewriting

Select Services ‣ Nginx ‣ Configuration ‣ HTTP(s) ‣ URL Rewriting

Add a new rewrite rule
../../_images/SFRRED_services_nginx_configuration_3.png
Services / Nginx / Configuration / HTTP(s) / HTTP Server

Select Services ‣ Nginx ‣ Configuration ‣ HTTP(s) ‣ HTTP Server

Add a new rewrite rule
../../_images/SFRRED_services_nginx_configuration_4.png

Note

NGINX should be serving the page we have created.
Configuring Siproxd to provision the SFR/RED BOX

To allow phone to work, the easiest way is to set Siproxd on the firewall.
Services / Unbound DNS / General

Select Services ‣ Unbound DNS ‣ General

Add parameters to let SFR/RED Box discover the SIP proxy:
../../_images/SFRRED_services_unbound_configuration_1.png

Warning

It appears OPNSense will drop support of functionnality of advanced parameters so I don’t know if it will be possible in future releases to define the DNS stuff using:

    local-data: “_sip._udp.firewall.localdomain.intra. 180 IN SRV 10 60 5060 firewall.localdomain.intra.”

Services / Siproxd

Select Services ‣ Siproxd

Define basic parameters:
../../_images/SFRRED_services_siproxd_configuration_1.png
Services / Siproxd / Outbound Domains

Select Services ‣ Siproxd ‣ Outbound Domains

Create the configuration for outbound domain:
../../_images/SFRRED_services_siproxd_configuration_2.png

Note

The IP address and the port of outbound domain was discovered using an host request on the proxy returned by SFR/RED while provisionning the box. You will have to check the <proxy></proxy> fields of voip2.xml.

    host -t SRV _sip._udp.residential.p-cscf.sfr.net

Note

the host request result gives available SIP servers with the port to use (in my case 5062).

    _sip._udp.residential.p-cscf.sfr.net has SRV record 10 0 5062 mitry.p-cscf.sfr.net. _sip._udp.residential.p-cscf.sfr.net has SRV record 10 0 5062 corbas.p-cscf.sfr.net. _sip._udp.residential.p-cscf.sfr.net has SRV record 10 0 5062 trappes.p-cscf.sfr.net.

Configuring NAT to redirect SFR/RED BOX calls to NGINX

To allow correct port forwarding, we will configure OPNSense to affect a static IP to the SFR/RED Box and we will create an alias for it.
Services / DHCPv4 / [LAN]

Select Services ‣ DHCPv4 ‣ [LAN]

Click on [+] to add a static mapping:
../../_images/SFRRED_services_dhcp_lan.png
Firewall / NAT / Port Forward

Select Firewall ‣ NAT ‣ Port Forward

Add a new forwarding rule:
../../_images/SFRRED_lan_port_forwarding.png

Note

Right now, everything should be ready. Restart the firewall, once ready plug the SFR/RED Box on your LAN and start it. You should be able to enjoy IPv4, IPv6 and Phone.


Setup for Sky UK ISP

Original Author: Martin Wasley
Introduction

This doc covers the setup of OPNsense on a Sky UK VDSL connection.

Sky uses a simple IPoE connection, all that is required is a suitable modem in bridge mode. If using a standard OpenReach modem then no setting is required in the modem itself.
WAN Interface

Set both IPv4 and IPv6 configuration type to DHCP and DHCPv6 respectively.
../../_images/skyuk_wan_1.png
Option61 - dhcp-client-identifier

We now need to send the Sky login credentials. When using VDSL we do not need to use specific credentials, as long as they are correctly formatted anything will do.

Under DHCP Client Configuration select the Advanced button.
../../_images/skyuk_lan_2.png

There is an entry ‘Send Options’, enter the UserID & Password here in the format:

dhcp-client-identifier “user_ID@skydsl|password”

It is said that it doesn’t matter what is sent in the option61 string, which is what this is, as long as something is sent, I prefer to play it safe so stick with the format as shown. For example, the following will work quite happily.

dhcp-client-identifier “12345678@skydsl|12345678”

The other part of the ID is called Option60, there are varying thoughts on whether this is needed anymore, it does no harm to include it so we’ll do so.

dhcp-class-identifier “7.16a4N_UNI|PCBAFAST2504Nv1.0”

So the full entry for the ‘Lease Requirements’ Send Options would be:

dhcp-client-identifier "12345678@skydsl|12345678",dhcp-class-identifier "7.16a4N_UNI|PCBAFAST2504Nv1.0"

The next step is to configure the parameters required for DHCPv6, these are located in the DHCPv6 client configuration section of the WAN interface shown below.
../../_images/skyuk_wan_2.png

Sky provide a /56 IPv6 delegation, they do not provide a global IPv6 address on the WAN interface, this is link local only. Prefix delegation size should be set to 56.

Click ‘Save’ and ‘Apply’

The only other requirement is found in the Interfaces:Settings menu under IPV6 DHCP. The ‘Prevent Release’ option.
../../_images/skyuk_dhcp6c_interface_settings.png

This is there as the Sky DHCPv6 servers use a ‘sticky’ address. If the OPNsense dhcp6 client sends a release signal to the server it’s more than likely that the allocated prefix will change, thus this setting, along with the ‘DHCP Unique Identifier’ setting will attempt to mitigate this risk.

Once these settings have been entered, click on ‘Save’ then ‘Apply’.
DHCP Unique Identifier

Although OPNsense stores the IPv6 DUID it is possible this can be lost, this again would probably result in a new prefix being given, therefore an option to enter and store a DUID is given in the Interface:Settings menu.
../../_images/skyuk_wan_3.png

The Identifier can either be entered manually or if the user clicks on the ‘i’ icon, the existing DUID can be automatically entered into the field by clicking on the ‘Insert the existing DUID here’ legend.

Click ‘Save’.
LAN Interface

The LAN interface Ipv4 address should have been setup during initial system installation, if they were not, then the LAN settings can be adjusted in the Interfaces:[LAN] menu.

It is my recommendation not to use the private subnet range 192.168.*.0, as this range is often used by hotels and other public networks for access, this can cause issues when using a VPN. My preferred address method is using the 10.*.*.0 subnet where the second and third quartet are birth dates or some other easily memorable number. i.e. 10.1.11.0 would be the first of November. This is more random and the chances of the same range on a public network is greatly reduced, however the address range is easily memorable.
../../_images/ZenUK_image3.png ../../_images/skyuk_lan_1.png

Once the LAN IPv4 address is set then all that remains in the LAN interface is to set the interface to use the assigned IPv6 prefix.

Set the Track IPv6 Interface to WAN, unless there is a special requirement which this document does not cover, set the IPv6 Prefix ID to 0.
../../_images/ZenUK_image4.png

Click ‘Save’ and then ‘Apply’.

Setting up the IPv4 DHCP server is not covered in this document, but is required.

It is advisable at this point to reboot the system.


Firewall
_images/architecture-buildings-city-327345.jpg

To manage traffic flowing through your security appliance, a broad range of filtering and shaping features is available. These are all combined in the firewall section.

    Generic info
    Aliases
    Categories
    [Interface] Groups
    Network Address Translation
        Reflection and Hairpin NAT
    NPTv6
    Rules
    Traffic Shaping
        Reserve dedicated bandwidth
        Share internet bandwidth amongst users evenly
        Limit maximum internet bandwidth users can consume
        Prioritize Applications (Weighted) using Queues
        Multi Interface shaping for a GuestNet
        Fighting Bufferbloat with FQ_CoDel
    (Advanced) Settings
    Normalization
    Configure CARP
    Log Files
    Diagnostics

Setup guides

    Organize PF Rules by Category

Generic info

This chapter explains some of the concepts that are being used in different modules of our firewall system and therefore don’t belong to a specific section of this topic.
Address types

When choosing source and or destination addresses, the user can choose several options depending on the context. To explain what the different options mean when being presented, we will sum them up below:

Alias
	

Flexible type of network or address definition for easy reuse, expained in aliases

Single host or network
	

Standard host or network in CIDR notation

any
	

All IPv4 and/or IPv6 addresses (in the world)

This Firewall
	

All IPv4 and/or IPv6 addresses assigned to this firewall

[Interface] Network
	

All networks assigned to the physical interface, this will include networks of virtual addresses assigned as well ([Interface] is explained in the interfaces topic). Normally used to allow traffic from or to clients connected to a specific interface.

[Interface] Address
	

All addresses configured on an interface, this includes all virtual (alias) addresses as well.

Virtual IPs
	

Explicit selection for addresses defined in Virtual IPs


Aliases

Aliases are named lists of networks, hosts or ports that can be used as one entity by selecting the alias name in the various supported sections of the firewall. These aliases are particularly useful to condense firewall rules and minimize changes.

Aliases can be added, modified and removed via Firewall ‣ Aliases.
Overview

The page opens with an overview of the aliases available, including some internal ones available from installed software. At the top of the page you can search for aliases or preselect various types or categories to which they belong.

In order to gain some insights into the current status of the plugins, two additional (meta) fields are being displayed, being:

    Loaded#

        Shows the amount of entries planned to install into the table, in case there’s not enough memory available to load the item in question, one can easily find the alias causing the overflow in table entries (bar at the right top of the page)

    Last updated

            Shows the last timestamp from the entries saved to disk.

Note

The fields above are only used for aliases that contain either networks or hosts, port type aliases are part of the rule and thus not visible in any table.
Alias Types

OPNsense offers the following alias types:

Type
	

Description

Hosts
	

Single hosts by IP or Fully Qualified Domain Name or host exclusions (starts with “!” sign)

Networks
	

Entire network p.e. 192.168.1.1/24 or network exclusion eg !192.168.1.0/24

Ports
	

Port numbers or a port range like 20:30

MAC addresses
	

MAC address or partial mac addresses like f4:90:ea

URL (IPs)
	

A table of IP addresses that are fetched once

URL Tables (IPs)
	

A table of IP addresses that are fetched on regular intervals.

GeoIP
	

Select countries or whole regions

Network group
	

Combine different network type aliases into one

Dynamic IPv6 Host
	

A Host entry that will auto update on a prefixchange

BGP ASN
	

Maps autonomous system (AS) numbers to networks where they are responsible for.

OpenVPN group
	

Map user groups to logged in OpenVPN users

Internal (automatic)
	

Internal aliases which are managed by the product

External (advanced)
	

Externally managed alias, this only handles the placeholder. Content is set from another source (plugin, api call, etc)
Hosts

Hosts can be entered as a single IP address, a range (separated with a minus sign, e.g. 10.0.0.1-10.0.0.10) or a fully qualified domain name.

When using a fully qualified domain name, the name will be resolved periodically (default is each 300 seconds).

Sample

    Let’s say we want to create an alias table for www.youtube.com
    ../_images/aliases_host.png 

Apply changes and look at the content of our newly created pf table.

Go to Firewall ‣ Diagnostics ‣ Aliases and select our newly created youtube table.
../_images/pftable_youtube.png

As you can see there are multiple IP addresses for this domain.

Tip

To change the alias domain resolve interval, go to Firewall ‣ Settings ‣ Advanced and set Aliases Resolve Interval to the number of seconds to refresh.

Hosts type Aliases can contain exclusion hosts. Exclusion addresses starts with “!” sign (eg !192.168.0.1) and can be used to exclude hosts from Network Group Aliases.

Warning

Please note thet the Flush action is not persistent!

“flush” means flush the current contents of the alias, which will be repopulated when it’s not an external type, so flush in most cases isn’t very useful.

Same behaviour applies to the API call alias_util flush
Networks

Networks are specified in Classless Inter-Domain Routing format (CIDR). Use the the correct CIDR mask for each entry. For instance a /32 specifies a single IPv4 host, or /128 specifies a single IPv6 host, whereas /24 specifies 255.255.255.0 and /64 specifies a normal IPv6 network. Network type Aliases can contain exclusion hosts or networks. Exclusion addresses starts with “!” sign (eg !192.168.0.0/24) and can be used to exclude hosts or networks from current Alias or Network Group Alias

Apart from the CIDR notation, one could also use a wildcard mask to match ranges of hosts or networks.

Tip

To match all servers ending at .1 in the 192.168.X.1 networks, use a wildcard definition like 192.168.0.1/0.0.255.0
Ports

Ports can be specified as a single number or a range using a colon :. For instance to add a range of 20 to 25 one would enter 20:25 in the Port(s) section.
MAC addresses

Hardware mac addresses can be specified as a (partial) hex value, such as F4:90:EA to match all addresses from Deciso or f4:90:ea:00:00:01 to match a single item (the input is case insensitive).

The way these aliases function is approximately the same as hostnames in host type aliases, they are resolved on periodic intervals from the arp and ndp tables.

Warning

Please be aware that hardware addresses can be spoofed (https://en.wikipedia.org/wiki/MAC_spoofing), which doesn’t make filters on them more secure than ip addresses in any way.

Note

Since mappings between addresses and mac addresses are resolved periodically the actual situation can differ, you can always check Firewall -> Diagnostics -> Aliases to inspect the current contents of the alias.
URL Tables

URL tables can be used to fetch a list of IP addresses from a remote server. There are several IP lists available for free, most notably are the “Don’t Route Or Peer” lists from Spamhaus.

Note

The content of the file being fetched should contain one IPv[4|6] address per line, lines that start with a whitespace , colon (,), semicolon (;), pipe (|) or hash (#) will be ignored.
GeoIP

With GeoIP alias you can select one or more countries or whole continents to block or allow. Use the toggle all checkbox to select all countries within the given region.

    ../_images/firewall_geoip_alias.png 

To use GeoIP, you need to configure a source in the Firewall ‣ Aliases -> GeoIP settings tab, the most commonly used source is MaxMind, for which we have a how-to available : MaxMind GeoIP’s Setup

Note

When using the Business Edition, you can leave the Url` field empty so the firewall will download the database provided by us.

The configured url should point to a zip file containing the following csv files:
Title

Filename
	

Purpose
	

Format
	

Example

%prefix%-locations-en.csv
	

maps geo locations to iso countries
	

geoname_id,,,,country_iso_code
	

1,,,,NL

%prefix%-IPv4.csv
	

IPv4 networks
	

network,geoname_id
	

2.21.241.0/28,1

%prefix%-IPv6.csv
	

IPv6 networks
	

network,geoname_id
	

2001:470:1f15:210::/64,1

The %prefix% can be used to identify the product and/or vendor, in MaxMind’s case these files are named GeoLite2-Country-Locations-en.csv, GeoLite2-Country-Blocks-IPv4.csv, GeoLite2-Country-Blocks-IPv6.csv for example.

Tip

Geo ip lists can be rather large, especially when using IPv6. When creating rules, always try to minimize the number of addresses needed in your selection. A selection of all countries in the world not being the Netherlands can usually be rewritten as only addresses from the Netherlands for example.

Tip

If the number of items is larger than the allocated alias size, you can assign more memory to aliases. Firewall ‣ Settings ‣ Advanced : Firewall Maximum Table Entries
Network group

Combine different network type aliases into one, this type of alias accepts other host type aliases (networks, hosts, …). Although nesting is possible with other alias types as well, this type only displays valid aliases easing administration, functionally a Networks type alias can do the same but uses a different presentation.
Dynamic IPv6 Host

An IPv6 Dynamic Host is used where the system is using a dynamic prefix on the LAN, a tracking interface. When the prefix changes, either due to the ISP changing the prefix at will or the prefix changes when the WAN connection is reset, any alias containing an address of a client such as a server on the LAN would no longer be valid.

For example, you obtain a prefix 2001:db8:2222:2800::/56. You have a /56 prefix and if the tracking id was set to 0 for your LAN, you would have an address range on your LAN of 2001:db8:2222:2800:: to 2001:db8:2222:2800:FFFF:FFFF:FFFF:FFFF.

You want to run a server on your LAN that is accessable from the WAN so you give it a static address of 2001:db8:2222:2800:1000:1000::1 and create a rule allowing traffic to access the server.

When your prefix changes, that static address is no longer valid, so you must use the Dynamic IPv6 Host to create an alias address for the firewall entry that automatically tracks the prefix and changes the rule.

The Dynamic Host Alias will always split on the /64 boundary, it will take the upper 64 bits from the interface you select and the lower 64 bits from the address you enter. It does not matter what size your prefix delegation is.

Create a new IPv6 Dynamic Host alias and enter only the suffix of the address, in this example, we will enter the lower 64 bits of the address, you would enter ::1000:1000:0000:1, note the ‘::’ at the start of the address, you MUST always start the address with a ‘::’. You do not need to enter a size after the address i.e. /128 as that is automatically assumed.

Select the interface you wish to use for the source of the uppper 64 bits, in this case we will select the LAN interface.

When the prefix changes, the alias address will then be updated in the firewall rules, let’s say your prefix changes to 2001:db8:2222:3200::/56 the rule updates and the entry for your server in the firewall would update automatically to be 2001:db8:2222:3200:1000:1000::1

Let’s take another example, you have a /48 prefix delegation, you have two LAN interfaces and a server on each. You would need to create two separate Dynamic IPv6 Host entries, one for each LAN. For simplicities sake we will use the same address for each server on each interface, you would enter ::aaaa:bbbb:cccc:0001 as the address.

Upper 64 bits, taken from LAN 1 Interface
	

Lower 64 bits - Your server address

Server 1: 2a02:1234:5678:0000
	

aaaa:bbbb:cccc:0001

Server 1 GUA address is: 2a02:1234:5678:0000:aaaa:bbbb:cccc:0001

Upper 64 bits, taken from LAN 2 Interface
	

Lower 64 bits - Your server address

Server 2: 2a02:1234:5678:0001
	

aaaa:bbbb:cccc:0001

Server 2 GUA address is: 2a02:1234:5678:0001:aaaa:bbbb:cccc:0001

The prefix changes, in this case we have a /48 prefix, so the new prefix is 2a02:1234:5679/48 our aliases would update to give us the following addresses:

LAN 1: Server 1 GUA address is:
	

2a02:1234:5679:0000:aaaa:bbbb:cccc:0001

LAN 2: Server 2 GUA address is:
	

2a02:1234:5679:0001:aaaa:bbbb:cccc:0001

You may enter multiple addresses, for example if you have several servers on the same LAN segment, just add the suffix for each one. In the example below we have three servers.

    ../_images/alias_dynamic_ipv6_host.png 

BGP ASN

With this alias type you are able to select networks by their responsible parties. Using BGP parties announce the addresses they are responsible for to eachother. For example Cloudflare uses AS number 13335, Microsoft is known to use 8075.

More background and how addresses are assigned is explained on wikipedia
External

The contents for external alias types is not administered via our normal alias service and can be practical in scenarios where you want to push new entries from external programs. Such as specific lockout features or external tools feeding access control to your firewall.

In Firewall ‣ Diagnostics ‣ Aliases you can always inspect the current contents of the external alias and add or remove entries immediately.

Tip

When changing alias contents which are used on firewall rules with state tracking enabled, you might need to remove the specific state before the new rule turns active. (see Firewall ‣ Diagnostics ‣ States Dump )

Tip

Since external alias types won’t be touched by OPNsense, you can use pfctl directly in scripts to manage its contents. (e.g. pfctl -t MyAlias -T add 10.0.0.3 to add 10.0.0.3 to MyAlias)
OpenVPN group

This alias type offers the possibility to build firewall policies for logged in OpenVPN users by the group they belong to as configured in System ‣ Access ‣ Groups.

The current users that are logged into OpenVPN can be inspected via VPN ‣ OpenVPN ‣ Connection Status, the alias just follows this information and flushes the attached addresses to the item in question.

For example, when a user named fred which is a member of group remote_users logs into OpenVPN and received a tunnel address of 10.10.10.2, the alias containing “remote_users” would include this address as well.

Note

For this mechanism to work, the common-name of the user certificate must match the username exactly, which is the case by default if the certificate has been created from the user manager.

Tip

When using LDAP (Active directory), you can synchronise group membership to avoid double administration in OPNsense.
Internal (automatic)

Internal aliases are prefixed with __ so they are easy to identify and can’t overlap with any user defined ones. These aliases help you to determine what the content is for some internal concepts such as “LAN network”. Using the Firewall->Diagnostics->Aliases menu item you can inspect their contents at any time.
Using Aliases in Firewall Rules

Aliases can be used in firewall rules to ease administration of large lists. For instance we might need a list of remote IP addresses that should have access to certain services, when anything changes we only need to update the list.

Let’s create a simple alias to allow 3 remote IP addresses access to an ipsec server for a site to site tunnel connection:

    192.168.100.1

    192.168.200.2

    192.168.202.2

../_images/alias_remote_ipsec.png

We call our list remote_ipsec and update our firewall rules accordingly.
../_images/alias_firewall_rules.png

Note

The list icon identifies a rule with an alias.
Export / Import

The alias admin page (Firewall ‣ Aliases) contains a download and an upload button in the footer of the table, with this feature you can merge aliases into the configuration and download a json formatted list of all aliases in the system.

Since data is validated before insertion, it shouldn’t be possible to import defective data (if the import fails, a list of errors is presented).

Tip

When performing migrations, sometimes its easier to change multiple items at once in a text editor. This feature can easily be used to facilitate that, with limiting risk of a broken configuration (since items are validated equally as single item input would do).
Add new entries using our API

The endpoints from the alias_util can easily be used to push new entries into an alias (or remove existing ones). In case of an external alias these items won’t be persistent over reboots, which can be practical in some use-cases (large frequent changing lists for example).

The document “Use the API” contains the steps needed to create an api key and secret, next you can just call the same endpoint the user interface would.

Below you see how to add 10.0.0.2 to an alias named MyAlias using an insecure connection (self-signed cert) on the host opnsense.firewall with curl. The verbose option provides more details about the data exchanged between the two machines.

curl \
  --header "Content-Type: application/json" \
  --basic \
  --user "key:secret" \
  --request POST \
  --insecure \
  --verbose \
  --data  '{"address":"10.0.0.2"}' \
  https://opnsense.firewall/api/firewall/alias_util/add/MyAlias

Note

Adding aliases using /api/firewall/alias_util/add/ is only supported for Host, Network and External type aliases
Exclusions

Pf firewall tables support exceptions (or exclusion) of addresses. This feature can be used in one Alias or in combined (Network group type) Aliases. See (https://www.freebsd.org/doc/handbook/firewalls-pf.html 30.3.2.4).
Nesting

For host and network alias types nesting is possibility, this can simplify management a lot since single items can be named properly and grouped into sections for administration.

For example, we define 4 servers among 2 critical using different rulesets:

    server_a {10.0.1.1}

    server_b {10.0.1.2}

    server_c {10.0.1.100}

    server_d {10.0.1.200}

    critical_servers {server_a , server_b}

    other_servers {server_c , server_d}

    servers { critical_servers , other_servers}.

The alias servers will contain all 4 addresses after configuration.

There is also a possibility to combine different Aliases with Aliases, consisting of exclusions. For example, there is Alias “FireHOL” that use extensive externl drop-list and two Aliases that contains subnet and hosts exclusions. It is possible to create Network group (combined) Alias (“FireHOL_with_exclusions”):

    FireHOL {https://raw.githubusercontent.com/firehol/blocklist-ipsets/master/firehol_level1.netset}

    subnets_exclusions {!127.0.0.0/8, !0.0.0.0/8}

    hosts_exclusions {!8.8.8.8}

    FireHOL_with_exclusions {FireHOL, subnets_exclusions, hosts_exclusions}

FireHOL_with_exclusions Alias will contain all records from FireHOL Alias excluding addresses from exclusions Aliases.

It’s always good to check if an address is included in the Alias via Firewall ‣ Diagnostics ‣ pfTable
Spamhaus

The Spamhaus Don’t Route Or Peer Lists DROP (Don’t Route Or Peer) and DROPv6 are advisory “drop all traffic” lists, consisting of netblocks that are “hijacked” or leased by professional spam or cyber-crime operations (used for dissemination of malware, trojan downloaders, botnet controllers). The DROP and DROPv6 lists are a tiny subset of the SBL, designed for use by firewalls and routing equipment to filter out the malicious traffic from these netblocks.

Source : https://www.spamhaus.org/drop/

Downloads

        DROP list

        DROPv6 list

To setup the DROP and DROPv6 lists in combination with the firewall rules, read: Configure Spamhaus DROP


Categories

To ease maintenance of larger rulesets, OPNsense includes categories for the firewall. Each rule can contain one or more categories, which can be filtered on top of each firewall rule page.

New categories can be created from within the rule or you can use the category editor in Firewall -> Categories to manage them.

There aren’t a lot of properties available on a category, you can optionally set a color and when created from a firewall rule the item can have an “automatic” checkbox, in which case it will be removed automatically when unused.

[Interface] Groups

To simplify rulesets, you can combine interfaces into Interface Groups and add policies which will be applied to all interfaces in the group.

Since interface groups are processed before normal interfaces, you shouldn’t have issues with overlapping rules in the interface tabs itself. More details about processing order can be found here

Note

For multiwan setups be careful with groups, since groups are not bound to a specific interface, they will use the normal routing system to determine the next hop when applied on WAN type interfaces (reply-to is not used here).
Settings

Groups are actually pretty easy to setup and don’t require a lot of settings.

Name
	

The technical name of the group. Has some restrictions which also apply to the underlying operating system.

Description
	

A user friendly description, informational use only

Members
	

Member interfaces


Network Address Translation

Network Address Translation (abbreviated to NAT) is a way to separate external and internal networks (WANs and LANs), and to share an external IP between clients on the internal network. NAT can be used on IPv4 and IPv6. For IPv6, Network Prefix Translation is also available.

Most of the options below use three different addresses: the source, destination and redirect address. These addresses are used for the following:

Source
	

Where the traffic comes from. This can often be left on “any”.

Destination
	

Where the traffic is headed. For incoming traffic from outside, this is usually your external IP address.

Redirect
	

Where the traffic should be redirected.

Warning

    Network Address Translation should not be relied upon as a security measure.

    Disabling pf will also disable NAT.

Some terms explained

BINAT: NAT generally works in one direction. However, if you have networks of equal size, you can also use BINAT, which is bidirectional. This can simplify your set-up. If you don’t have networks of equal size, you can only use regular NAT.

NAT reflection: When a client on the internal network tries to access another client, but using the external IP instead of the internal one (which would the most logical), NAT reflection can rewrite this request so that it uses the internal IP, in order to avoid taking a detour and applying rules meant for actual outside traffic.

Tip

There is a how-to section explaining NAT Reflection in detail.

Note

The NAT rules generated with enabling NAT reflection only include networks directly connected to your Firewall. This means if you have a private network separated from your LAN you need to add this with a manual outbound NAT rule.

Pool options: When there are multiple IPs to choose from, this option will allow regulating which IP gets used. The default, Round Robin, will simply distribute packets to one server after the other. If you only have one external IP, this option has no effect.
Port forwarding

When multiple clients share an external IP address, any connection not initiated by one of the clients will not succeed since the firewall will not know where to send the traffic. This can be addressed by creating port forwarding rules. For example, for a web server behind the firewall to be accessible, ports 80 and 443 need to be redirected to it.

Port forwarding is also referred to as “Destination NAT” or “DNAT”.

In OPNsense, port forwarding can be set up by navigating to Firewall ‣ NAT ‣ Port Forward. Here, you will see an overview of port forwarding rules. New rules can be added by clicking Add in the upper right corner.

When adding a rule, the following fields are available:

Disabled
	

Disable this rule without removing it.

No RDR (NOT)
	

Do not create a redirect rule. Leave this disabled unless you know what you are doing.

Interface
	

Which interface this rule should apply to. Most of the time, this will be WAN.

TCP/IP version
	

IPv4, IPv6 or both.

Protocol
	

In typical scenarios, this will be TCP.

Source
	

Where the traffic comes from. Click “Advanced” to see the other source settings.

Source / Invert
	

Invert match in “Source” field.

Source port range
	

When applicable, the source port we should match on. This is usually random and almost never equal to the destination port range (and should usually be ‘any’).

Destination / Invert
	

Invert match in “Destination” field.

Destination
	

Where the traffic is headed.

Destination port range
	

Service port(s) the traffic is using

Redirect target IP
	

Where to redirect the traffic to.

Redirect target port
	

Which port to use (when using tcp and/or udp)

Pool Options
	

See “Some terms explained”. The default is to use Round robin.

Description
	

A description to easily find the rule in the overview.

Set local tag
	

Set a tag that other NAT rules and filters can check for.

Match local tag
	

Check for a tag set by another rule.

No XMLRPC sync
	

Prevent this rule from being synced to a backup host. (Checking this on the backup host has no effect.)

NAT reflection
	

See “Some terms explained”. Leave this on the default unless you have a good reason not to.

Filter rule association
	

Associate this with a regular firewall rule.
One-to-one

One-to-one NAT will, as the name implies, translate two IPs one-to-one, rather than one-to-many as is most common. In this respect, it is similar to what NPT does for IPv6.

In OPNsense, one-to-one NAT can be set up by navigating to Firewall ‣ NAT ‣ One-to-one. Here, you will see an overview of one-to-one rules. New rules can be added by clicking Add in the upper right corner.

When adding a rule, the following fields are available:

Disabled
	

Disable this rule without removing it.

Interface
	

Which interface this rule should apply to. Most of the time, this will be WAN.

Type
	

BINAT (default) or NAT. See “Some terms explained”.

External network
	

Starting address of external network, which should be used to translate addresses to/from.

Source / invert
	

Invert match in “Source” field.

Source
	

The internal network for this mapping, usually some RFC 1918 range

Destination / invert
	

Invert match in “Destination” field.

Destination
	

The destination network packages should match, when used to map external networks, this is usually any

Description
	

A description to easily find the rule in the overview.

NAT reflection
	

See “Some terms explained”. Leave this on the default unless you have a good reason not to.
Outbound

When a client on an internal network makes an outbound request, the gateway will have to change the source IP to the external IP of the gateway, since the outside server will not be able to send an answer back otherwise.

Outbound NAT is also referred to as “Source NAT” or “SNAT”.

If you only have one external IP, then you leave the Outbound NAT options on automatic. However, if you have multiple IP addresses, you might want to change the settings and add some custom rules.

The main settings for outbound are as follows:

Automatic outbound NAT rule generation
	

The default. Follows the behaviour described above, and is good for most scenarios.

Manual outbound NAT rule generation
	

No automatic rules are generated. They can be added manually.

Hybrid outbound NAT rule generation
	

Automatic rules are added, but additional manual rules can be added as well.

Disable outbound NAT rule generation
	

Disables outbound NAT. This is used for transparent bridges, for example.

New rules can be added by clicking Add in the upper right corner.

When adding a rule, the following fields are available:

Disabled
	

Disable this rule without removing it.

Do not NAT
	

Disable NAT for all traffic matching this rule. Leave this disabled unless you know what you are doing.

Interface
	

Which interface this rule should apply to. Most of the time, this will be WAN.

TCP/IP version
	

IPv4 or IPv6

Protocol
	

In typical scenarios, this will be TCP.

Source invert
	

Invert match in “Source” field.

Source
	

The source network to match

Source port
	

When applicable, the source port we should match on. This is usually random and almost never equal to the destination port range (and should usually be ‘any’).

Destination invert
	

Invert match in “Destination” field.

Destination
	

Destination network to match

Destination port
	

Service port the traffic is using

Translation / target
	

What to translate matching packets to.

Log
	

Put packets matching this rule in the logs. Use this sparingly to avoid overflowing the logs.

Translation / port
	

Which port to use on the target

Static-port
	

Prevents pf(4) from modifying the source port on TCP and UDP packets.

Pool options
	

See “Some terms explained”. The default is to use Round robin.

Set local tag
	

Set a tag that other NAT rules and filters can check for.

Match local tag
	

Check for a tag set by another rule.

No XMLRPC sync
	

Prevent this rule from being synced to a backup host. (Checking this on the backup host has no effect.)

Description
	

A description to easily find the rule in the overview.
API access

Partial API access, is available and described in more detail in the firewall api reference manual.
How-tos

    Reflection and Hairpin NAT


Reflection and Hairpin NAT

Index

    Reflection and Hairpin NAT

        Networks used in this How-To section

        NAT - Quick Overview

        Introduction to Reflection and Hairpin NAT

        Best Practice

        Start of the How-To Section:

            Method 1 - Creating manual Port-Forward NAT (DNAT), manual Outbound NAT (SNAT), and automatic firewall rules

            Method 2 - Creating Automatic Port-Forward NAT (DNAT), Manual Outbound NAT (SNAT), and Manual firewall rules

            Method 3 - Creating Automatic Port-Forward NAT (DNAT), Automatic Outbound NAT (SNAT), and Manual firewall rules

        One-to-One NAT Reflection

        Troubleshooting NAT Rules

Networks used in this How-To section

Interface
	

IPv4 Subnet
	

Hosts
	

Gateway

WAN
	

203.0.113.0/24
	

203.0.113.1 - OPNsense
	

203.0.113.254 - OPNsense

DMZ
	

172.16.1.0/24
	

172.16.1.1 - Webserver
	

172.16.1.254 - OPNsense

LAN
	

192.168.1.0/24
	

192.168.1.1 - Client
	

192.168.1.254 - OPNsense
NAT - Quick Overview

Because there are not enough available IPv4 addresses, a workaround called NAT (Network Address Translation) was implemented into the IPv4 Standard. It basically enables a router like the OPNsense to translate IPv4 addresses to other IPv4 addresses. Most of the time it is used to translate the limited external IPv4 address space to the shared internal IPv4 address space (RFC 1918, 192.168.0.0/16 - 172.16.0.0/12 - 10.0.0.0/8) and vice versa.

Note

SNAT - Source Network Address Translation

        Changes the source IP of a packet

        Firewall –> NAT –> Outbound using the option Translation / target in a rule

DNAT - Destination Network Address Translation

        Changes the destination IP of a packet

        Firewall –> NAT –> Port Forward using the option Redirect target IP in a rule

PAT - Port Address Translation

        Changes the destination port of a packet

        Firewall –> NAT –> Port Forward using the option Redirect target port in a rule

If you create a DNAT rule, you enable all clients in the WAN access to an internal IPv4 address. The OPNsense acts like a translator, translating IPv4 addresses between client and server. The OPNsense writes all translations into a file called the NAT table. It knows exactly how traffic should flow back and forth with the translations in place.

Warning

NAT is not a security feature. It only acts as a translator. If you want security, you need firewall rules in addition.
Introduction to Reflection and Hairpin NAT

For example, you have a Webserver example.com with the internal IP 172.16.1.1 in your DMZ. It has a public DNS Record of example.com in A 203.0.113.1.

Your internal client 192.168.1.1 can’t reach the Webserver if it resolves the DNS A-Record 203.0.113.1. When the OPNsense receives the packet from the client 192.168.1.1 with the destination IP 203.0.113.1, it chooses itself as the target, and not 172.16.1.1. That’s because the external IPv4 address 203.0.113.1 is mapped to the WAN interface of the OPNsense.

That’s where Reflection NAT comes into play. It creates NAT rules which help your internal client 192.168.1.1 to communicate with your webserver 203.0.113.1, by using the OPNsense as the “translator” to the actual destination 172.16.1.1.

Attention

You should choose your preferred Reflection NAT method from the three possible choices presented here. They’re exclusive to each other, picking one method and sticking to it will prevent mistakes.

    Method 1 - Creating manual Port-Forward NAT (DNAT), manual Outbound NAT (SNAT), and automatic firewall rules

    Method 2 - Creating automatic Port-Forward NAT (DNAT), manual Outbound NAT (SNAT), and manual firewall rules

    Method 3 - Creating automatic Port-Forward NAT (DNAT), automatic Outbound NAT (SNAT), and manual firewall rules

Note

    Reflection NAT: The client and the server are in different subnets (layer 2 broadcast domains) and the OPNsense routes traffic between them. They can’t communicate directly by resolving ARP requests. You only need DNAT.

    Hairpin NAT: The client and the server are in the same subnet (layer 2 broadcast domain). They can communicate directly with each other by resolving ARP requests. You need SNAT and DNAT.

Note

When using IPsec, by default NAT only matches on policy based VPN. NAT on VTI (Virtual Tunnel Interfaces) won’t match unless some tunables are set. These tunables change the behavior of firewall filter and NAT on if_enc and if_ipsec interfaces. You can read more about the tunables in IPsec VTI - Route based setup
Best Practice

The best way to do Reflection NAT in the OPNsense is not to use the legacy Reflection options in (Advanced) Settings. Creating the NAT rules manually with Method 1 prevents unwanted traffic and makes auditing easy. There will be no hidden rules. All rules will be perfectly visible in the GUI and .xml config exports.
Start of the How-To Section:

The goal is to access the Webserver 172.16.1.1 on port 443 with it’s external IP 203.0.113.1 from a client in WAN, LAN and DMZ.
Method 1 - Creating manual Port-Forward NAT (DNAT), manual Outbound NAT (SNAT), and automatic firewall rules

Go to Firewall ‣ Settings ‣ Advanced

    Disable Reflection for port forwards, Reflection for 1:1 and Automatic outbound NAT for Reflection

Go to Firewall ‣ NAT ‣ Port Forward

    Select + to create a new Port Forward rule.

    Interface:
    	

    Select WAN, DMZ and LAN - Select all interfaces in which clients are that should access the webserver. This will create a linked Firewall rule in Firewall ‣ Rules ‣ Floating which allows the traffic.

    Protocol:
    	

    Select TCP

    Source:
    	

    Select Any

    Source port range:
    	

    Select Any

    Destination:
    	

    Input 203.0.113.1 - It’s the external IPv4 address of the webserver.

    Destination port range:
    	

    Input 443 - Or select the alias HTTPS

    Redirect target IP:
    	

    Input 172.16.1.1 - It’s the Webserver’s internal IPv4 address in the DMZ.

    Redirect target port:
    	

    Input 443 - Or select the alias HTTPS

    Description:
    	

    Input Reflection NAT Rule Webserver 443 - Add a description because the linked Filter rule association will use that as its name and the Firewall ‣ Rules ‣ Floating rule will have it in the description.

    NAT reflection:
    	

    Use system default

    Filter rule association:
    	

    Add associated filter rule

Tip

Reading the DNAT rule like a sentence makes it clearer:

If a packet is received by the OPNsense on any of the interfaces WAN, DMZ and LAN with protocol TCP from the source IP ANY and the source port range ANY to destination IP 203.0.113.1 and destination port 443 –> rewrite the destination IP to 172.16.1.1 and the destination port to 443.

Note

Due to “Add associated filter rule”, the added linked firewall rule in Firewall ‣ Rules ‣ Floating will allow traffic to the destination IP 172.16.1.1 because NAT rules match before Firewall rules. That means the firewall receives the packet and the NAT rule converts the destination from 203.0.113.1 to 172.16.1.1 first, before passing the packet to the firewall filter. You could also set “Filter rule association: Pass”, but then the resulting firewall rule would be invisible.

Note

In some setups (e.g. an external IP address is bound on an additional VPN interface) you need to set “Filter rule association: None” and create your own Firewall rules. One of those firewall rules should match only on the VPN interface, and in “advanced features” of that rule “reply-to” should be your VPN interface. The other firewall rule (without “reply-to”) should match the remaining interfaces.

Attention

Now you have Reflection NAT. The traffic from the internal LAN client 192.168.1.1 and any WAN client reaches the Webserver. But there is a caveat - any DMZ client and the Webserver itself are still unable reach the external IP 203.0.113.1. For that you need Hairpin NAT, which involves an additional SNAT rule.

Go to Firewall ‣ NAT ‣ Outbound

    Select Hybrid outbound NAT rule generation and save. That way you can have manual outbound rules in conjunction with automatic IP-Masquerading rules. You could also choose Manual outbound NAT rule generation. Please make sure that you create your own IP-Masquerading rules with the manual outbound NAT enabled.

    Select + to create a new Outbound NAT rule.

    Interface:
    	

    Select DMZ - It’s the interface of the subnet the Webserver is in.

    Protocol:
    	

    Select TCP

    Source Address:
    	

    Select DMZ net - It’s the alias for the DMZ Network 172.16.1.0/24

    Source Port:
    	

    Select Any

    Destination Address:
    	

    Input 172.16.1.1 - It’s the Webserver’s internal IPv4 address in the DMZ.

    Destination Port:
    	

    Input 443 - Or select the alias HTTPS

    Translation/target:
    	

    Select DMZ address - It’s the alias for the OPNsense Interface IPv4 address 172.16.1.254 in the DMZ Network.

    Description:
    	

    Input Hairpin NAT Rule Webserver 443

Tip

Reading the SNAT rule like a sentence makes it clearer:

If a packet is received by the OPNsense on the interface DMZ with protocol TCP from the source net 172.16.1.0/24 and the source port ANY to destination IP 172.16.1.1 and destination port 443 –> rewrite the source ip to 172.16.1.254 and answer from the OPNsense DMZ interface.

Note

Now all DMZ clients (and the Webserver itself) can reach the Webserver with its external IP.

    You need this additional SNAT rule to avoid asymmetrical traffic between clients and servers in the same layer 2 broadcast domain. TCP traffic won’t work otherwise.

Repeat Method 1 until all additional servers are reachable.

If you encounter any issues, check Troubleshooting NAT Rules for a few tips.

Warning

The following methods are not adviced, but are still explained in order to prevent misconfigurations. There is more information in (Advanced) Settings.
Method 2 - Creating Automatic Port-Forward NAT (DNAT), Manual Outbound NAT (SNAT), and Manual firewall rules

Go to Firewall ‣ Settings ‣ Advanced

    Enable Reflection for port forwards to create automatic rules for all entries Firewall ‣ NAT ‣ Port Forward that have WAN as interface.

Go to Firewall ‣ NAT ‣ Port Forward

    Create the NAT rule as in Method 1 - Port Forward but change the following things:

        Make sure that your Port Forwarding rule specifies only WAN as interface.

Go to Firewall ‣ Rules ‣ Floating

    Action:
    	

    Select Pass

    Interface:
    	

    Select WAN, DMZ and LAN - Select all interfaces in which clients are that should access the webserver.

    Protocol:
    	

    Select TCP

    Source:
    	

    Select Any

    Destination:
    	

    Input 172.16.1.1 - It’s the Webserver’s internal IPv4 address in the DMZ. NAT matches before firewall.

    Destination port range:
    	

    Input 443 - Or select the alias HTTPS

    Description:
    	

    Input Reflection NAT Rule Webserver 443
Go to Firewall ‣ NAT ‣ Outbound

    Create the NAT rule as in Method 1 - Outbound

Method 3 - Creating Automatic Port-Forward NAT (DNAT), Automatic Outbound NAT (SNAT), and Manual firewall rules

Go to Firewall ‣ Settings ‣ Advanced

    Enable Reflection for port forwards to create automatic rules for all :menuselection: Firewall –> NAT –> Port Forward that have WAN as interface. Enable Automatic outbound NAT for Reflection to create automatic SNAT rules.
Go to Firewall ‣ NAT ‣ Port Forward

    Create the NAT rule as in Method 2 - Port Forward
Go to Firewall ‣ Rules ‣ Floating

    Create the floating firewall rule as Method 2 - Floating

One-to-One NAT Reflection

When Firewall ‣ Settings ‣ Advanced Reflection for 1:1 is activated, automatic Reflection NAT rules for all One-to-One NAT rules are generated.

If you want to create manual Reflection and Hairpin NAT rules, leave Reflection for 1:1 disabled and follow the steps in Method 1. The only change is not adding the WAN interface to the Port Forward rules you create. The resulting Port Forward and Outbound NAT rules are in addition to the existing One-to-One NAT rules.

If your Port Forward rule has 1 interface selected (e.g. LAN), the resulting Filter rule association: Add associated filter rule will appear in Firewall ‣ Rules ‣ LAN. If you have more than 1 interface selected, it will appear in Firewall –> Rules –> Floating.
Troubleshooting NAT Rules

Tip

    Open SSH shell:

    Display all loaded and active NAT rules:

    pfctl -s nat

    “rdr” means Firewall ‣ NAT ‣ Port Forward rules.

    “nat” means Firewall ‣ NAT ‣ Outbound rules.

    You can also check the rules in the GUI in Firewall ‣ Diagnostics ‣ Statistics

Tip

    Displays all NAT rules in the OPNsense debug:

    cat /tmp/rules.debug | grep -i nat

    If there are more rules here than in pfctl -s nat, it means you forgot to hit apply somewhere.

Tip

    Look at the default drops of the firewall live log in Firewall ‣ Log Files ‣ Live View

    Turn on logging of the NAT and Firewall rules you have created, and check if they match in Firewall ‣ Log Files ‣ Live View. NAT rules have the label “NAT” or “RDR”. Firewall rules have their description as label.

    In “Firewall ‣ Diagnostics ‣ Sessions you can check if there is a session between your internal client and your internal server, and which rule matches to it.

    Use tcpdump on the client, the opnsense and the server, and test if the traffic goes back and forth between the devices without any mistakes. Look for TCP SYN and SYN ACK. If there are only SYN then the connection isn’t established and there are mistakes in your rules.

NPTv6

Network Prefix Translation, shortened to NPTv6, is used to translate IPv6 addresses. A common usage for this is to translate global (“WAN”) IPs to local ones. In this regard, it is similar to NAT, although NPTv6 can only be used to map addresses one-to-one, unlike NAT which typically translates one external IP to several internal ones.

NPTv6 routes are listed at Firewall ‣ NAT ‣ NPTv6. New rules can be added by clicking Add in the upper right corner. A quick overview of the fields:

Disabled
	

Disables this rule without having to remove it.

Interface
	

Which interface this rule should apply to. Most of the time, this will be a WAN interface.

Internal IPv6 Prefix
	

The internal IPv6 prefix used in the LAN(s). This will replace the prefix of the destination address in inbound packets. The prefix size specified here will also be applied to the external prefix.

External IPv6 Prefix
	

The external IPv6 prefix. This will replace the prefix of the source address in outbound packets.

Category
	

The category this rule belongs to, can be used as a filter in the overview.

Description
	

A description to easily indentify the purpose of this rule in the overview.


Rules

OPNsense contains a stateful packet filter, which can be used to restrict or allow traffic from and/or to specific networks as well as influence how traffic should be forwarded (see also policy based routing in “Multi WAN”).

The rules section shows all policies that apply on your network, grouped by interface.
Overview

Our overview shows all the rules that apply to the selected interface (group) or floating section. For every rule some details are provided and when applicable you can perform actions, such as move, edit, copy, delete.
../_images/Firewall_overview.png

Below you will find some highlights about this screen.

    Interface name

        The name of the interface is part of the normal menu breadcrumb

    Category

        If categories are used in the rules, you can select which one you will show here.

    Toggle inspection

        You can toggle between inspection and rule view here, when in inspection mode, statistics of the rule are shown. (such as packet counters, number of active states, …)

    Show / hide automatic rules

        Some rules are automatically generated, you can toggle here to show the details. If a magnifying glass is shown you can also browse to its origin (The setting controlling this rule).

    Automatic rules

        The contents of the automatic rules

    User rules

        All user defined rules

The basics

Before creating rules, it’s good to know about some basics which apply to all rules.
States

By default rules are set to stateful (you can change this, but it has consequences), which means that the state of a connection is saved into a local dictionary which will be resolved when the next packet comes in. The consequence of this is that when a state exists, the firewall doesn’t need to process all its rules again to determine the action to apply, which has huge performance advantages.

The use of states can also improve security particularly in case of tcp type traffic, since packet sequence numbers and timestamps are also checked in order to pass traffic, it’s much harder to spoof traffic.

Note

When changing rules, sometimes its necessary to reset states to assure the new policies are used for existing traffic. You can do this in Firewall ‣ Diagnostics ‣ States.

Note

In order to keep states, the system need to reserve memory. By default 10% of the system memory is reserved for states, this can be configured in Firewall ‣ Settings ‣ Firewall Maximum States. (The help text shows the default number of states on your platform)

States can also be quite convenient to find the active top users on your firewall at any time, as of 21.7 we added an easy to use “session” browser for this purpose. You can find it under Firewall ‣ Diagnostics ‣ Sessions.
Action

Rules can be set to three different action types:

    Pass –> allow traffic

    Block –> deny traffic and don’t let the client know it has been dropped (which is usually advisable for untrusted networks)

    Reject –> deny traffic and let the client know about it. (only tcp and udp support rejecting packets, which in case of TCP means a RST is returned, for UDP ICMP UNREACHABLE is returned).

For internal networks it can be practical to use reject, so the client does not have to wait for a time-out when access is not allowed. When receiving packets from untrusted networks, you usually don’t want to communicate back if traffic is not allowed.
Processing order

Firewall rules are processed in sequence per section, first evaluating the Floating rules section followed by all rules which belong to interface groups and finally all interface rules.

Internal (automatic) rules are usually registered first.

Rules can either be set to quick or not set to quick, the default is to use quick. When set to quick, the rule is handled on “first match” basis, which means that the first rule matching the packet will take precedence over rules following in sequence.

When quick is not set, last match wins. This can be useful for rules which define standard behaviour. Our default deny rule uses this property for example (if no rule applies, drop traffic).

Note

Internally rules are registered using a priority, floating uses 200000, groups use 300000 and interface rules land on 400000 combined with the order in which they appear. Automatic rules are usually registered at a higher priority (lower number).

Warning

NAT rules are always processed before filter rules! So for example, if you define a NAT : port forwarding rules without a associated rule, i.e. Filter rule association set to Pass, this has the consequence, that no other rules will apply!

Tip

The interface should show all rules that are used, when in doubt, you can always inspect the raw output of the ruleset in /tmp/rules.debug
Rule sequence

The sequence in which the rules are displayed and processed can be customized per section:

    Select one or more rules using the checkbox on the left side of the rule.

    Use the arrow button in the action menu on the right side of a rule in order to move selected rules before the rule where the action button is pressed.

    Or you can use the arrow button on the top in the heading row to move the selected rules to the end.

Direction

Traffic can be matched on in[coming] or out[going] direction, our default is to filter on incoming direction. In which case you would set the policy on the interface where the traffic originates from.

For example, if you want to allow https traffic coming from any host on the internet, you would usually set a policy on the WAN interface allowing port 443 to the host in question.

Note

Traffic leaving the firewall is accepted by default (using a non-quick rule), when Disable force gateway in Firewall ‣ Settings ‣ Advanced is not checked, the connected gateway would be enforced as well.
Settings

Traffic that is flowing through your firewall can be allowed or denied using rules, which define policies. This section of the documentation describe the different settings, grouped by usage.
Descriptive settings

Some settings help to identify rules, without influencing traffic flow.

Category
	

The category this rule belongs to, can be used as a filter in the overview

Description
	

Descriptive text
Basic settings

Below are the settings most commonly used:

Action
	

The action to perform.

Disabled
	

Disable a rule without removing it, can be practical for testing purposes and to support easy enablement of less frequently used policies.

Interface
	

Interface[s] this rule applies on. You can easily copy rules between interfaces and change this field to the new target interface. (remember to check the order before applying)

TCP/IP Version
	

Does this rule apply on IPv4, IPv6 or both.

Protocol
	

Protocol to use, most common are TCP and UDP

Source
	

Source network or address, when combining IPv4 and IPv6 in one rule, you can use aliases which contain both address families.

Source / Invert
	

Invert source selection (for example not 192.168.0.0/24)

Destination
	

Destination network or address, like source you can use aliases here as well.

Destination / Invert
	

When the filter should be inverted, you can mark this checkbox

Destination port range
	

For TCP and/or UDP you can select a service by name (http, https) or number (range), you can also use aliases here to simplify management.

Log
	

Create a log entry when this rule applies, you can use Firewall ‣ Log Files ‣ Live View to monitor if your rule applies.

Tip

The use of descriptive names help identify traffic in the live log view easily.

Tip
With the use of the eye button in the right top corner of the screen you can find statistics about the rule in question (number of evaluations, number of active states and traffic counters).
Less commonly used

Some settings are usually best left default, but can also be set in the normal rule configuration.

Source port range
	

In case of TCP and/or UDP, you can also filter on the source port (range) that is used by the client. Since in most cases you can’t influence the source port, this setting is usually kept default (any).

Quick
	

If a packet matches a rule specifying quick, the first matching rule wins. When not set to quick the last matching rule wins. When not sure, best use quick rules and interpret the ruleset from top to bottom.

Direction
	

Direction of the traffic, see also Direction.
High Availability

The following options are specifically used for HA setups.

No XMLRPC Sync
	

Disable configuration sync for this rule, when Firewall Rules sync is enabled in System ‣ High Availability ‣ Settings

State Type / NO pfsync
	

Prevent states created by this rule to be synced to the other node
Schedule

Rules can also be scheduled to be active at specific days or time ranges, you can create schedules in Firewall ‣ Advanced ‣ Schedules and select one in the rule.
Policy based routing

This feature can be used to forward traffic to another gateway based on more fine grained filters than static routes could (OSI layer 4 verses OSI layer 3) and can be used to build multi-wan scenario’s using gateway groups.

More information about Multi-Wan can be found in the “Multi WAN” chapter.

Gateway
	

When a gateway is specified, packets will use policy based routing using the specified gateway or gateway group. Usually this option is set on the receiving interface (LAN for example), which then chooses the gateway specified here. (This ignores default routing rules). Only packets flowing in the same direction of the rule are affected by this parameter, the opposite direction (replies) are not affected by this option.

reply-to
	

By default traffic is always send to the connected gateway on the interface. If for some reason you don’t want to force traffic to that gateway, you can disable this behaviour or enforce an alternative target here.

Note

When using policy based routing, don’t forget to exclude local traffic which shouldn’t be forwarded. You can do so by creating a rule with a higher priority, using a default gateway.

Tip

In our experience the packet capture function (Interfaces ‣ Diagnostics ‣ Packet capture) can be a valuable tool to inspect if traffic is really heading the direction you would expect it to go, just choose a host to monitor and try to exchange some packets. When selecting all interfaces, it’s easy to see where traffic headed.
Connection limits

The advanced options contains some settings to limit the use of a rule or specify specific timeouts for the it. Most generic (default) settings for these options can be found under Firewall ‣ Settings ‣ Advanced

Max states
	

Limits the number of concurrent states the rule may create. When this limit is reached, further packets that would create state will not match this rule until existing states time out.

Max source nodes
	

Limits the maximum number of source addresses which can simultaneously have state table entries.

Max established
	

Limits the maximum number of simultaneous TCP connections which have completed the 3-way handshake that a single host can make.

Max source states
	

Limits the maximum number of simultaneous state entries that a single source address can create with this rule.

Max new connections
	

Limit the rate of new connections over a time interval. The connection rate is an approximation calculated as a moving average. (number of connections / seconds) Only applies on TCP connections

State timeout
	

State Timeout in seconds (applies to TCP only)
Advanced

Some less common used options are defined below.

Source OS
	

Operating systems can be fingerprinted based on some tcp fields from the originating connection. These fingerprints can be used as well to match traffic on. (more detailed information can be found in the pf.os man page)

allow options
	

By default the firewall blocks IPv4 packets with IP options or IPv6 packets with routing extension headers set. If you have an application that requires such packets (such as multicast or IGMP) you can enable this option.

TCP flags
	

If specific TCP flags need to be set or unset, you can specify those here.

Set priority
	

Packets matching this rule will be assigned a specific queueing priority. If the packet is transmitted on a VLAN interface, the queueing priority will be written as the priority code point in the 802.1Q VLAN header. If two priorities are given, packets which have a TOS of lowdelay and TCP ACKs with no data payload will be assigned to the second one.

Match priority
	

Only match packets which have the given queueing priority assigned.

Set local tag
	

Packets matching this rule will be tagged with the specified string. The tag acts as an internal marker that can be used to identify these packets later on. This can be used, for example, to provide trust between interfaces and to determine if packets have been processed by translation rules. Tags are “sticky”, meaning that the packet will be tagged even if the rule is not the last matching rule. Further matching rules can replace the tag with a new one but will not remove a previously applied tag. A packet is only ever assigned one tag at a time.

Match local tag
	

Match packets that are tagged earlier (using set local tag)

State Type
	

Influence the state tracking mechanism used, the following options are available. When in doubt, it’s usually best to preserve the default keep state

    Keep state ‣ is used for stateful connection tracking.

    Sloppy state ‣ works like keep state, but it does not check sequence numbers. Use it when the firewall does not see all packets.

    Synproxy state ‣ proxies incoming TCP connections to help protect servers from spoofed TCP SYN floods. This option includes the functionality of keep state and modulate state combined.

    None ‣ Do not use state mechanisms to keep track.

Troubleshooting

While building your ruleset things can go wrong, it’s always good to know where to look for signs of an issue. One of the most common mistakes is traffic doesn’t match the rule and/or the order of the rule doesn’t make sense for whatever reason.

With the use of the “inspect” button, one can easily see if a rule is being evaluated and traffic did pass using this rule. As of 21.7 it’s also possible to jump directly into the attached states to see if your host is in the list as expected.

Another valuable tool is the live log viewer, in order to use it, make sure to provide your rule with an easy to read description and enable the “log” option.

If your using source routing (policy based routing), debugging can sometimes get a bit more complicated. Since the normal system routing table may not apply, it helps to know which flow the traffic actually followed. The packet capture is a useful tool in that case.

Common issues in this area include return traffic using a different interface than the one it came into, since traffic follows the normal routing table on it’s way out (reply-to issue), or traffic leaving the wrong interface due to overselection (matching internal traffic and forcing a gateway).

Inspecting used netmasks is also a good idea, intending to match a host but providing a subnet is a mistake easily made (e.g. 192.168.1.1/32 vs 192.168.1.1/24 is in reality all of 192.168.1.x).

Last but not least, remember rules are matched in order and the default (inbound) policy is block if nothing else is specified, since we match traffic on inbound, make sure to add rules where traffic originates from (e.g. lan for traffic leaving your network, the return should normally be allowed by state).
API access

Partial API access is described in more detail in the firewall api reference manual.


Traffic Shaping

Traffic shaping (also known as “packet shaping”) is the control of computer network traffic in order to optimize or guarantee performance, lower latency, and/or increase usable bandwidth by delaying packets that meet certain criteria. More specifically, traffic shaping is any action on a set of packets (often called a stream or a flow), which imposes additional delay on those packets such that they conform to some predetermined constraint (a contract or traffic profile).
../_images/traffic_shaping.png
Introduction

Traffic shaping within OPNsense is very flexible and is organized around pipes, queues and corresponding rules. The pipes define the allowed bandwidth, the queues can be used to set a weight within the pipe and finally the rules are used to apply the shaping to a certain package flow. The shaping rules are handled independently from the firewall rules and other settings.

OPNsense traffic shaping is a reliable solution to limit bandwidth or prioritize traffic and can be combined with other functions such as captive portal or high availability (CARP).

Bandwidth limitations can be defined based upon the interface(s), IP source & destination, direction of traffic (in/out) and port numbers (application).

Available bandwidth can be shared evenly over all users, this allows for optimum performance at all times.

Traffic can also be prioritized by adding queues and defining weights. Strictly speaking traffic is not really prioritized but applications with a higher weight can consume more bandwidth than others when the total available bandwidth is limited.

The traffic shaper implementation uses IPFW and dummynet to offer a modern, reliable solution with a low cpu footprint.
Dummynet & ipfw

Dummynet operates by first using the firewall to classify packets and divide them into flows, using any match pattern that can be used in ipfw rules. Depending on local policies, a flow can contain packets for a single TCP connection, or from/to a given host, or entire subnet, or a protocol type, etc.

Packets belonging to the same flow are then passed to either of two different objects, which implement the traffic regulation:

pipe

    A pipe emulates a link with given bandwidth, propagation delay, queue size and packet loss rate. Packets are queued in front of the pipe as they come out from the classifier, and then transferred to the pipe according to the pipe’s parameters.
queue

    A queue is an abstraction used to implement the WF2Q+ (Worstcase Fair Weighted Fair Queueing) policy, which is an efficient variant of the WFQ policy. The queue associates a weight and a reference pipe to each flow, and then all backlogged (i.e., with packets queued) flows linked to the same pipe share the pipe’s bandwidth proportionally to their weights. Note that weights are not priorities; a flow with a lower weight is still guaranteed to get its fraction of the bandwidth even if a flow with a higher weight is permanently backlogged.

In practice, pipes can be used to set hard limits to the bandwidth that a flow can use, whereas queues can be used to determine how different flow share the available bandwidth.

The shaping rules can be defined in the rules section of the traffic shaper.
Status / statistics

To check if your shaper is acting like intended, you can use the status page (Firewall -> Shaper -> Status).

This component will show a breakdown of configured pipes, queues and rules showing the amount of traffic passed through it since the last restart of the service including the timestamp when that happened.

If flows are active, you can show their details using the “Show active flows” checkbox, do remember to refresh your view after changing these settings.

The rules are not shown by default, you can use the “Show rules” checkbox to enabled those, this option can help you identifying misconfigurations more easily, since the underlaying technology (ipfw) keeps track of data on a per rule basis.

Tip

Make sure to use easy to find descriptions, these will ease debugging when traffic isn’t being handled as expected.
Configuration / How-tos

    Reserve dedicated bandwidth
    Share internet bandwidth amongst users evenly
    Limit maximum internet bandwidth users can consume
    Prioritize Applications (Weighted) using Queues
    Multi Interface shaping for a GuestNet
    Fighting Bufferbloat with FQ_CoDel


Reserve dedicated bandwidth

Reserve dedicated bandwidth for a realtime traffic such as (hosted) Voice Over IP (VOIP) server.

In this scenario we will create a pipe dedicated for traffic going to and coming from our realtime application. For the sample we presume a SIP trunk or hosted Voice Over IP (VOIP) server.

For this example we presume a requirement of 4 uncompressed voice channels of 64 kbps, resulting in a total bandwidth of 256 kbps. The internet connection in this example has 10 Mbps Download and 1 Mbps Upload.

Shaping hosted VOIP / SIP trunk sample

To start go to Firewall ‣ Shaper ‣ Pipes.
Step 1 - Create Upload and Download Pipes

On the Pipes tab click the + button in the lower right corner. An empty Edit Pipe screen will popup.

Create Pipe For Upload (To our VOIP Server)

enabled
	

Checked
	

Check to enable the pipe

bandwidth
	

256
	

Numeric value of the desired bandwidth

bandwidth Metric
	

Kbit/s
	

Metric to use with the numeric value

mask
	

(Empty)
	

Used for auto queueing, empty for our sample

description
	

PipeUp-256kbps
	

Free field, enter something descriptive

Create Pipe For Upload (Other Traffic = 1024 kbps - 256 kbps = 768 kbps)

enabled
	

Checked
	

Check to enable the pipe

bandwidth
	

768
	

Numeric value of the desired bandwidth

bandwidth Metric
	

Kbit/s
	

Metric to use with the numeric value

mask
	

(Empty)
	

Used for auto queueing, empty for our sample

description
	

PipeUp-768kbps
	

Free field, enter something descriptive

Create Pipe For Download (From our VOIP Server)

enabled
	

Checked
	

Check to enable the pipe

bandwidth
	

256
	

Numeric value of the desired bandwidth

bandwidth Metric
	

Kbit/s
	

Metric to use with the numeric value

mask
	

(Empty)
	

Used for auto queueing, empty for our sample

description
	

PipeDown-256kbps
	

Free field, enter something descriptive

Create Pipe For Download (Other Traffic = 10240 kbps - 256 kbps = 9984 kbps )

enabled
	

Checked
	

Check to enable the pipe

bandwidth
	

9984
	

Numeric value of the desired bandwidth

bandwidth Metric
	

Kbit/s
	

Metric to use with the numeric value

mask
	

(Empty)
	

Used for auto queueing, empty for our sample

description
	

PipeDown-9984kbps
	

Free field, enter something descriptive
Step 2 - Create Rules

On the Rules tab click the + button in the lower right corner. An empty Edit rule screen will popup.

Create a rule for traffic directed towards the VOIP Server (Upload).

sequence
	

11
	

Auto generated number, overwrite only when needed

interface
	

WAN
	

Select the interface connected to the internet

proto
	

ip
	

Select the protocol, IP in our example

source
	

any
	

The source IP to shape, leave on any

src-port
	

any
	

The source port to shape, leave on any

destination
	

172.10.2.1
	

The IP address of our VOIP server

dst-port
	

any
	

Use any of the destination port if static

target
	

PipeUP-256kbps
	

Select the Upload 256 kbps Pipe

description
	

ShapeVOIPUpload
	

Enter a descriptive name

Create a rule for traffic coming from the VOIP Server (Download).

sequence
	

21
	

Auto generated number, overwrite only when needed

interface
	

WAN
	

Select the interface connected to the internet

proto
	

ip
	

Select the protocol, IP in our example

source
	

172.10.2.1
	

The IP address of our VOIP server

src-port
	

any
	

The source port to shape, leave on any

destination
	

any
	

The destination IP to shape, leave on any

dst-port
	

any
	

The destination port to shape, leave on any

target
	

PipeDown256kbps
	

Select the Download 256 kbps Pipe

description
	

ShapeVOIPDown
	

Enter a descriptive name

Create a rule for all other internet upload traffic

sequence
	

31
	

Auto generated number, overwrite only when needed

interface
	

WAN
	

Select the interface connected to the internet

proto
	

ip
	

Select the protocol, IP in our example

source
	

192.168.1.0/24
	

The source IPs to shape, our LAN network

src-port
	

any
	

The source port to shape, leave on any

destination
	

any
	

the destination address, leave in any

dst-port
	

any
	

Use any of the destination port if static

target
	

PipeUp-768kbps
	

Select the Upload 768 kbps Pipe

description
	

ShapeUpload
	

Enter a descriptive name

Create a rule for all other internet download traffic

sequence
	

41
	

Auto generated number, overwrite only when needed

interface
	

WAN
	

Select the interface connected to the internet

proto
	

ip
	

Select the protocol, IP in our example

source
	

any
	

The source IP to shape, leave on any

src-port
	

any
	

The source port to shape, leave on any

destination
	

192.168.1.0/24
	

The destination IPs to shape, our LAN network

dst-port
	

any
	

The destination port to shape, leave on any

target
	

PipeDown-9984kbps
	

Select the Download 256Kbps Pipe

description
	

ShapeDown
	

Enter a descriptive name

Note

Be aware of the sequence! It is important to make sure the right traffic is passed to the right pipe.

Now press apply to activate the traffic shaping rules.

Screenshot Rules
../../_images/shaping_rules_s1.png


Share internet bandwidth amongst users evenly

For this example we presume an internet connection of 10 Mbps Download and 1 Mbps Upload that we want to share evenly between all users.

Shaping bandwidth evenly sample

To start go to Firewall ‣ Shaper ‣ Pipes.
Step 1 - Create Upload and Download Pipes

On the Pipes tab click the + button in the lower right corner. An empty Edit Pipe screen will popup.

Create Pipe For Upload

enabled
	

Checked
	

Check to enable the pipe

bandwidth
	

1
	

Numeric value of the desired bandwidth

bandwidth Metric
	

Mbit/s
	

Metric to use with the numeric value

mask
	

empty
	

Select destination to share the bandwidth

description
	

PipeUp-1Mbps
	

Free field, enter something descriptive

Create Pipe For Download

enabled
	

Checked
	

Check to enable the pipe

bandwidth
	

10
	

Numeric value of the desired bandwidth

bandwidth Metric
	

Mbit/s
	

Metric to use with the numeric value

mask
	

empty
	

Select destination to share the bandwidth

description
	

PipeDown-10Mbps
	

Free field, enter something descriptive
Step 2 - Create a Queues

On the Queues tab click the + button in the lower right corner. An empty Edit queue screen will popup.

Create Queue for Upload

enabled
	

Checked
	

Check to enable the pipe

pipe
	

PipeUp-1Mbps
	

Select our Pipe

weight
	

100
	

Weight to use with the numeric value

mask
	

source
	

Every source creates a match

description
	

QueueUp-1Mbps
	

Free field, enter something descriptive

Create Queue for Download

enabled
	

Checked
	

Check to enable the pipe

pipe
	

PipeDown-10Mbps
	

Select our Pipe

weight
	

100
	

Weight to use with the numeric value

mask
	

destination
	

Every source creates a match

description
	

QueueDown-10Mbps
	

Free field, enter something descriptive
Step 3 - Create Rules

On the Rules tab click the + button in the lower right corner. An empty Edit rule screen will popup.

Create a rule for traffic directed towards the internet (Upload).

sequence
	

11
	

Auto generated number, overwrite only when needed

interface
	

WAN
	

Select the interface connected to the internet

proto
	

ip
	

Select the protocol, IP in our example

source
	

192.168.1.0/24
	

The source IP to shape, select the LAN network

src-port
	

any
	

The source port to shape, leave on any

destination
	

any
	

The destination to shape, leave on any

dst-port
	

any
	

Use any of the destination port if static

target
	

QueueUp-1Mbps
	

Select the Upload 1Mbps Queue

description
	

ShapeUpload
	

Enter a descriptive name

Create a rule for traffic coming from the internet (Download).

sequence
	

21
	

Auto generated number, overwrite only when needed

interface
	

WAN
	

Select the interface connected to the internet

proto
	

ip
	

Select the protocol, IP in our example

source
	

any
	

The source address, leave on any

src-port
	

any
	

The source port to shape, leave on any

destination
	

192.168.1.0/24
	

The destination IP to shape, select LAN network

dst-port
	

any
	

The destination port to shape, leave on any

target
	

QueueDown-10Mbps
	

Select the Download 10 Mbps Queue

description
	

ShapeDownload
	

Enter a descriptive name

Now press apply to activate the traffic shaping rules.

Screenshot Rules
../../_images/shaping_rules_s2.png


Limit maximum internet bandwidth users can consume

For this example we will divide the internet Download traffic between the connected users in such manner that each user will receive up to a maximum of 1 Mbps.

Simple network diagram

To start go to Firewall ‣ Shaper ‣ Pipes.
Step 1 - Create download and upload pipes

On the Pipes tab click the + button in the lower right corner. An empty Edit Pipe screen will popup.

Create Pipe For Download

enabled
	

Checked
	

Check to enable the pipe

bandwidth
	

1
	

Numeric value of the desired bandwidth

bandwidth Metric
	

Mbit/s
	

Metric to use with the numeric value

mask
	

destination
	

Dynamic pipe per downloading client

description
	

PipeDown-1Mbps
	

Free field, enter something descriptive

Create Pipe For Upload

enabled
	

Checked
	

Check to enable the pipe

bandwidth
	

1
	

Numeric value of the desired bandwidth

bandwidth Metric
	

Mbit/s
	

Metric to use with the numeric value

mask
	

source
	

Dynamic pipe per uploading client

description
	

PipeUp-1Mbps
	

Free field, enter something descriptive

Note

Always create separate pipes for download and upload limiting to avoid undefined behaviour when mixing bidirectional traffic in a single pipe.
Step 2 - Create rules

On the Rules tab click the + button in the lower right corner. An empty Edit rule screen will popup.

Create a rule for traffic coming from the internet (download).

sequence
	

21
	

Auto generated number, overwrite only when needed

interface
	

WAN
	

Select the interface connected to the internet

proto
	

ip
	

Select the protocol, IP in our example

source
	

any
	

The source address, leave on any

src-port
	

any
	

The source port to shape, leave on any

destination
	

192.168.1.0/24
	

The destination IP to shape, select LAN network

dst-port
	

any
	

The destination port to shape, leave on any

target
	

PipeDown-1Mbps
	

Select the 1 Mbps download pipe

description
	

ShapeDownload
	

Enter a descriptive name

Create a rule for traffic going to the internet (upload).

sequence
	

22
	

Auto generated number, overwrite only when needed

interface
	

WAN
	

Select the interface connected to the internet

proto
	

ip
	

Select the protocol, IP in our example

source
	

192.168.1.0/24
	

The source IP to shape, select LAN network

src-port
	

any
	

The source port to shape, leave on any

destination
	

any
	

The destination address, leave on any

dst-port
	

any
	

The destination port to shape, leave on any

target
	

PipeUp-1Mbps
	

Select the 1 Mbps upload pipe

description
	

ShapeUpload
	

Enter a descriptive name

Note

If you want to limit traffic for a specific IP addresses then just enter the IP addresses in the destination field instead of the full LAN network range.

Now press apply to activate the traffic shaping rules.

Screenshot Rules
../../_images/shaping_rules_s3.png
Prioritize using Queues

By utilizing queues we can influence the bandwidth within a pipe and give certain applications more bandwidth than others based on a weighted algorithm.

The idea is simple: Let presume we have a pipe of 10 Mbps and 2 applications for instance smtp (email) and http(s). The http(s) traffic will get a weight of 1 and the smtp traffic a weight of 9, then when all capacity of our pipe is in use the email traffic will get 9x more bandwidth than our http(s) traffic, resulting in 1 Mbps for http(s) and 9 Mbps for smtp.

For our example we only look at download traffic, but the exact same can be done for the upload traffic.

Application
	

Weight
	

Minimum Bandwidth

SMTP (port 25)
	

9
	

9 Mbps

HTTP (80)
	

1
	

1 Mbps

HTTPS (443)

To start go to Firewall ‣ Shaper ‣ Pipes.
Step 1 - Create Download Pipe

On the Pipes tab click the + button in the lower right corner. An empty Edit Pipe screen will popup.

Create Pipe For Download (10 Mbps)

enabled
	

Checked
	

Check to enable the pipe

bandwidth
	

10
	

Numeric value of the desired bandwidth

bandwidth Metric
	

Mbit/s
	

Metric to use with the numeric value

mask
	

(empty)
	

Leave empty

description
	

PipeDown-10Mbps
	

Free field, enter something descriptive
Step 2 - Create Queues

On the Queues tab click the + button in the lower right corner. An empty Edit queue screen will popup.

Create Queue for SMTP

enabled
	

Checked
	

Check to enable the pipe

pipe
	

PipeDown-10Mbps
	

Select our Pipe

weight
	

9
	

Weight to use with the numeric value

mask
	

(empty)
	

Leave empty

description
	

Queue-SMTP
	

Free field, enter something descriptive

Create Queue for HTTP

enabled
	

Checked
	

Check to enable the pipe

pipe
	

PipeDown-10Mbps
	

Select our Pipe

weight
	

1
	

Weight to use with the numeric value

mask
	

(empty)
	

Leave empty

description
	

Queue-HTTP
	

Free field, enter something descriptive
Step 3 - Create Rules

On the Rules tab click the + button in the lower right corner. An empty Edit rule screen will popup.

Create a rule for smtp download traffic (email)

sequence
	

11
	

Auto generated number, overwrite only when needed

interface
	

WAN
	

Select the interface connected to the internet

proto
	

ip
	

Select the protocol, IP in our example

source
	

any
	

The source address, leave on any

src-port
	

smtp
	

The source port to shape, smtp or 25

destination
	

any
	

The destination IP to shape, leave on any

dst-port
	

any
	

The destination port to shape, leave on any

target
	

Queue-SMTP
	

Select the SMTP queue

description
	

ShapeSMTPDownload
	

Enter a descriptive name

Create a rule for HTTP download traffic

sequence
	

21
	

Auto generated number, overwrite only when needed

interface
	

WAN
	

Select the interface connected to the internet

proto
	

ip
	

Select the protocol, IP in our example

source
	

any
	

The source address, leave on any

src-port
	

http
	

The source port to shape, http or 80

destination
	

any
	

The destination IP to shape, leave on any

dst-port
	

any
	

The destination port to shape, leave on any

target
	

Queue-HTTP
	

Select the HTTP queue

description
	

ShapeHTTPDownload
	

Enter a descriptive name

Adding an extra rule for HTTPS traffic is simple as we can use the same HTTP queue if we like:

sequence
	

31
	

Auto generated number, overwrite only when needed

interface
	

WAN
	

Select the interface connected to the internet

proto
	

ip
	

Select the protocol, IP in our example

source
	

any
	

The source address, leave on any

src-port
	

https
	

The source port to shape, https or 443

destination
	

any
	

The destination IP to shape, leave on any

dst-port
	

any
	

The destination port to shape, leave on any

target
	

Queue-HTTP
	

Select the HTTP queue

description
	

ShapeHTTPSDownload
	

Enter a descriptive name

This way HTTP and HTTPS traffic will be treated the same (total max of 1 Mbps).

Now press apply to activate the traffic shaping rules.

Screenshot Rules
../../_images/shaping_rules_s4.png


Prioritize Applications (Weighted) using Queues

By utilizing queues we can influence the bandwidth within a pipe and give certain applications more bandwidth than others based on a weighted algorithm.

The idea is simple: Let presume we have a pipe of 10 Mbps and 2 applications for instance smtp (email) and http(s). The http(s) traffic will get a weight of 1 and the smtp traffic a weight of 9, then when all capacity of our pipe is in use the email traffic will get 9x more bandwidth than our http(s) traffic, resulting in 1 Mbps for http(s) and 9 Mbps for smtp.

For our example we only look at download traffic, but the exact same can be done for the upload traffic.

Application
	

Weight
	

Minimum Bandwidth

SMTP (port 25)
	

9
	

9 Mbps

HTTP (80)
	

1
	

1 Mbps

HTTPS (443)

To start go to Firewall ‣ Shaper ‣ Pipes.
Step 1 - Create Download Pipe

On the Pipes tab click the + button in the lower right corner. An empty Edit Pipe screen will popup.

Create Pipe For Download (10 Mbps)

enabled
	

Checked
	

Check to enable the pipe

bandwidth
	

10
	

Numeric value of the desired bandwidth

bandwidth Metric
	

Mbit/s
	

Metric to use with the numeric value

mask
	

(empty)
	

Leave empty

description
	

PipeDown-10Mbps
	

Free field, enter something descriptive
Step 2 - Create Queues

On the Queues tab click the + button in the lower right corner. An empty Edit queue screen will popup.

Create Queue for SMTP

enabled
	

Checked
	

Check to enable the pipe

pipe
	

PipeDown-10Mbps
	

Select our Pipe

weight
	

9
	

Weight to use with the numeric value

mask
	

(empty)
	

Leave empty

description
	

Queue-SMTP
	

Free field, enter something descriptive

Create Queue for HTTP

enabled
	

Checked
	

Check to enable the pipe

pipe
	

PipeDown-10Mbps
	

Select our Pipe

weight
	

1
	

Weight to use with the numeric value

mask
	

(empty)
	

Leave empty

description
	

Queue-HTTP
	

Free field, enter something descriptive
Step 3 - Create Rules

On the Rules tab click the + button in the lower right corner. An empty Edit rule screen will popup.

Create a rule for smtp download traffic (email)

sequence
	

11
	

Auto generated number, overwrite only when needed

interface
	

WAN
	

Select the interface connected to the internet

proto
	

ip
	

Select the protocol, IP in our example

source
	

any
	

The source address, leave on any

src-port
	

smtp
	

The source port to shape, smtp or 25

destination
	

any
	

The destination IP to shape, leave on any

dst-port
	

any
	

The destination port to shape, leave on any

target
	

Queue-SMTP
	

Select the SMTP queue

description
	

ShapeSMTPDownload
	

Enter a descriptive name

Create a rule for HTTP download traffic

sequence
	

21
	

Auto generated number, overwrite only when needed

interface
	

WAN
	

Select the interface connected to the internet

proto
	

ip
	

Select the protocol, IP in our example

source
	

any
	

The source address, leave on any

src-port
	

http
	

The source port to shape, http or 80

destination
	

any
	

The destination IP to shape, leave on any

dst-port
	

any
	

The destination port to shape, leave on any

target
	

Queue-HTTP
	

Select the HTTP queue

description
	

ShapeHTTPDownload
	

Enter a descriptive name

Adding an extra rule for HTTPS traffic is simple as we can use the same HTTP queue if we like:

sequence
	

31
	

Auto generated number, overwrite only when needed

interface
	

WAN
	

Select the interface connected to the internet

proto
	

ip
	

Select the protocol, IP in our example

source
	

any
	

The source address, leave on any

src-port
	

https
	

The source port to shape, https or 443

destination
	

any
	

The destination IP to shape, leave on any

dst-port
	

any
	

The destination port to shape, leave on any

target
	

Queue-HTTP
	

Select the HTTP queue

description
	

ShapeHTTPSDownload
	

Enter a descriptive name

This way HTTP and HTTPS traffic will be treated the same (total max of 1 Mbps).

Now press apply to activate the traffic shaping rules.

Screenshot Rules
../../_images/shaping_rules_s4.png


Multi Interface shaping for a GuestNet

One of the options with OPNsense’s traffic shaper is its ability to add shaping rules based upon two interfaces. This option allows you to shape traffic differently based on the direction the traffic is moving between interfaces.

For this example we will use this functionality to share a symmetric 10 Mbps internet connection between a primary LAN network and a Guest Network.

The LAN network will not be limited, traffic from users on our Guest Network will be limited to a total of 2 Mbps Download and 1 Mbps Upload.

Simple network diagram
Step 1 - Create Upload and Download Pipes

On the Pipes tab click the + button in the lower right corner. An empty Edit Pipe screen will popup.

Create Pipe For Upload (GuestNet - em2)

enabled
	

Checked
	

Check to enable the pipe

bandwidth
	

1
	

Numeric value of the desired bandwidth

bandwidth Metric
	

Mbit/s
	

Metric to use with the numeric value

mask
	

(Empty)
	

Leave empty

description
	

PipeUp-1Mbps
	

Free field, enter something descriptive

Create Pipe For Download (GuestNet - em2)

enabled
	

Checked
	

Check to enable the pipe

bandwidth
	

2
	

Numeric value of the desired bandwidth

bandwidth Metric
	

Mbit/s
	

Metric to use with the numeric value

mask
	

(Empty)
	

Leave empty

description
	

PipeDown-2Mbps
	

Free field, enter something descriptive
Step 2 - Create Rules

On the Rules tab click the + button in the lower right corner. An empty Edit rule screen will popup.

Important - Before you continue!

    First change the mode to advanced, see the toggle in the left top corner of the popup dialog. One click should shift it from red (disabled) to green (enabled).

Create a rule for the download traffic

sequence
	

11
	

Auto generated number, overwrite only when needed

interface
	

WAN
	

Select the interface connected to the internet

interface2
	

GuestNet
	

Select the interface that matches your GuestNet

proto
	

ip
	

Select the protocol, IP in our example

source
	

any
	

The source address, leave on any

src-port
	

any
	

The source port to shape, leave on any

destination
	

any
	

The destination IP to shape, leave on any

dst-port
	

any
	

The destination port to shape, leave on any

direction
	

in
	

Match incoming packages (download)

target
	

PipeDown-2Mbps
	

Select the Download pipe

description
	

GuestNetDownload
	

Enter a descriptive name

Create a rule for the upload traffic

sequence
	

21
	

Auto generated number, overwrite only when needed

interface
	

WAN
	

Select the interface connected to the internet

interface2
	

GuestNet
	

Select the interface that matches your GuestNet

proto
	

ip
	

Select the protocol, IP in our example

source
	

any
	

The source address, leave on any

src-port
	

any
	

The source port to shape, leave on any

destination
	

any
	

The destination IP to shape, leave on any

dst-port
	

any
	

The destination port to shape, leave on any

direction
	

out
	

Match outgoing packages (upload)

target
	

PipeUp-1Mbps
	

Select the Upload pipe

description
	

GuestNetUpload
	

Enter a descriptive name

Now press apply to activate the traffic shaping rules.

Fighting Bufferbloat with FQ_CoDel

Bufferbloat is the undesirable latency that comes from a router or other network equipment buffering too much data. This occurs because the router cannot immediately transmit data through a slow (bottleneck) link, so it “buffers” those packets. New traffic can get stuck behind those buffered packets, resulting in enormous (even multi-second) delays to all traffic. End users see this as lagging in games, stuttering in video & voice calls, or a general sense that “the network is slow”.

The AQM/SQM algorithms can eliminate that latency, significantly improving the end-user experience. One AQM is FQ_CoDel e.g. Flow Queueing with Controlled Delay. It ensures that packets from small flows are sent in a timely fashion, while large flows share the bottleneck’s capacity.

Here is an overview of the FQ_CoDel algorithm that performs these tasks in parallel:

    Separate every traffic flow’s arriving packets into their own queue.

    Remove a small batch of packets from a queue, round-robin style, and transmit that batch through the (slow) bottleneck link to the ISP. When each batch has been fully sent, retrieve a batch from the next queue, and so on.

    Offer back pressure to flows that are sending “more than their share” of data.

This last step is the heart of the FQ_CoDel algorithm. It measures the time that a packet remains in a queue (its “sojourn time”). That’s how it determines that a flow is using more than its share. If packets have been in a queue “too long” (that is, if their sojourn times exceed the target setting for longer than the interval), FQ_CoDel begins to mark or drop some of those packets to cause the sender to slow down.

For more details, see RFC 8290 https://datatracker.ietf.org/doc/html/rfc8290.
Parameters of FQ_CoDel

FQ_CoDel uses the following parameters in its algorithm.

target
	

Maximum time packets should dwell in a queue. (Default: 5ms)

interval
	

When sojourn times exceed the target for more than this interval, drop or mark packets to slow that flow. (Default: 100ms)

quantum
	

Maximum number of bytes to dequeue for transmission at one time. Should be set to the value of Interface MTU. (Default: 1514 bytes, 1500+14B hardware header, max 9000)

limit
	

Size of all queues managed by FQ_CoDel instance. It is the hard limit on the real queue size in packets (Default: 10240, max 20480).

flows
	

Sets the number of queues into which the incoming packets are classified (Default: 1024, max 65536)

CoDel ECN
	

Enable packet marking for ECN-enabled TCP flows when queue delay becomes high. (Default: Disabled)
Configuring FQ_CoDel for OPNsense

In the configuration steps below, assume these advertized ISP speeds:
	

Download
	

Upload

Mbit/s
	

530
	

30

To begin, go to Firewall ‣ Shaper ‣ Pipes. Select the advanced mode

After configuring the Pipes and Queues (below), be sure to read the Tuning FQ_CoDel section below that describes the brief final tuning process.
Step 1a - Create Download Pipe

On the Pipes tab click the + button in the lower right corner. An empty Edit Pipe screen pops up.
Create Pipe For Download

Setting
	

Default
	

Description

enabled
	

Checked
	

Check to enable the pipe

bandwidth
	

495
	

Set initially to 85% of ISP advertized BW, tune later - numeric

bandwidth Metric
	

Mbit/s
	

Metric associated with the bandwidth

queue
	

(empty)
	

Leave empty: queues are configured separately

mask
	

(none)
	

Leave empty

scheduler type
	

FQ_CoDel
	

Enables FQ_CoDel in scheduler

Enable CoDel
	

(empty)
	

Leave empty: use FQ as selected above

(FQ-)CoDel target
	

(empty)
	

Leave as default (default 5ms); tune later

(FQ-)CoDel interval
	

(empty)
	

Leave as default: tune later

(FQ-)CoDel ECN
	

Checked
	

Check to enable packet marking ECN for ECN enabled flows

FQ-CoDel quantum
	

(empty)
	

Set to your WAN MTU. For Ethernet let it default

FQ-CoDel limit
	

(empty)
	

Leave as default; tune later

FQ-CoDel flows
	

(empty)
	

Leave as default (default 1024)

description
	

Download
	

Free field, enter something descriptive
Step 1b - Create Upload Pipe

On the Pipes tab click the + button in the lower right corner. An empty Edit Pipe screen pops up.

Follow the same process as for the Download pipe, entering the 85% upload bandwidth value and entering “Upload” for the description
Step 2a - Create Download Queue

On the Queues tab click the + button in the lower right corner. An empty Edit queue screen pops up.
Create Queue For Download

enabled
	

Checked
	

Check to enable the queue

pipe
	

Download
	

Select our Pipe

weight
	

100
	

FQ_CoDel ignores the weight: set to 100

mask
	

(none)
	

Leave empty: FQ will handle fairness

Enable CoDel
	

(empty)
	

Leave empty: use FQ as selected in Pipe

(FQ-)CoDel target
	

(empty)
	

Leave empty for a queue

(FQ-)CoDel interval
	

(empty)
	

Leave empty for a queue

(FQ-)CoDel ECN
	

(empty)
	

Leave empty for a queue

description
	

Download-Queue
	

Free field, enter something descriptive

Note

target, interval, ECN actually refer to CoDel and not FQ_CoDel in the queue
Step 2b - Create Upload Queue

On the Queues tab click the + button in the lower right corner. An empty Edit queue screen pops up.

Follow the same process as for the Download queue, selecting the Upload pipe, and entering “Upload-Queue” for the description
Step 3a - Create Download Rule

On the Rules tab click the + button in the lower right corner. An empty Edit rule screen pops up.
Create a Rule For Download

enabled
	

Checked
	

Check to enable the rule

sequence
	

1
	

Auto generated number, overwrite only when needed

interface
	

WAN
	

Select the interface connected to the internet

proto
	

ip
	

Select the protocol, IP in our example

source
	

any
	

The source address to shape, leave on any

src-port
	

any
	

The source port to shape, leave on any

destination
	

any
	

The destination IP to shape, leave on any

dst-port
	

any
	

The destination port to shape, leave on any

direction
	

in
	

Matches incoming or outgoing packets or both (default). We want to shape Download e.g ingress on WAN

target
	

Download-Queue
	

Select the Download queue

description
	

Download-Rule
	

Enter a descriptive name
Step 3b - Create Upload Rule

On the Rules tab click the + button in the lower right corner. An empty Edit rule screen pops up.

Follow the same process as for the Download rule, using the same values except:

    sequence (set to 2);

    direction (set to “out”)

    target (set to “Upload-Queue”);

    description (set to “Upload-Rule”)

Step 4 - Finalizing the configuration

Now press apply to activate the traffic shaping rules.
Test for Bufferbloat

There are several web sites that measure the latency during download and upload to give an indication of bufferbloat in your network. Each of these clearly labels the download and upload rates, as well the latency during those tests. See these screen shots below.

They are all substantially the same. Pick one and use it for all your measurements.

Waveform Speed Test https://www.waveform.com/tools/bufferbloat
../../_images/waveform_bufferbloat_test_post_config_tuning.png

Cloudflare https://speed.cloudflare.com/
../../_images/cloudflare_speedtest.png

Speedtest.net http://speedtest.net
../../_images/speedtest_net.png
Tuning FQ_CoDel

After you configure the pipes and queues (above), take a few minutes to “tune” your FQ_CoDel instance for your ISP. To do this:

First, run any of the speed tests above before applying any shaper. Run several tests to get average data rates and latency. Write those values down.

While you are configuring FQ_CoDel, enter an initial value for the “bandwidth” that is 85% of the advertized rate from the ISP. (That is, if the download service is 100 Mbit/s, set the speed to 85 Mbit/s; for 40 Mbit/s upload, set it to 40 x 85%, or 34 Mbit/s.)

The remainder of the process is iterative, but brief:

    Run a speed test to see the latency

    Increase the Download bandwidth setting a bit

    Run a speed test again. If the latency remains low, increase the bandwidth setting again.

    Keep doing this until the latency increases, then back off the setting.

    Do the same with the Upload bandwidth setting

When each of the Download and Upload bandwidth settings are as high as possible without increasing latency, you’re done.
Detailed FQ-CoDel Tuning

FQ_CoDel is designed to be a “no-knobs” algorithm. After you enter the Download and Upload bandwidth settings, the defaults for the other parameters work very well out of the box for virtually all situations. Before you invest further time in tuning, try the router for a day. If it’s “good enough”, you are done.

Read on if you want to go further.

FQ-CoDel “out of the box” default settings

FQ_C Parameter
	

Default

quantum
	

1514

target
	

5

interval
	

100

limit
	

10240

flows
	

1024

ECN
	

OFF
quantum

Quantum is one of these parameters that were constantly discussed what should be the proper value. Within the internet there is a lot of discussion that it should be set to 300 per 100 Mbit/s of BW. This however is wrong.

Quantum specifies number of bytes a queue can serve before being moved to the tail of old. As we are doing Fair Queueing we want to aim to serve all queues equally.

The proper value of Quantum should be no more or less than is the WAN MTU.

Note

At lower rates, below 100 Mbit/s, setting the quantum to 300 ensures that more smaller packets get through faster than big ones. It doesn’t matter much at higher rates. The quantum should be set to the MTU or 300 if you have low bandwidth and the cpu power. Setting the quantum lower causes more loops touching all the packets so it eats slightly more cpu
target & interval

Target is the acceptable minimum standing/persistent queue delay for each FQ-CoDel queue. This minimum delay is identified by tracking the local minimum queue delay that packets experience. Target should be tuned to be at least the transmission time of a single MTU-sized packet at the WAN egress link speed.

To do this we can run excessive ping to the HOP after your OPNsense and take the average rtt round up as your Target. In this case 12ms

Example from the CLI of OPNsense

traceroute 1.1.1.1
traceroute to 1.1.1.1 (1.1.1.1), 64 hops max, 40 byte packets
1  192.168.0.1  0.463 ms  0.453 ms  0.480 ms     <<<< LAN Interface of OPN
2  10.205.5.1  10.879 ms  11.010 ms  11.079 ms   <<<< ISP directly connected Device to OPN WAN

ping -s 1472 -c 1000 -D 10.205.5.1
PING 10.205.5.1 (10.205.5.1) 1472(1500) bytes of data.
1480 bytes from 10.205.5.1: icmp_seq=0 ttl=255 time=13.1 ms
1480 bytes from 10.205.5.1: icmp_seq=1 ttl=255 time=10.4 ms

--- 10.205.5.1 ping statistics ---
1000 packets transmitted, 1000 packets received, 0.0% packet loss
round-trip min/avg/max/stddev = 7.800/11.429/45.992/4.796 ms

Note

Target is a good parameter for tune to prevent CoDel being too aggressive at low BW. Otherwise Target should be around 5-10% of Interval

Interval is used to ensure that the measured minimum delay does not become too stale. It’s value is chosen to give endpoints time to react to a drop without being so long that response times suffer.

Note

Interval default 100ms works usually well (10ms-1s, excels at range 10ms-300ms). If you want to tune Interval it should to be set around the worst case RTT scenario through the bottleneck
limit

Default limit size of 10240 packets is to much. The creators recommended value 1000 for sub 10 Gbit/s connections. The default limit will never reached for sub 10 Gbit/s WAN connections. Before that could happen FQ_CoDel would already take action. So it’s healthy to reduce limit.

The over-large packet limit leads to bad results during slow start on some benchmarks. Reducing it too low could impact new flow start.

However there is a problem with FQ_CoDel implementation in FreeBSD (as well OpenBSD), that causes CPU hogging and excessive logging, this is more visible when set to 1000. Which causes a back pressure and additional unwanted latency.

For now its best to have limit at default.

Note

There is already a BUG opened for this and an email chain from one of the CoDel creators. This problem is overall affecting the performance, its not specific only to limit parameter, and more so the more flows are present
flows

The “flows” parameter sets the number of queues into which the incoming packets are classified. Due to the stochastic nature of hashing, multiple flows may end up being hashed into the same slot.

This parameter can be set only at initialization time in the current implementation (needs reboot of device), since memory has to be allocated for the hash table.

Warning

Setting too high number can cause the device to be stuck. Be careful with this one.
ECN

Current best practice is to turn off ECN on uplinks running at less than 4 Mbit/s (if you want good VOIP performance; a single packet at 1 Mbit/s takes 13ms, and packet drops get you this latency back).

ECN IS useful on downlinks on a home router, where the terminating hop is only one or two hops away, and connected to a system that handles ECN correctly.

Note

If you are experiencing slow starts disable ECN


(Advanced) Settings

In some circumstances people might want to change how our system handles traffic by default, in which case the advanced settings section is a good place to look.
Network Address Translation

Warning

Although the options below might look interesting to ease setup, we do not advise to use them. Since automatic rules always contain assumptions about the situation they try to solve, it’s not guaranteed they will fit your use-case at all times. They merely exist for historical reasons, if possible better add manual nat rules to make sure the intend is very explicit when one inspects your setup.

Tip

There is a how-to section explaining NAT Reflection in detail.

Attention

Firewall Rules won’t be automatically generated when using any of the below Reflection options. You have to create them manually or traffic will be blocked by the default deny rule.

Note

    Examine the automatic Reflection rules either in the shell with pfctl -s nat or in the GUI at Firewall ‣ Diagnostics ‣ Statistics ‣ rules.

    rdr means redirection. Redirection rules are Firewall ‣ NAT ‣ Port Forward rules, also known as Destination NAT. Destination NAT changes the destination IP of a packet.

    nat rules are Firewall ‣ NAT ‣ Outbound rules, also known as Source NAT. Source NAT changes the source IP of a packet.

    Reflection NAT is just rdr. Hairpin NAT is a combination of rdr and nat.

Reflection for port forwards

Disabled by default, when enabled the system will generate rdr rules to reflect port forwards on internal interfaces automatically (interfaces without a gateway set).

If you create a Firewall ‣ NAT ‣ Port Forward rule with the interface as wan, the automatic rdr rules will be created for any of your other connected interfaces (e.g. lan, opt1, lo0).
Reflection for 1:1

Disabled by default, when enabled the system will generate redirect rdr rules for 1to1 nat rules similar to the portforward option.
Automatic outbound NAT for Reflection

Disabled by default, when enabled the system will generate nat rules in addition to rdr rules, effectively turning all Reflection NAT into Hairpin NAT.

Warning

The disadvantage of reflecting traffic back with the firewall’s internal IP address is that the receiving side will see the source IP address of the firewall instead of the source IP address of the client. Some security features on servers like fail2ban can’t properly function like this.
Bogon Networks
Update Frequency

Configure the frequency of updating the lists of IP addresses that are reserved (but not RFC 1918) or not yet assigned by IANA.
Gateway Monitoring
Skip rules

By default, when a rule has a specific gateway set, and this gateway is down, rule is created and traffic is sent to default gateway. This option overrides that behavior and the rule is not created when gateway is down
Multi-WAN
Sticky connections

When using a gateway group the firewall will use the same gateway for the same source address, by default as long as there’s a state active, optionally this can be configured with a different timeout.
Shared forwarding

Using policy routing in the packet filter rules causes packets to skip processing for the traffic shaper and captive portal tasks. Using this option enables the sharing of such forwarding decisions between all components to accomodate complex setups.
Disable force gateway

By default OPNsense enforces a gateway on “Wan” type interfaces (those with a gateway attached to it), although the default usually is the desired behaviour, it does influence the routing decisions made by the system (local traffic bound to an address will use the associated gateway).

Note

This rule is responsible for the let out anything from firewall host itself (force gw) rule visible in the floating section, it forces a route to (route-to) on all non local traffic for the “Wan” type interface.
Schedules
Schedule States

By default schedules clear the states of existing connections when the expiration time has come. This option overrides that behavior by not clearing states for existing connections.
Logging

Here the logging behaviour of the default block/pass, automatic outbound NAT as well as bogon and private network blocks can be adjusted. If disabled, only log directives from your manual rules will be show in the firewall log.
Miscellaneous
Firewall Optimization

Firewall state table optimization to use, influences the number of active states in the system, only to be changed in specfic implementation scenarios.

    [normal] (default)As the name says, it is the normal optimization algorithm

    [high-latency] Used for high latency links, such as satellite links. Expires idle connections later than default

    [aggressive] Expires idle connections quicker. More efficient use of CPU and memory but can drop legitimate idle connections

    [conservative] Tries to avoid dropping any legitimate idle connections at the expense of increased memory usage and CPU utilization.

Bind states to interface

Set behaviour for keeping states, by default states are floating, but when this option is set they should match the interface. The default option (unchecked) matches states regardless of the interface, which is in most setups the best choice.
Disable Firewall

Disable all firewall (including NAT) features of this machine.
Firewall Adaptive Timeouts

Timeouts for states can be scaled adaptively as the number of state table entries grows.

    [start] When the number of state entries exceeds this value, adaptive scaling begins. All timeout values are scaled linearly with factor (adaptive.end - number of states) / (adaptive.end - adaptive.start).

    [end] When reaching this number of state entries, all timeout values become zero, effectively purging all state entries immediately. This value is used to define the scale factor, it should not actually be reached (set a lower state limit, see below).

Firewall Maximum States

Maximum number of connections to hold in the firewall state table, usually the default is fine, when serving a lot of connections you may consider increasing the default size which is mentioned in the help text.
Firewall Maximum Fragments

Sets the maximum number of entries in the memory pool used for fragment reassembly.
Firewall Maximum Table Entries

Maximum number of table entries for systems such as aliases, sshlockout, bogons, etc, combined. When using a lot of large aliases, you may consider increasing the default. The configured default is mentioned in the help text.
Static route filtering

This option only applies if you have defined one or more static routes. If it is enabled, traffic that enters and leaves through the same interface will not be checked by the firewall. This may be desirable in some situations where multiple subnets are connected to the same interface.

Note

Although these rules will be visible in the “automatic” rule section of each interface, we generally advice to add the rules actually recquired on a per net basis manually.
Disable reply-to

With Multi-WAN you generally want to ensure traffic leaves the same interface it arrives on, hence reply-to is added automatically by default. When using bridging, you must disable this behavior if the WAN gateway IP is different from the gateway IP of the hosts behind the bridged interface.

Warning

Although our default is to enable this rule for historic reasons, there are side-affects when adding reply-to to every “wan” type rule. When allowing traffic originating from the same network as the interface is attached to, it will still reply the packet to the configured gateway.

To prevent this behvior, you can either disable reply-to here and configure the desired behaviour on a per-rule basis or add a rule for local traffic above the one for outbound traffic disabling reply-to (in rule advanced).
Disable anti-lockout

When this is unchecked, access to the web GUI or SSH on the LAN interface is always permitted, regardless of the user-defined firewall rule set. Check this box to disable the automatically added rule, so access is controlled only by the user-defined firewall rules. Ensure you have a firewall rule in place that allows you in, or you will lock yourself out.
Aliases Resolve Interval

Interval, in seconds, that will be used to resolve hostnames configured on aliases.
Check certificate of aliases URLs

Make sure the certificate is valid for all HTTPS addresses on aliases. If it’s not valid or is revoked, do not download it.
Anti DDOS
Enable syncookies

This option is quite similar to the syncookies kernel setting, preventing memory allocation for local services before a proper handshake is made.

In this case pf will be protected agains state table exhaustion.

The following modes are available:

    never (default)

    always

    adaptive - in which case a lower and upper percentage should be specified referring to the usage of the state table.


Normalization

Traffic normalization protects internal machines against inconsistencies in Internet protocols and implementations. OPNsense has some generic options to normalize some packets on a per interface basis, in some cases more detailed changes are needed, for which custom rules can be configured.

By default (when Disable interface scrub is not set), all interfaces are scrubbed for all traffic, with fragment reassemble enabled and max-mss set when specified in MSS on the interface.

Note

Some protocols, such as NFS, require specific fragment handling options, which my require specific options set like IP Do-Not-Fragment*
Settings

Normalization rules use the same kind of matching as normal firewall rules, which we are not going to detail here. When matched, some different options can be set.

Note

When rules overlap, the first matching rule wins, hence per interface options are sorted after user configurable ones.

Max mss
	

Enforces a maximum MSS for matching TCP packets. Can also be configured on the interface as general rule.

TOS / DSCP
	

Enforces a TOS/DCP for matching IP packets.

Minimum TTL
	

Enforces a minimum TTL for matching IP packets.

Do not fragment
	

Clears the dont-fragment bit for a matching IP packet, which disables IP fragmentation when set.

Random ID
	

Replaces the IP identification field with random values to compensate for predictable values generated by many hosts. This option only applies to packets that are not fragmented after the optional fragment reassembly.


Configure CARP
Overview

One of the more powerful features of OPNsense is to set-up a redundant firewall with automatic fail-over option. This chapter describes step by step how to create a set-up based on two networks. The 192.168.1.0/24 will be used for the internal network and 172.18.0.0/24 will be used to route our traffic to the internet.
../../_images/900px-Carp_setup_example.png

When using CARP ( FreeBSD handbook on CARP ), all fail-safe interfaces should have a dedicated IP address which will be combined with one shared virtual IP address to communicate to both networks. In the picture above the dashed lines are used to mark the virtual addresses.

The configuration file (XML) for both firewalls can be downloaded from the wiki.
Terminology

There is some terminology involved in setting up a CARP cluster, which we will explain briefly first:

CARP

Common Address Redundancy Protocol uses IP protocol 112, is derived from OpenBSD and uses multicast packets to signal its neighbours about its status. Always make sure that each interface can receive CARP packets. Every virtual interface must have a unique Virtual Host ID (vhid), which is shared across the physical machines. To determine which physical machine has a higher priority, the advertised skew is used. A lower skew means a higher score. (our master firewall uses 0).

pfSync

Together with CARP, we can use pfSync to replicate our firewalls state. When failing over you need to make sure both machines know about all connections to make the migration seamless. It’s highly advisable to use a dedicated interface for pfSync packets between the hosts, both for security reasons (state injection) as for performance.

Warning

When using different network drivers on both machines, like running a HA setup with one physical machine as master and a virtual machine as slave, states can not be synced as interface names differ. The only workaround would be to set up a LAGG.

XMLRPC sync

OPNsense includes a mechanism to keep the configuration of the backup server in sync with the master. This mechanism is called XMLRPC sync and can be found under System ‣ High Availability ‣ Settings.
Setup interfaces & basic firewall rules

Warning

Make sure the interface assignments on both systems are identical! Via Interfaces ‣ Overview you can check if e.g. DMZ is opt1 on both machines. When the assignments differ you will have mixed Master and Backup IPs on both machines.

Our example uses three interfaces, which all have a rather basic setup.

Master

Go to interfaces, make sure you have all three interfaces assigned and setup the following addresses and subnets:

LAN 192.168.1.10/24

WAN 172.18.0.101/24

PFSYNC 10.0.0.1

Next we need to make sure the appropriate protocols can be used on the different interfaces, go to Firewall ‣ Rules and make sure both LAN and WAN accept at least CARP packets (see protocol selection). Because we’re connecting both firewalls using a direct cable connection, we will add a single rule to accept all traffic on all protocols for that specific interface. Another option is to only accept traffic to the GUI port and pfSync protocol.

Backup

The backup server needs its own dedicated addresses, we will use these:

LAN
	

192.168.1.20/24

WAN
	

172.18.0.102/24

PFSYNC
	

10.0.0.2

Note

Per default the dropdown menu for subnet mask only fits for IPv4 addresses (up to 32). If you want to add an IPv6 CARP address, write your IPv6 address and the dropdown list will auto-update to 128. Configuring CARP with IPv6

Because we are going to synchronize firewall settings between both hosts, we only need to make sure that the pfSync interface can accept data from the master for the initial setup. Use the same rule as used for the master on this interface.
Setup Virtual IPs

On the master node we are going to setup our Virtual IP addresses, which will also be added to the backup node with a higher skew after synchronisation. Go to Interfaces ‣ Virtual IPs and add a new one with the following characteristics:

Type
	

Carp

Interface
	

WAN

IP addresses
	

172.18.0.100 / 24

Virtual password
	

opnsense (the example uses this)

VHID Group
	

1

Advertising Frequency
	

Base 1 / Skew 0

Description
	

VIP WAN

And another using the following:

Type
	

Carp

Interface
	

LAN

IP addresses
	

192.168.1.1 / 24

Virtual password
	

opnsense (the example uses this)

VHID Group
	

3

Advertising Frequency
	

Base 1 / Skew 0

Description
	

VIP LAN

Note

Always create Carp VIPs with the same subnet mask as it’s parent interface. If the parent interface is /24, your Carp VIP should also be /24. Even though some sources claim that /32 will work, services like DHCP Failover will fail with peer holds all free leases.
Setup outbound NAT

When traffic is going out of the firewall it should also use the virtual IP address on the WAN interface to make seamless transitions possible. The default NAT configuration is for OPNsense is to use Automatic outbound NAT rule generation using the WAN interface’s IP address for outgoing connections. This will not allow seamless transitions and needs to be changed to the WAN VIP.

Go to Firewall ‣ NAT ‣ Outbound. Choose manual outbound nat rule generation. On this page create the a rule originating from the 192.168.1.0/24 network to use the CARP virtual interface (172.18.0.100). The rule should contain the following:

Interface
	

WAN

Source addresss
	

LAN net (192.168.1.0/24)

Translation / target
	

172.18.0.100 (CARP virtual IP)
(optional) Setup DHCP server

When using DHCP for the local area network, there are some things to consider. All clients should use the virtual address instead of the physical address it’s normally propagating. Next thing to consider is there will be two servers active at the same time, which should know of each others pools. If DNS requests are also forwarded by OPNsense, make sure the DHCP server sends the right IP address. These are settings used in our example (on the master server):

DNS servers
	

192.168.1.1

Gateway
	

192.168.1.1

Failover peer IP
	

192.168.1.20
Setup pfSync and HA sync (xmlrpc)

First we should configure pfSync to synchronize the connection state tables and HA sync (xmlrpc) on the master firewall. Go to System ‣ High Availability ‣ Settings and enable pfSync by activating the Synchronize States checkbox, selecting PFSYNC for the Synchronize Interface and enter the peer IP (10.0.0.2) in the field Synchronize Peer IP.

To synchronize the configuration settings from the master to the backup firewall, we setup the XMLRPC sync. In the Synchronize Config to IP field we enter the peer IP (10.0.0.2) of the PFSYNC interface again to keep this traffic on the direct connection between the two firewalls. Now we need to enter the remote user name and password and configure the settings we want to duplicate to the backup server. For our setup we will enable the following:

Synchronize rules

Synchronize NAT

Synchronize DHCPD

Synchronize Virtual IPs

After this we configure pfSync on the backup firewall. Go to System ‣ High Availability ‣ Settings and enable pfSync by activating the Synchronize States checkbox, selecting PFSYNC for the Synchronize Interface and enter the master IP (10.0.0.1) in the field Synchronize Peer IP. Do not configure XMLRPC sync on the backup firewall.
Finalize setup

Just to make sure all settings are properly applied, reboot both firewalls before testing.
Testing setup

First go to System ‣ High availability ‣ Status in the OPNsense webinterface and check if both machines are properly initialized.

To test our setup, we will connect a client to the local area network and open a ssh connection to a host behind both firewalls. Now when connected you should be able to look at the state table on both OPNsense firewalls (Firewall ‣ Diagnostics ‣ States Dump) and they should both display the same connection. Next try to pull the network plug from the master firewall and it should move over to the backup without loosing (or freezing) the ssh connection.
Adding multiple CARP IPs

If your provider offers you a subnet of public IP addresses and you want to expose them for NAT or different services running on your Firewall, you will also have to add them to your HA setup. Since adding a VHID for every IP would make the CARP traffic very noisy, you can also add a new IP Alias and choose the correct VHID where the first CARP IP is configured. See CARP Virtual IP type for more information on the concept.

Note

IP Aliases are not synchronized to the backup firewall during a configuration sync, be sure to also add it to your second machine when setting up CARP.

Attention

Adding an IP alias with a VHID attached to a running CARP system requires some consideration. Since adding a new IP Alias to an existing VHID on a single machine will invalidate the VHID hash for both sides, both machines will react by switching to the master state, triggering a split-brain scenario. To avoid this, CARP must explicitly be disabled on one of the machines before adding the new IP Alias. For an exact procedure, refer to the example
Example: Updating a CARP HA Cluster

Running a redundant Active/Passive cluster leads to the expectation to have zero downtime. To keep the downtime at a minimum when running updates just follow these steps:

    Update your secondary unit and wait until it is online again

    On your primary unit go to Interfaces ‣ Virtual IPs ‣ Status and click Enter Persistent CARP Maintenance Mode

    You secondary unit is now MASTER, check if all services like DHCP, VPN, NAT are working correctly

    If you ensured the update was fine, update your primary unit and hit Leave Persistent CARP Maintenance Mode

With these steps you will not lose too many packets and your existing connection will be transferred as well. Also note that entering persistent mode survives a reboot.
Example: Adding a virtual IP to an active VHID group

    On either the primary or secondary unit, go to Interfaces ‣ Virtual IPs ‣ Status, click on Disable CARP (not maintenance mode). When disabling it on the master, the backup should take over.

    Add the virtual IP alias to the machine where CARP is disabled and apply the settings.

    While keeping CARP disabled on this machine, add the same IP alias to the other machine and apply. This may interrupt traffic briefly at worst, but this is acceptable in a failover scenario.

    Double-check that the VIP configuration is identical on both machines.

    Re-enable CARP on the previous machine. Normal operation should resume.

Configuring CARP with IPv6

Warning

Please read all the above steps before attempting to configure IPv6 CARP VIPs. This section is complementry. Some important details are omitted for a more focused approach.

Note

    An example ISP provided you the following:

    IPv6 network: 2001:db8:1234::/48

    Transfer network: 2001:db8:1234::/64

    Upstream gateway: 2001:db8:1234::/64

    Static route: 2001:db8:1234::/48 next hop 2001:db8:1234::7/64

Note

    Firewall rules have to permit Protocol: CARP with TCP/IP Version: IPv6 on all interfaces with CARP IPv6 VIPs.

Master

Go to interfaces, make sure you have these interfaces assigned and setup the following addresses and subnets:

WAN
	

2001:db8:1234::1/64

LAN
	

2001:db8:1234:1::1/64

Backup

The backup server needs its own dedicated addresses, we will use these:

WAN
	

2001:db8:1234::2/64

LAN
	

2001:db8:1234:1::2/64
Setup Virtual IPv6 Global Unicast Address

On the master node we are going to setup our Virtual IPv6 global unicast address, which will also be added to the backup node with a higher skew after synchronisation. Go to Interfaces ‣ Virtual IPs and add a new one with the following characteristics:

Type
	

Carp

Interface
	

WAN

IP addresses
	

2001:db8:1234::7/64

Virtual password
	

opnsense (the example uses this)

VHID Group
	

2

Advertising Frequency
	

Base 1 / Skew 0

Description
	

VIP WAN IPv6

Tip

2001:db8:1234::7/64 should be the IP where the static route of your provider points to.

Warning

Use a free VHID Group for each additional CARP VIP. Don’t use the same VHID Group twice.
Setup Virtual IPv6 Link Local Address

On the master node we are going to setup our Virtual IPv6 link local address, which will also be added to the backup node with a higher skew after synchronisation. Go to Interfaces ‣ Virtual IPs and add a new one with the following characteristics:

Type
	

Carp

Interface
	

LAN

IP addresses
	

fe80::/64

Virtual password
	

opnsense (the example uses this)

VHID Group
	

4

Advertising Frequency
	

Base 1 / Skew 0

Description
	

VIP LAN IPv6

Warning

    All IPv6 CARP VIPs on LAN interfaces should be /64 Link Local Addresses.

    Don’t use Global Unicast Addresses, many devices ignore them as IPv6 Gateway.

Tip

    Even though you can use fe80::/64 for each additional LAN interface, it’s advisable to use IPv6 addresses with IPv4 embedded (RFC 4291 - Section 2.5.5).

    Example: If there is a LAN interface with the IPv4 CARP VIP 192.168.1.1/24, you could use fe80::192:168:1:1/64 as the link local address. It would help with readability, because hosts in that network would have the IPv4 Gateway as 192.168.1.1 and the IPv6 Gateway as fe80::192:168:1:1.

Setup Router Advertisments

WAN

    Go to Services ‣ Router Advertisments and select the WAN interface.

    Make sure Router Advertisements is set to Disabled

LAN

    Go to Services ‣ Router Advertisments and select the LAN interface.

    Change the Source Address from automatic to VIP LAN IPv6 (fe80::/64).

Resources

    Configuration for master server ( Carp_example_master.xml )

    Configuration for backup server ( Carp_example_backup.xml )


Log Files

When troubleshooting problems with your firewall, it is very likely you have to check the logs available on your system. In the UI of OPNsense, the log files are generally grouped with the settings of the component they belong to. The log files can be found here:

Live View
	

Firewall ‣ Log Files ‣ Live View
	

View firewall logs in realtime, smart filtering can be applied

Plain View
	

Firewall ‣ Log Files ‣ Plain View
	

Just the plain contents how pf logs into filter.log
Live View

Live view updates itself in realtime if a rule is matched that has logging enabled or one of the global logging options is enabled under: System ‣ Settings ‣ Logging

In the top left corner of the page you can build filter conditions for rules to match when inspecting traffic, while here you can select different fields (for example label, src address, dst address) and how to match them (contains, is, is not, does not contain) combined with a criteria (either a string or a preselected value, depending on type). The [+] button adds the the filter to the view.

By default results should match all criteria (AND), but you can change that to an any of criteria (OR). The latter is sometimes practical if you want to track a small list of hosts.

Detailed information for a specific rule can be provided using the info button at the end of each line.

Tip

The host and port fields are a bit special and apply to both source and destination, which makes sure that traffic matched to and from a specific address or port are both matched.

Tip

Usually a rule contains a rid field which corresponds to the rule or setting in OPNsense responsible for this match, when clicking on the link the system will try to redirect you to the correct setting (or rule).

Note

The live log only shows rules that are matched by the firewall, in case a state is created the flow will be reported for the first packet, as long as the state still exists no new lines will be reported for the same traffic flow. If you need to inspect raw traffic, it’s often practical to combine the live-log with the packet capture feature found under interface diagnostics in the menu.

Note

Since log lines are stored on the system without an exact match to the rule in question, we do need to translate the sequence in the file back to the rule definition stored in the system. Due to this fact, the information is less accurate historically if the firewall was reconfigured. (labels may be incorrect when looking at older data)


Diagnostics
Aliases

Detailed insight into loaded aliases and their content. When an alias has Statistics enabled, it will show these too.

It’s also possible to manually adjust the contents, using Quick add address or the delete button.

Note

When deleting items, keep in mind that the regular update process might put the address (or network) back in, since deletion isn’t persistent.

Tip

Use “Find references” to check if an address would match any configured aliases, which is very practical for debugging purposes, since it will also check if an address fits a network (such as 10.0.0.2 fits in 10.0.0.0/24).
Sessions

Utilises pftop to offer a detailed view on the active sessions and their traffic counters.

The following fields are available in the grid:

Dir
	

Direction (in -> or out <-)

Proto
	

Protocol in question

Source
	

Source address and port

Gateway
	

Address and port this session is being translated too using NAT

Destination
	

Destination address and port

State
	

State at source:destination, see tables in States section

Age (sec)
	

The number of seconds since the state is created

Expires (sec)
	

The number of seconds left before the state expires.

Pkts
	

Number of packets processed by the state

Bytes
	

Number of bytes processed by the state

Rule
	

Rule this state (most likely) belongs to
States

Insight into the state table (pf), offers the ability to search for specific states and removal. It is also possible to reset all states and/or the source tracking tables from here, especially the state table reset should be used with care as it drops all active connections.

If you use the grid search input to look for states, or you used the Inspect button on the firewall rules page and opened the state view, you will see a button that allows you to kill all states that matched the criteria.

Note

The state table tries to connect states to rules, but since these are refered to by rule number (sequence) in pf(4) these aren’t always accurate after changes to the rules.

The following fields are available in the grid:

State id
	

Unique internal identifier describing the state and the origin (creator)

Int
	

Bound to which interface, by default this is all unless ” Bind states to interface” is set in Firewall->Settings->Advanced

Dir
	

Direction (in -> or out <-)

Proto
	

Protocol in question

Source
	

Source address and port

Nat
	

Address and port this session is being translated too using NAT

Destination
	

Destination address and port

State
	

State at source:destination, see next tables for lists of states and their explanations available

Rule
	

Rule this state (most likely) belongs to

Command
	

Button to drop a specific state (State id)
List of available TCP states (as defined by RFC 793)

LISTEN
	

Represents waiting for a connection request from any remote TCP and port.

SYN_SENT
	

Represents waiting for a matching connection request after having sent a connection request.

SYN_RCVD
	

Represents waiting for a confirming connection request acknowledgment after having both received and sent a connection request.

ESTABLISHED
	

Represents an open connection, data received can be delivered to the user. The normal state for the data transfer phase of the connection.

FIN_WAIT_1
	

Represents waiting for a connection termination request from the remote TCP, or an acknowledgment of the connection termination request previously sent.

FIN_WAIT_2
	

Represents waiting for a connection termination request from the remote TCP.

CLOSE_WAIT
	

Represents waiting for a connection termination request from the local user.

CLOSING
	

Represents waiting for a connection termination request acknowledgment from the remote TCP.

LAST_ACK
	

Represents waiting for an acknowledgment of the connection termination request previously sent to the remote TCP (which includes an acknowledgment of its connection termination request).

TIME_WAIT
	

Represents waiting for enough time to pass to be sure the remote TCP received the acknowledgment of its connection termination request.

CLOSED Represents no connection state at all
List of available UDP/Other states (man pf.conf(5))

NO_TRAFFIC
	

No traffic for this direction

SINGLE
	

The state if the source host sends more than one packet but the destination host has never sent one back.

MULTIPLE
	

The state if both hosts have sent packets.
Statistics

Various detailed statistics gathered from pfctl, such as packet counters per interface, memory limits, configured timeouts and detailed active rules.


Organize PF Rules by Category

OPNsense firewall rules can be organized per category. These categories can be freely chosen or selected.

Note

This feature was added in version 16.1.1. Always keep your system up to date.
Adding a category to a rule

To add a category to a rule, open or create a new rule and scroll to Category. Then just add you category, if this is the first rule with a category no selection options will be visible.
../../_images/Rule_Category.png
Firewall Rules Filter by category

Only when there are rules with a defined category, the Filter by category becomes visible at the bottom of the table.

If you click it is will look like this:
../../_images/Filter_by_Category.png

If you have a large number of categories, then just start typing and in search box to make a quick selection.
Before Selection

Take a look at this simple rule set before selecting our “My IPs” category.
../../_images/Rules_Full.png
And after selection

Now when selecting our test category it will look like this:
../../_images/Filter_Category_Result.png

That is all there is to it to organize your rules without messing anything up.
Multi Select

In a later release of OPNsense 16.1 multi selection has been added. This features makes it possible to select rules from more than one category.

Example:
../../_images/fw_category_multiselect.png


Virtual Private Networking

A virtual private network secures public network connections and in doing so it extends the private network into the public network such as internet. With a VPN you can create large secure networks that can act as one private network.
../_images/Virtual_Private_Network_overview.png

(picture from wikipedia)

Companies use this technology for connecting branch offices and remote users (road warriors).

OPNsense supports VPN connections for branch offices as well as remote users.

Creating a single secured private network with multiple branch offices connecting to a single site can easily be setup from within the graphical user interface. For remote users, certificates can be created and revoked and a simple to use export utility makes the client configuration a breeze.

OPNsense offers a wide range of VPN technologies ranging from modern SSL VPNs to well known IPsec as well as WireGuard and Zerotier via the use of plugins.
../_images/vpn.png
IPsec

Since IPsec is used in many different scenario’s and sometimes has the tendency to be a bit complicated, we will describe different usecases and provide some examples in this chapter.
General context

The IPsec module incorporates different functions, which are grouped into various menu items. Since the start of our project we have been offering IPsec features based on the legacy ipsec.conf format, which we are migrating to swantcl.conf as of version 23.1. While migrating the existing featureset we came to the conclusion that the world has changed quite a bit and in order to offer better (api) access to the featureset available we decided to plan for deprecation of the legacy “Tunnel settings” as they have existed since we started. No timeline has been set, only a feature freeze on tunnels using the “Tunnel settings” menu item.

One of the main goals for the long run is to better align the gui components so they reflect the reality underneath, as we use strongswan, our aim is to follow their terminology more closely than we previously did.

The following functions are available in the menu (as of OPNsense 23.1):

    Connections

        New configuration tool offering access to the connections and pools sections of the swanctl configuration

    Tunnel Settings

        Legacy IPsec configuration tool

    Mobile Clients

        Offering access to various options of the attr plugin and pool configurations for legacy tunnels

    Pre-Shared Keys

        Define secrets to be used for local authentication.

    Key Pairs

        For public key authentication collect public and private keys.

    Advanced Settings

        Define passthrough networks (to exclude from kernel traps), logging options and some generic options

    Status Overview

        Shows tunnel statusses

    Lease Status

        For mobile clients, show address leases for various pools configured

    Security Association Database

        Shows security associations, the fundamental concept of IPsec describing a relationship between two or more entities

    Security Policy Database

        Installed security policies describing which traffic is allowed to pass a tunnel

    Virtual Tunnel Interfaces

        Edit or create new if_ipsec(4) interfaces and show the ones created by legacy tunnels

    Log File

        Inspect log entries related to IPsec

Migrating from tunnels to connections

Having used the tunnel settings from the early OPNsense days, some terminology might be a bit confusing when moving into the new options offered. This paragraph aims to explain some of the common terms from the tunnel section and their new place in the connections. For a full list of changes, the upstream migration documentation is an interesting read as well.

    Phase 1 - The general connection settings, like local/remote addressess and general protocol settings. Choices in authentication to use are also part of this, they may involve multiple rounds.

    Phase 2 - Nowadays Strongswan calls these children, as these define the CHILD_SA subsections in play. This is where you can define the networks on both ends. When multiple segments are being added into the same child, these are being treated as one policy where all of them are able to communicate to eachother.

    Phase 1 / Tunnel Isolation - This option made sure every network defined in phase 2 would be treated as a child of it’s own (e.g. two phase 2’s would turn into two children)

    Phase 2 / Manual SPD entries - Manual SPD entries, this has been replaced with it’s own menu option (Security Policy Database) offering more flexibilty and visibilty.

Note

Using DNS for endpoints is possible, but will work a bit different than previously as in most cases the firewall tried to resolve the names and didn’t use the functionality provided by Strongswan. It is however currently not possible to use DNS entries for VTI tunnels due to restrictions in if_ipsec(4) as these type of interfaces can’t be changed dynamically in a reliable way.

Note

When migrating Pre-Shared Key type tunnels to connections, make sure to add an entry in the “Pre-Shared Keys” module as well. If both ends should use their own identifier, fill in both local and remote values. The legacy module requested this information in the phase 1 page and wrote the same information to the secrets.

Tip

Since OPNsense uses the new Strongswan format also for legacy tunnels, it is rather easy to convert a tunnel manually when downloading the swanctf.conf file from the machine. You can find it in /usr/local/etc/swanctl/swanctl.conf and the format is almost identical to the connections gui available in OPNsense.
Combining legacy tunnels and connections

It is possible to combine tunnels and connections, but there are some constraints. As our legacy tunnels force a reqid for each configured child (phase 2), there is a risk the automated numbering from the new connection children overlaps. To prevent these overlaps, its required to set an unused reqid in the connection child.
Security policies and routing

In order to pass traffic over an IPsec tunnel, we need a policy matching the traffic. By default when adding a phase 2 (or child) policy a “kernel route” is installed as well, which traps traffic before normal routing takes place.

Note

Without a policy in place for the tunnel, traffic won’t be accepted, in case a policy with a kernel route overlaps a local or locally routed network the traffic will not be received by the host in question.

Tip

When matching overlapping networks in a policy (VTI or overlapping networks), make sure to exclude your own network segments in the Passthrough networks option in VPN -> IPsec -> Advanced Settings to prevent traffic being blackholed.
Firewall rules

When using the legacy tunnels and Disable Auto-added VPN rules is not checked in VPN ‣ IPsec ‣ Advanced Settings some automatic firewall rules are created for remote hosts connecting to this one. The new connections feature does not offer this and (WAN) rules have to be specified manually in order to connect to IPsec on this host.

The relevant protocols and ports for IPsec are the following:

    Protocol: ESP (https://en.wikipedia.org/wiki/IPsec#Encapsulating_Security_Payload)

    Port: 500/UDP (https://en.wikipedia.org/wiki/Internet_Security_Association_and_Key_Management_Protocol)

    Port: 4500/UDP (https://en.wikipedia.org/wiki/NAT_traversal#IPsec)

Note

One of the main reasons we are not offering automatic rules is that their either more open than expected (allow IPsec from anywhere) or too closed as the rule engine will “guess” the remote endpoint (in case of a fqdn).

The default behavior of our firewall is to block inbound traffic, which also means traffic using the tunnel should be allowed explicitly, the Firewall ‣ Rules ‣ IPsec menu items offer access to the IPsec traffic policies.
Dead Peer Detection (DPD)

Dead Peer Detection (DPD) is a method of detecting a dead IKE peer as specified by RFC 3706.

When a peer is assumed dead, an action may be specified, such as closing the CHILD_SA or re-negotiate the CHILD_SA under a fresh IKE_SA.

Note

DPD is disabled by default, when using connections, make sure to specify a DPD delay (s) > 0 to enable the feature. Actions may be specified on its children.

When using IKEv1 a dpdtimeout can be specified to control when a peer is considered to be inaccesible. This setting has no effect on how IKEv2 handles retransmissions, in which case the general settings will be used as specified in the following document.

Warning

By default for IKEv2 the timeout on connections triggering a dpd action takes at least a couple of minutes, when quicker interaction is needed the charon retransmit timings should be changed which applies to all tunnels. These settings can be changed via the Advanced settings, or when not yet supported on your version, a custom strongswan configuration.
Implementation schemes

When setting up IPsec VPNs there are two main types of scenario’s with their own advantages and disadvantages.
Policy based

The first one is the standard policy based tunnel, which guards the security of the tunnel with policies and installs kernel traps to send traffic over the tunnel in case it matches these policies. For example a local network 192.168.1.0/24 sending traffic to a remote location responsible for 192.168.2.0/24. The advantage of this scenario is the ease of setup, no routes are needed to be configured, when in this example 192.168.1.10 contacts 192.168.2.10 the packets are seamlessly forwarded over the tunnel to the remote location.

When local traffic doesn’t match the policies in question due to the tunnel needing Network Address Translation, that’s also possible as long as policies are manually added to the security policy database, this is also referred to as “NAT before IPsec”.
Route based (VTI)

Route based, also known as VTI, tunnels are using a virtual interface known as if_ipsec(4), which can be found under VPN -> IPsec -> Virtual Tunnel Interfaces. This links two ends of the communication for routing purposes after which normal routing applies. The “(Install) Policies” checkmark needs to be disabled in this case for the child (phase 1 in the legacy tunnel configuration) definition. Usually the communication policy (phase 2 or child) is set to match all traffic (either 0.0.0.0/0 for IPv4 or ::/0 for IPv6).

So the same example as the policy based option would need (static) routes for the destinations in question (192.168.1.0/24 needs a route to 192.168.2.0/24 and vice versa), peering happens over a small network in another subnet (for example 10.0.0.1 <-> 10.0.0.2) bound to the tunnel interface.

The advantage of this type of setup is one can use standard or advanced routing technologies to forward traffic around tunnels.

Note

In order to filter traffic on the if_ipsec(4) device some tunables need to be set. Both net.inet.ipsec.filtertunnel and net.inet6.ipsec6.filtertunnel need to be set to 1 and net.enc.in.ipsec_filter_mask and net.enc.out.ipsec_filter_mask need to be set to 0 in order to allow rules on the device. The downside is that policy based tunnels (enc0) can not be filtered anymore as this changes the behaviour from filtering on the enc0 device to the if_ipsec(4) devices.

Warning

Currently it does not seem to be possible to add NAT rules for if_ipsec(4) devices.

Warning

The most reliable VTI tunnel setups use static addresses on both ends of the tunnel as the if_ipsec(4) device matches both source and destination [#]. In recent versions of our product it is possible to auto-detect and reconfigure the tunnel on connect by keeping both local and remote addresses of the VTI empty in VPN ‣ IPsec ‣ Virtual Tunnel Interfaces.

Tip

Since VTI tunnels are bound to requestid’s it is important CHILD_SA’s are instantiated not more than once. To prevent duplicate children, configure Unique as Replace on the instance (advanced mode) and use a “trap” policy for the start action.
Road Warriors / Mobile users

IPsec may also be used to service remote workers connecting to OPNsense from various clients, such as Windows, MacOS, iOS and Android. The type of client usually determines the authentication scheme(s) being used.

In case clients should be offered default settings, these can be configured from VPN -> IPsec -> Mobile Clients. Pool options (Virtual IPvX Address Pool) on this page will be used by the legacy tunnel configuration only, when using the new connections module one may configure different pools per connection.

Note

If you are configuring Radius authentication using the new Connections module, make sure to select the relevant Radius servers in VPN -> IPsec -> Mobile Clients under Radius (eap-radius). This pool of servers will be shared across all connections. This option will not be visibile if you have legacy Radius authentication methods configured.

The examples section contains various options available in OPNsense. When using the new “connections” option available as of OPNsense 23.1, different examples from Strongswan are usually quite easy to implement as we follow the swantcl.conf format quite closely in the new module.
Examples

This paragraph offers examples for some commonly used implementation scenarios.
New > 23.1 (VPN -> IPsec -> Connections)

    IPsec - Policy based public key setup
    IPsec - Route based (VTI) PSK setup
    IPsec - NAT before IPsec
    IPsec - Roadwarriors IKEv2 EAP-MSCHAPv2

Tip

The number of examples for the new module on our end is limited, but for inspiration it’s often a good idea to walkthrough the examples provided by Strongswan. Quite some swanctl.conf examples are easy to implement in our new module as we do follow the same terminology.
Legacy (VPN -> IPsec -> Tunnel Settings)

    IPsec - Site to Site tunnel
    IPSec - BINAT (NAT before IPSec)
    IPsec VTI - Route based setup
    IPsec VTI - connect to Microsoft Azure
    Road Warriors - Setup Remote Access
        IPsec: Setup OPNsense for IKEv2 EAP-RADIUS
        IPsec: Setup OPNsense for IKEv2 EAP-TLS
        IPsec: Setup OPNsense for IKEv1 using XAuth
        IPsec: Setup OPNsense for IKEv2 EAP-MSCHAPv2
        IPsec: Setup OPNsense for IKEv2 Mutual RSA + MSCHAPv2

The following client setup examples are available in our documentation:

    IPsec: Setup Android Remote Access
    IPsec: Setup Linux Remote Access
    IPsec: Setup Windows Remote Access

Note

Using Network Address Translation in policy based tunnels is different, due to the fact that the installed IPsec policy should accept the traffic in order to encapsulate it. The IPSec BINAT document will explain how to apply translations.
CARP considerations

When using IPsec in a high availability setup, it is important to understand the implications of the setup. Without assuming what the remote gateway looks like (which may be a single device or a high availability setup as well), the following considerations should be taken into account:

    For IKEv2, MOBIKE should be disabled. Due to the nature of CARP, a virtual IP in backup state will “disappear”, which will trigger MOBIKE to try to re-establish the connection from a different available IP, thus overriding your “Local address” configuration. In a lot of cases this will be the primary IP of the WAN interface.

    In all cases (initiator, responder or both) the “Local Address” must be set to a CARP virtual IP.

    DPD must at least be configured on the peer to detect a non-responsive peer and reauthenticate the connection. DPD is usually the limiting factor in failover response time and is therefore the primary functionality to adjust to allow for faster failover. See the DPD section for more information and constraints.

    IPsec connections never failover seamlessly between primary and backup and always need a fresh IKE_SA. If quicker failover is required, dynamic routing with route-based tunnels is likely a better solution.

Tuning considerations

Depending on the workload (many different IPsec flows or a single flow), it might help to enable multithreaded crypto mode on ipsec, in which case cryptographic packets are dispatched to multiple processors (especially when only a single tunnel is being used).

In order to do so, add or change the following tunable in System ‣ Settings ‣ Tunables:

Note

net.inet.ipsec.async_crypto = 1

To distribute load better over available cores in the system, it may help to enable receive side scaling. In which case the following tunables need to be changed:

Note

    net.isr.bindthreads = 1

    net.isr.maxthreads = -1 <– equal the number of cores in the machine

    net.inet.rss.enabled = 1

    net.inet.rss.bits = X <– see rss document.

Miscellaneous variables
Path MTU Discovery

When trying to enforce path mtu discovery (PMTU), you need to make sure packets leave the network with the DF set. The kernel offers a tunable net.inet.ipsec.dfbit which offers 3 options, 0, clear the bit on packets leaving the firewall (default), 1, set the DF bit or 2 to copy the bit from the inner header.
Diagnostics

In order to keep track of the connected tunnels, you can use the VPN -> IPsec -> Status Overview to browse through the configured tunnels.

The VPN -> IPsec -> Security Policy Database is also practical to gain insights in the registered policies, when NAT is used, the additional SPD entries should be visible here as well.

When troubleshooting problems with your firewall, it is very likely you have to check the logs available on your system. In the UI of OPNsense, the log files are generally grouped with the settings of the component they belong to. The log files can be found in the “Log file” menu item.

Tip

When trying to debug various issues, the amount of log information gathered can be configured using the settings in VPN -> IPsec -> Advanced Settings.
Custom configurations

In some (rare) cases one might want to add custom configuration options not available in the user interface, for this reason we do support standard includes.

While the swanctl.conf and the legacy ipsec.conf configuration files are well suited to define IPsec-related configuration parameters, it is not useful for other strongSwan applications to read options from these files. To configure these other components, it is possible to manually append options to our default template, in which case files may be placed in the directory /usr/local/etc/strongswan.opnsense.d/ using the file extention .conf

IPsec configurations are managed in swantcl.conf format (as of 23.1), merging your own additions is possible by placing files with a .conf extension in the directory /usr/local/etc/swanctl/conf.d/.

Warning

Files added to these directories will not be mainted by the user interface, if you’re unsure if you need this, it’s likely a good idea to skip adding files here as it might lead to errors difficult to debug.

Note

Prior to version 23.1 it was also possible to add secrets and ipsec configurations in /usr/local/etc/ipsec.secrets.opnsense.d/ and /usr/local/etc/ipsec.opnsense.d/, with the switch to 23.1 these files are deprecated and should be manually migrated into swanctl.conf format.
OpenVPN (SSL VPN)

One of the main advantages of OpenVPN in comparison to IPsec is the ease of configuration, there are fewer settings involved and it’s quite simple to export settings for clients.
General context

The OpenVPN module incorporates different functions to setup secured networks for roadwarriors and side to side connections. Since the start of our project we organized the openvpn menu section into servers and clients, which actually is a role for the same OpenVPN process. As our legacy system has some disadvantages which are difficult to fix in a migration, we have chosen to add a new component named Instances in version 23.7 which offers access to OpenVPN’s configuration in a similar way as the upstream documentation describes it. This new component will eventually replace the existing client and server options in a future version of OPNsense, leaving enough time to migrate older setups.

Tip

When upgrading into a new major version of OPNsense, always make sure to read the release notes to check if your setup requires changes.

Note

OpenVPN on OPNsense can also be used to create a tunnel between two locations, similar to what IPsec offers. Generally the performance of IPsec is higher which usually makes this a less common choice. Mobile usage is really where OpenVPN excells, with various (multifactor) authentication options and a high flexibility in available network options.

The following functions are available in the menu (as of OPNsense 23.7):

    Instances

        New instances tool offering access to server and client setups

    Servers

        Legacy server configuration tool

    Clients

        Legacy client configuration tool

    Client Specific Overrides

        Set client specific configurations based on the client’s X509 common name.

    Client Export

        Export tool for client configurations, used for server type instances

    Connection Status

        Show tunnel statusses

    Log File

        Inspect log entries related to OpenVPN

Public Key Infrastructure (X.509)

OpenVPN is most commonly used in combination with a public key infrastructure, where we use a certificate autority which signs certificates for both server and clients (Also know as TLS Mode). More information about this topic is available in our Trust section.

Tip

As of version 24.1 OPNsense is able to use OCSP to validate client certificates when using the new Instances. Make sure Use OCSP (when available) is enabled in the trust section of the server instance and the CA used contains a proper AuthorityInfoAccess extension as described in our Trust section.
Firewall rules

To allow traffic to the tunnel on any interface, a firewall rule is needed to allow the tunnel being established. The default port for OpenVPN is 1194 using protocol UDP.

After communication has been established, it’s time to allow traffic inside the tunnel. All OpenVPN interfaces defined in OPNsense are grouped as OpenVPN.

Tip

In order to use features as policy based routing or manual routes, you can assign the underlying devices and use them in a similar fashion as physical interfaces.
High availability [CARP]

When operating an OpenVPN server, there’s not much needed to allow an active/passive setup for your environment other then using a virtual (CARP) address. As the server will stop receiving traffic when the virtual address doesn’t it, the backup will eventually become out of service automatically.

In client mode, the OpenVPN instance needs to stop trying to reconnect when it’s not in MASTER mode, the legacy client module shutsdown all instances directly attached to the interface. Our new instances module allows to select the vhid to track. In most cases an explicit bind isn’t needed for a client, the default for a client is to use the nobind option.

Note

It’s not possible to move between machines fully seamless as the client will have to reconnect in order to reach a valid state again.
Examples

This paragraph offers examples for some commonly used implementation scenarios.

Note

When using a site to site example with SSL/TLS instead of a shared key, make sure to configure “client specific overrides” as well to correctly bind the remote networks to the correct client.
Legacy (VPN -> OpenVPN -> Client|Server)

    Setup SSL VPN site to site tunnel
    Setup SSL VPN Road Warrior

New (VPN -> OpenVPN -> Instances)

    Setup SSL VPN site to site tunnel
    Setup SSL VPN Road Warrior

Client Specific Overrides

The mechanism of client overrides utilises OpenVPN client-config-dir option, which offer the ability to use specific client configurations based on the client’s X509 common name.

It is possible to specify the contents of these configurations in the gui under VPN -> OpenVPN -> Client Specific Overrides. Apart from that, an authentication server (System -> Access -> Servers) can also provide client details in special cases when returning Framed-IP-Address, Framed-IP-Netmask and Framed-Route properties.

Note

Client specific overwrites will be written after authentication or client connect (depending on the type of setup). This in order for authentication services like RADIUS to be able to provision additional properties, such as tunnel and local networks.

A selection of the most relevant settings can be found in the table below.
Client Specific Overrides

Parameter
	

Purpose

Disabled
	

Set this option to disable this client-specific override without removing it from the list

Servers
	

Select the OpenVPN servers where this override applies to, leave empty for all

Common name
	

The client’s X.509 common name, which is where this override matches on

IPv[4|6] Tunnel Network
	

The tunnel network to use for this client per protocol family, when empty the servers will be used

IPv[4|6] Local Network
	

The networks that will be accessible from this particular client per protocol family.

IPv[4|6] Remote Network
	

These are the networks that will be routed to this client specifically using iroute, so that a site-to-site VPN can be established.

Redirect Gateway
	

Force the clients default gateway to this tunnel

Note

When configuring tunnel networks, make sure they fit in the network defined on the server tunnel itself to allow the server to send data back to the client. For example in a 10.0.0.0/24 network you are able to define a client specific one like 10.0.0.100/30.

To reduce the chances of a collision, also make sure to reserve enough space at the server as the address might already be assigned to a dynamic client otherwise.

Tip

When using topology “subnet” the netmask usually equals the one defined in the instance itself as the gateway being pushed to the client is the first adress in the network and otherwise unreachable.

Troubleshooting common issues

The most common causes for non functional overwrites are caused by mismatches, in order to debug these, make sure to check the logs for messages like the following:

    Locate overwrite for 'XXX' using server 'XXX' (vpnid: XXX) << trying to find an overwrite (user authentication))

        Usually followed by user 'XXX' authenticated using 'XXX' XXX showing username, authenticator used and optionally the overwrite type and filename.

    client config created @ XXX << file written on client connect (without user authentication)

    unable to write client config for XXX, missing target filename << no matching overwrite found (without user authentication)

By default overwrites are matched by certificate common name, when Force CSO Login Matching (legacy) or Username as CN (instances) are set the username will be used instead.
Wireguard
General context

WireGuard® is a simple yet fast and modern VPN solution, which in some cases is more convenient than IPsec or OpenVPN, certainly in terms of options you need to configure. In our experience IPsec is the fastest solution for site-to-site connections, but Wireguard is the simplest option to setup.

A wireguard setup on our end exists of the following main components:

    Instances: in the wireguard configuration these are called “interfaces” and they describe how the virtual wgX device on our end is configured in terms of addressing and cryptography.

    Peers: these are the clients that are allowed to connect to us, described by their optional remote address including the networks that are allowed to pass through the tunnel. Peers belong to one or more instances.

Instances

In order to configure an instance, we start by adding one in the gui and generate a keypair. The public key is usually required for the other end of the tunnel (peer). An unused port to listen on is required as well. The tunnel addresses are configured on the wgX device (which is always visible in Interfaces ‣ Overview).

By default, when “Disable routes” is not set, routes are created for each connected peer to the networks selected in “Allowed IPs”, optionally only a single gateway route might be configured as well.

Note

When choosing tunnel addresses, make sure the network defined includes the addresses being used by the peers. For example when choosing 10.10.0.1/24 the wgX instance has this address configured and is able to accept a peer using 10.10.0.2/32.

Tip

Remember to create a firewall rule to allow traffic to the configured port and inside the tunnel.
Peers

Peers define the hosts that we exchange information with, which might be a road-warrior type or a static destination, in which case you either provide or omit an “Endpoint Address and Port”. At minimum you need the public key of the other party, optionally you may offer a pre-shared key as additional security measure. The “Allowed IPs” define the networks that are allowed to pass the tunnel.

Note

In most cases the “Allowed IPs” list contains the networks used on the remote host and the peer ip address (instance/tunnel address) configured on the other end.

Tip

When NAT and firewall traversal persistence is required, the :code:` Keepalive interval` can be used to exchange packets every defined interval ensuring states will not expire.
Peer generator

When creating login credentials for multiple clients, a more practical method is also available to generate these. The peer generator offers you a simple selection for the instance you wish to generate credentials for and stores relevant fields like endpoint location for future use. It also helps to assign IP addresses to clients based on the network defined in the instance.

Warning

Since IP addresses are only stored when the user saves the profile (and calculated upfront), it’s not possible to create users for the same instance concurrently.

Each newly created client will receive a keypair, for which the public key will be stored on the firewall in the peers section.

Note

The private key will not be stored on the firewall as this only belongs to the device your installing the profile on. Regenerating a config file, automatically means you will need to import it again in the client as well to avoid trust being broken.

After providing the relevant information for the client to login, you can copy the qrcode or the text in the Config text box to configure the client.

Don’t forget to press the “Store and generate next” button to actually store the public information in the firewall so the client is able to login.
High availability (using CARP)

When using wireguard on active/passive high availability clusters, only one instance at a time is allowed to communicate to the other party. In OPNsense this can be reached by selecting a vhid to track as instance dependancy {Depend on (CARP)}.

If an instance depends on a CARP vhid, it will query the current status and determine if the interface should be usable (when MASTER), the interface status (up/down) will be toggled accordingly.

Note

As the interface itself will not change, all of its addresses and routes remain when not being active. This ensures a relatively quick switch between roles.

Tip

Because the carp dependancy is managed per instance, you are able to keep tunnels available selectively, for example to manage the machines remotely.
Diagnostics and debugging

In VPN ‣ WireGuard ‣ Status you can find the configured instances and peers including their last known handshake and the amount of data being exchanged. For Instances you are also able to see if the device underneath (wgX) is up or down, depending on the carp status described in the previous chapter.

Tip

Althought wireguard itself offers very limit logging, our setup process will make a note of errors and signal about certain events. When having issues configuring an instance or peer, always make sure to check the logs in VPN ‣ WireGuard ‣ Log File first.

Warning

When having issues exchanging packets between both ends of the tunnel, always make sure to check if the “Allowed IPs” in the peer configurations contain the proper networks. In case traffic is not allowed when traveling in, its dropped silently (a capture will not show it), roughly the same happens when traveling out, a capture will show it, but nothing will be send out.

Note

Runtime debugging from the console is possible using the ifconfig command, for more information see the upstream manual page
Examples

This paragraph offers examples for some commonly used implementation scenarios.

    WireGuard Site-to-Site Setup
    WireGuard Road Warrior Setup
    WireGuard AzireVPN Road Warrior Setup
    WireGuard MullvadVPN Road Warrior Setup
    WireGuard ProtonVPN Road Warrior Setup
    WireGuard Selective Routing to External VPN Endpoint

Plugin VPN options

Via plugins additional VPN technologies are offered, including:

    OpenConnect - SSL VPN client, initially build to connect to commercial vendor appliances like Cisco ASA or Juniper.

    Stunnel - Provides an easy to setup universal TLS/SSL tunneling service, often used to secure unencrypted protocols.

    Tinc - Automatic Full Mesh Routing

    WireGuard - Simple and fast VPN protocol working with public and private keys.

    Zerotier - seamlessly connect everything, requires account from zerotier.com, free for up to 100 devices.

    OpenConnect Setup
    Stunnel
    Zerotier Configuration


IPsec - Policy based public key setup

This example utilises the new options available in OPNsense 23.1 to setup a site to site tunnel in policy mode between two OPNsense machines using key pairs.

Index

    IPsec - Policy based public key setup

        Network topology

        Preparations

            Key pairs

        Setting up the IPsec connection

            General settings

            Authentication

            Children

            Save and apply

        Validate

        Install firewall policies

Network topology

The schema below describes the situation we are implementing. Two networks (A,B) and a transit network (10.10.1.0/24) to peer both firewalls.
Preparations

Since our policy based setup doesn’t require interfaces, gateways and routes, we only need to make sure the IPsec module is enabled on the Connections tab and Key pairs are registered for both hosts.
Key pairs

Go to the VPN->IPsec->Key Pairs option in the menu and create a new key on both hosts, then copy the public part from Site A to Site B and vise versa. Keys may easily be generated with the gear button in the Key type field.
Setting up the IPsec connection

In order to setup a simple (and common) IPsec connection, we go to VPN->IPsec->Connections and add a new entry.
General settings

Side by side the following general settings need to be set in this case, which configures the first part of the security association between both sites:

Property
	

site A
	

site B

Local addresses
	

10.10.1.1
	

10.10.1.2

Remote addresses
	

10.10.1.2
	

10.10.1.1

Press <save> to go to the next step.

Note

One may omit the local address if any address may be used to initiate the connection from, other valid options are also mentioned in the help text of the attribute.
Authentication

Next we will need to add local authentication (add a new record in the local grid):

Property
	

site A
	

site B

Authentication
	

Public Key
	

Public Key

Id
	

hostA
	

hostB

Public Keys
	

hostA-key
	

hostB-key

Then we need to set Pre-Shared Key for remote authentication as well:

Property
	

site A
	

site B

Authentication
	

Public Key
	

Public Key

Id
	

hostB
	

hostA

Public Keys
	

hostB-key
	

hostA-key

Note

On host A the private key for Host A should be known and only the public key of Host B, Host B is exactly the oposite.
Children

Finally we may add a child which will add security policies and kernel routes.

Property
	

site A
	

site B

Mode
	

Tunnel
	

Tunnel

Policies
	

[checked]
	

[checked]

Local
	

192.168.1.0/24
	

10.0.1.0/24

Remote
	

10.0.1.0/24
	

192.168.1.0/24
Save and apply

Finally save the settings and hit apply on the connections page to establish the tunnel.
Validate

Now can check if the tunnel is active on both side using the status overview in VPN->IPsec->Status Overview
Install firewall policies

With the tunnel active, all that remains is to accept traffic on this tunnel using the Firewall->Rules->IPsec menu option.


IPsec - Route based (VTI) PSK setup

This example utilises the new options available in OPNsense 23.1 to setup a site to site tunnel in routed mode between two OPNsense machines using a pre shared key.

Index

    IPsec - Route based (VTI) PSK setup

        Network topology

        Preparations

            Interface

            Enable IPsec

        Setting up the IPsec connection

            General settings

            Authentication

            Children

            Save and apply

            Gateways

            Routes

        Validate

        Install firewall policies

Network topology

The schema below describes the situation we are implementing. Two networks (A,B) and a transit network (10.10.1.0/24) to peer both firewalls. We will create a tunnel network using 192.168.123.1 [A] and 192.168.123.2 [B].
Preparations
Interface

In order to define our IPsec tunnel we do need to define a virtual tunnel interface (VPN->IPsec->Virtual Tunnel Interfaces) first. The purpose of this device is to attach a tunnel to a security policy defined by its request id (reqid).

On both sites A and B we will add VTIs using the following parameters:

Property
	

site A
	

site B

Reqid
	

10
	

10

Local address
	

10.10.1.1
	

10.10.1.2

Remote address
	

10.10.1.2
	

10.10.1.1

Tunnel local address
	

192.168.123.1
	

192.168.123.2

Tunnel remote address
	

192.168.123.2
	

192.168.123.1

Note

Reqid should be a unique number within all configured if_ipsec(4) tunnels. The number 10 is arbitrary
Enable IPsec

Before configuring the connections, we enable the IPsec module. Just mark the “enable” checkbox on the connections tab.
Setting up the IPsec connection

In order to setup a simple (and common) IPsec connection, we go to VPN->IPsec->Connections and add a new entry.
General settings

Side by side the following general settings need to be set in this case, which configures the first part of the security association between both sites:

Property
	

site A
	

site B

Local addresses
	

10.10.1.1
	

10.10.1.2

Remote addresses
	

10.10.1.2
	

10.10.1.1

Unique (advanced)
	

Replace
	

Replace

Press <save> to go to the next step.
Authentication

Next we will need to add local authentication (add a new record in the local grid):

Property
	

site A
	

site B

Authentication
	

Pre-Shared Key
	

Pre-Shared Key

Id
	

hostA
	

hostB

Then we need to set Pre-Shared Key for remote authentication as well:

Property
	

site A
	

site B

Authentication
	

Pre-Shared Key
	

Pre-Shared Key

Id
	

hostB
	

hostA

Note

Secrets for both ends need to be added to “VPN->IPsec->Pre-Shared Keys”, site A needs a secret set for local identifier hostB. Optionally one may also set a second (remote) identifier in which case the secret belongs to these two identifiers.
Children

Finally we may add a child which will add security policies. Since our VTI tunnel matches on all traffic, both Site A and B use the same configuration which looks like this:

Mode
	

Tunnel

Reqid
	

10

Policies
	

[uncheck]

Local
	

0.0.0.0/0

Remote
	

0.0.0.0/0

Start action
	

Trap

Warning

Make sure no policies are installed, when missing a passthrough and having policies installed one would not be able to access the firewall anymore as traffic will be trapped inside the tunnel.
Save and apply

Finally save the settings and hit apply on the connections page to establish the tunnel.
Gateways

Next step on both ends is to define a gateway (System->Gateways->Configuration) which reaches the other end of this channel, the interface should be automatically created and is called ipsec10 in this example.

Both ends will need a gateway pointing at each other : Site A will need the following gateway:

Property
	

site A
	

site B

Name
	

IPSEC10_GW
	

IPSEC10_GW

Interface
	

IPSEC10
	

IPSEC10

Address Family
	

IPv4
	

IPv4

IP address
	

192.168.123.2
	

192.168.123.1
Routes

We may already prepare the routes as the interfaces and gateways are available in System->Routes->Configuration.

On Site A we need to define a path to Site B and the other way around:

Property
	

site A
	

site B

Network Address
	

10.0.2.0/24
	

192.168.2.0/24

Gateway
	

IPSEC10_GW
	

IPSEC10_GW
Validate

Now can check if the tunnel is active on both side using the status overview in VPN->IPsec->Status Overview
Install firewall policies

With the tunnel active, all that remains is to accept traffic on this tunnel using the Firewall->Rules->IPsec menu option.


IPsec - NAT before IPsec

Index

    IPsec - NAT before IPsec

        Network topology

        Preparations

        Add manual security policies

        Configure NAT

Network topology

The schema below describes the situation we are implementing. Two networks (A,B) to peer both firewalls, where the Ipsec policy includes 10.1.0.0/24 <-> 192.168.1.0/24, but locally side A uses 10.99.0.0/24.

How to setup the tunnel itself is explained in the IPsec - Policy based public key setup document.
Preparations

Make sure the tunnel is up and running before trying out the NAT part, then edit the child entry and input a Reqid there which isn’t used in any of the other tunnels. For this example we choose 100 here.

Note

It’s imperative to choose a static number here in order to be able to bind policies to the current tunnel.
Add manual security policies

In order for IPsec to trust the local network (10.99.0.0/24) a manual policy needs to be added, go to the “Manual” tab in VPN->IPsec->Security Policy Database. Next add a new entry containing the following items:

Property
	

site A

Reqid
	

100

Source network
	

10.0.99.0/24

Tip

When the “Destination network” is left empty, the other end (in this case 192.168.1.0/24) will be received from the tunnel. In case multiple networks exist in the same child policy it’s better to define which one this entry belongs too.

Tip

After changing manual security policies, make sure the tunnel is reconnected (restart or disconnect and connect) as the registration is being arranged using an updown event

Note

Some scenario’s require multiple clients being connected to the same “child” (such as mobile), when the other end pushes it’s network (destination), it is possible to hook to the correct connection by connecting the manual policy directly to the connection child. In these cases the reqid is dynamic (leave blank) in the connection child. The “Child” option can be used for these manual policies.
Configure NAT

To map the networks, we will use a one to one rule created from the Firewall->NAT->One-to-One menu option. The following settings apply here:

Property
	

site A
	

Notes

Interface
	

IPsec
	

Type
	

BINAT
	

Two way mapping

External network
	

10.1.0.0
	

As defined in the child connection

Source
	

10.99.0.0/24
	

The local network

Destination
	

192.168.1.0/24
	

The remote network

Note

When using BINAT all networks need to be equally sized (/24 in this case)


IPsec - Roadwarriors IKEv2 EAP-MSCHAPv2

Index

    IPsec - Roadwarriors IKEv2 EAP-MSCHAPv2

        Networks used in this How-To section

        Methods for Roadwarrior Setup

            Method 1 - Shared IP pool for all roadwarriors

            Method 2 - Static IP address per roadwarrior

        Prerequisites

            System: Trust: Authorities

            System: Trust: Certificates

            External DNS Records

            Firewall: Aliases

            Firewall: Rules: WAN

            Update your Firewall

        Method 1 - Shared IP pool for all roadwarriors

            1.1 - VPN: IPsec: Connections: Pools

            1.2 - VPN: IPsec: Pre-Shared Keys

            1.3 - VPN: IPsec: Connections

        Method 2 - Static IP address per roadwarrior

            2.1 - VPN: IPsec: Connections: Pools

            2.2 - VPN: IPsec: Pre-Shared Keys

            2.3 - VPN: IPsec: Connections

        Firewall rules, Outbound NAT and DNS

            Firewall: Aliases

            Firewall: Rules: IPsec

            Firewall: NAT: Outbound

            Services: Unbound DNS

        Client configuration

            Windows 10/11 native VPN client

            iOS native VPN client

            Android StrongSwan VPN client

            Windows/macOS NCP Secure Entry client

        Troubleshooting

The following roadwarrior configuration is universally usable for many different clients and easy to setup.

EAP-MSCHAPv2 via IKEv2 is based on a server certificate and an EAP Pre-Shared Key (username + password). The CA certificate has to be installed on the users device.
Networks used in this How-To section

Interface
	

Network IPv4
	

Network IPv6

WAN
	

203.0.113.0/24
	

2001:db8:1234::/48

LAN
	

192.168.1.0/24
	

2001:db8:1234:1::/64

IPsec
	

172.16.203.0/24
	

2001:db8:1234:ec::/64

The example users are John and Laura. The example FQDN is vpn1.example.com.

Hint

Any IPv6 functionality is optional. If you don’t want to use IPv4+IPv6 dual stack, just skip all IPv6 addresses/networks and focus on IPv4.

Note

    IPv6 transport with UDP encapsulation of ESP packets is supported by OPNsense 24.7 with the FreeBSD 14 kernel.

    When using OPNsense 24.1 or below it is currently not possible to use IPv6 as outer tunnel transport address. IPsec requires UDP encapsulation of ESP packets for most mobile clients. UDP encapsulation and decapsulation for IPv6 is unsupported by the FreeBSD 13 Kernel.

Warning

    Don’t copy security relevant configuration parameters like passwords into your configuration. Create your own!

    Change all IP addresses, usernames and DNS Records to your own usecase.

Methods for Roadwarrior Setup
Method 1 - Shared IP pool for all roadwarriors

    Benefit: Easy configuration and works with most clients out of the box.

    Drawback: All configured EAP Identities can authenticate with this connection, so you can’t have tight access control. Roadwarriors don’t have unique IP addresses.

Method 2 - Static IP address per roadwarrior

    Benefit: Tight security because every user can be controlled individually with firewall rules.

    Drawback: Configuration needs more time and might not scale with large user counts. Windows native VPN client doesn’t like this configuration since it demands the eap identity exchange method eap id = %any.

Prerequisites

Attention

In all following examples, parameters that should be empty or at default are omitted. Don’t change them without a good reason.
System: Trust: Authorities

Create a certificate authority which will be used to create server certificates for your IPsec VPN. The lifetime of the CA is 10 years, if it expires you have to deploy new CA certificates to all clients.

    Descriptive name:
    	

    IPsec CA

    Method:
    	

    Create an internal Certificate Authority

    Key Type:
    	

    RSA

    Key length (bits):
    	

    2048

    Digest Algorithm:
    	

    SHA256

    Lifetime (days):
    	

    3650

    Country Code:
    	

    Enter your Country Code

    State or Province:
    	

    Enter Your State

    City:
    	

    Enter your City

    Organization:
    	

    Enter your Organization

    Email Address:
    	

    Enter your Email address

    Common Name:
    	

    IPsec CA

Download this CA certificate and save it for later, it’s needed for client setup.
System: Trust: Certificates

Create a server certificate for your IPsec VPN. The lifetime of the certificate is 1 year, if it expires you have to renew the certificate on the OPNsense or your clients can’t connect anymore.

    Method:
    	

    Create an internal Certificate

    Descriptive name:
    	

    vpn1.example.com

    Certificate authority:
    	

    IPsec CA

    Type:
    	

    Server Certificate

    Key Type:
    	

    RSA

    Key lenght (bits):
    	

    2048

    Digest Algorithm:
    	

    SHA256

    Lifetime (days):
    	

    365

    Country Code:
    	

    Enter your Country Code

    State or Province:
    	

    Enter Your State

    City:
    	

    Enter your City

    Organization:
    	

    Enter your Organization

    Email Address:
    	

    Enter your Email address

    Common Name:
    	

    vpn1.example.com

    Alternative Names:
    	

    Type DNS: vpn1.example.com

External DNS Records

Your OPNsense Firewall has the example IP Subnets 203.0.113.0/24 and 2001:db8:1234::/48. The FQDN can point to any bindable IPv4 and IPv6 address in those subnets. It will be used by clients to connect to the IPsec VPN Server - and by the OPNsense to bind the local listen address.

    Create an A-Record with your external DNS provider, for example vpn1.example.com in A 203.0.113.1

    Create an AAAA-Record, for example vpn1.example.com in AAAA 2001:db8:1234::1

Firewall: Aliases

Create an alias for the IP addresses of your FQDN. That way you can create a combined IPv4/IPv6 rule to allow incoming connections to your IPsec VPN server.

    Name:
    	

    host_vpn1_example_com

    Type:
    	

    Host(s)

    Content:
    	

    203.0.113.1 2001:db8:1234::1

    Description:
    	

    Host vpn1.example.com

Create an alias for the UDP ports used by IPsec. Port 500 is ISAKMP and port 4500 is IPsec NAT-T.

    Name:
    	

    port_ipsec_500_4500

    Type:
    	

    Port(s)

    Content:
    	

    500 4500

    Description:
    	

    Ports IPsec 500 and 4500

Firewall: Rules: WAN

Since this roadwarrior configuration will use UDP encapsulation, the ESP packets will be encapsulated inside UDP packets. That’s why you don’t need a rule to allow the ESP protocol. You only need a firewall rule to allow UDP 500 and UDP 4500. Use the aliases you created in the prior step.

    Action
    	

    Pass

    Interface
    	

    WAN

    Direction
    	

    In

    TCP/IP Version
    	

    IPv4+IPv6

    Protocol
    	

    UDP

    Source
    	

    Any

    Source port
    	

    Any

    Destination
    	

    host_vpn1_example_com

    Destination port
    	

    port_ipsec_500_4500

    Description
    	

    Allow IPsec UDP ports from ANY source to this firewall

Update your Firewall

Update your OPNsense at least to Version 23.7.4, that’s the version that introduced EAP id: %any which is used in Method 1. If you stay on a lower Version, you can only configure Method 2.

Note

    Now that the Prerequisites have been met, you can choose where to continue:

    Method 1 - Shared IP pool for all roadwarriors

    Method 2 - Static IP address per roadwarrior

Attention

    Don’t create both methods on your OPNsense at the same time, it’s a potential security risk.

    Only create one connection where you use EAP id: %any (Method 1). If you create multiples of these connections, any roadwarrior can connect to any of them.

Method 1 - Shared IP pool for all roadwarriors
1.1 - VPN: IPsec: Connections: Pools

Create an IPv4 pool that all roadwarriors will share. This configuration will result in 256 usable IPv4 addresses. Please note that this is not a network, it’s a pool of IP addresses that will be leased. The DNS Server(s) will be pushed as Configuration Payload (RFC4306 and RFC7296 3.15). In this example they represent the Unbound Server of the OPNsense.

    Name:
    	

    pool-roadwarrior-ipv4

    Network:
    	

    172.16.203.0/24

    DNS:
    	

    192.168.1.1

Create an IPv6 pool that all roadwarriors will share. This configuration will result in 256 usable IPv6 addresses.

    Name:
    	

    pool-roadwarrior-ipv6

    Network:
    	

    2001:db8:1234:ec::/120

    DNS:
    	

    2001:db8:1234:1::1

Note

The IPv6 pool is not a /64 Prefix, because it’s used to define a pool of IPv6 addresses that can be used as leases. Prefix /120 means there are 256 IPv6 addresses available. The hard limit of StrongSwan pools is Prefix /97.

Note

You can skip the DNS field if you don’t want to push DNS Servers to your clients.
1.2 - VPN: IPsec: Pre-Shared Keys

Create EAP Pre-Shared Keys. The local identifier is the username, and the Pre-Shared Key is the password for the VPN connection.

    Local Identifier:
    	

    john@vpn1.example.com

    Pre-Shared Key:
    	

    48o72g3h4ro8123g8r

    Type:
    	

    EAP

    Local Identifier:
    	

    laura@vpn1.example.com

    Pre-Shared Key:
    	

    LIUAHSDq2nak!12

    Type:
    	

    EAP

Note

Instead of john@vpn1.example.com you can use any string as local identifier, for example only john. If you have multiple VPN servers, the FQDN makes it easier to know which one the user is assigned to.
1.3 - VPN: IPsec: Connections

    Enable IPsec with the checkbox at the bottom right and apply.

    Press + to add a new Connection, enable advanced mode with the toggle.

General Settings:

    Proposals:
    	

    aes256-sha256-modp2048 (Disable default!)

    Version:
    	

    IKEv2

    Local addresses:
    	

    vpn1.example.com

    UDP encapsulation:
    	

    X

    Rekey time:
    	

    2400

    DPD delay:
    	

    30

    Pools:
    	

    pool-roadwarrior-ipv4 pool-roadwarrior-ipv6

    Keyingtries:
    	

    0

    Description:
    	

    roadwarrior-eap-mschapv2-p1

Save to reveal the next options:

Local Authentication:

    Round:
    	

    0

    Authentication:
    	

    Public Key

    Id:
    	

    vpn1.example.com

    Certificates:
    	

    vpn1.example.com

    Description:
    	

    local-vpn1.example.com

Remote Authentication:

    Round:
    	

    0

    Authentication:
    	

    EAP-MSCHAPv2

    EAP Id:
    	

    %any

    Description:
    	

    remote-eap-mschapv2

Children:

Press + to add a new Child, enable advanced mode with the toggle.

    Start action:
    	

    Trap

    ESP proposals:
    	

    aes256-sha256-modp2048 (Disable default!)

    Local:
    	

    0.0.0.0/0 ::/0

    Rekey time (s):
    	

    600

    Description:
    	

    roadwarrior-eap-mschapv2-p2

Save and Apply the configuration.

Note

With children you select the networks your roadwarrior should be able to access. In a split tunnel scenario, you would specify the example LAN nets 192.168.1.0/24 and 2001:db8:1234:1::/64 as local traffic selectors. In a full tunnel scenario (all traffic forced through the tunnel) you would specify 0.0.0.0/0 and ::/0 as local traffic selectors. The following example child will use the full tunnel method. A full tunnel is generally more secure - especially with IPv6 involved - since no traffic can leak.

Now you can skip to Firewall rules, Outbound NAT and DNS
Method 2 - Static IP address per roadwarrior
2.1 - VPN: IPsec: Connections: Pools

Create an individual IPv4 pool for each roadwarrior. This configuration will result in 1 usable IPv4 address. The DNS Server(s) will be pushed as Configuration Payload (RFC4306 and RFC7296 3.15). In this example they represent the Unbound Server of the OPNsense.

    Name:
    	

    pool-roadwarrior-john-ipv4

    Network:
    	

    172.16.203.1/32

    DNS:
    	

    192.168.1.1

    Name:
    	

    pool-roadwarrior-laura-ipv4

    Network:
    	

    172.16.203.2/32

    DNS:
    	

    192.168.1.1

Create an individual IPv6 pool for each roadwarrior. This configuration will result in 1 usable IPv6 address.

    Name:
    	

    pool-roadwarrior-john-ipv6

    Network:
    	

    2001:db8:1234:ec::1/128

    DNS:
    	

    2001:db8:1234:1::1

    Name:
    	

    pool-roadwarrior-laura-ipv6

    Network:
    	

    2001:db8:1234:ec::2/128

    DNS:
    	

    2001:db8:1234:1::1

Note

If a roadwarrior has more than one device, you can provide them a larger pool. For example /31 would result in 2 IPv4 addresses, and /127 in 2 IPv6 addresses. You will have to keep track of this yourself though, don’t configure pools that overlap.

Note

You can skip the DNS field if you don’t want to push DNS Servers to your clients.
2.2 - VPN: IPsec: Pre-Shared Keys

Create EAP Pre-Shared Keys. The local identifier is the username, and the Pre-Shared Key is the password for the VPN connection.

    Local Identifier:
    	

    john@vpn1.example.com

    Pre-Shared Key:
    	

    48o72g3h4ro8123g8r

    Type:
    	

    EAP

    Local Identifier:
    	

    laura@vpn1.example.com

    Pre-Shared Key:
    	

    LIUAHSDq2nak!12

    Type:
    	

    EAP

Note

Instead of john@vpn1.example.com you can use any string as local identifier, for example only john. If you have multiple VPN servers, the FQDN makes it easier to know which one the user is assigned to.
2.3 - VPN: IPsec: Connections

    Enable IPsec with the checkbox at the bottom right and apply.

2.3.1 Create connection for john@vpn1.example.com:

    Press + to add a new Connection, enable advanced mode with the toggle.

General Settings:

    Proposals:
    	

    aes256-sha256-modp2048 (Disable default!)

    Version:
    	

    IKEv2

    Local addresses:
    	

    vpn1.example.com

    UDP encapsulation:
    	

    X

    Rekey time:
    	

    2400

    DPD delay:
    	

    30

    Pools:
    	

    pool-roadwarrior-john-ipv4 pool-roadwarrior-john-ipv6

    Keyingtries:
    	

    0

    Description:
    	

    roadwarrior-john-eap-mschapv2-p1

Save to reveal the next options:

Local Authentication:

    Round:
    	

    0

    Authentication:
    	

    Public Key

    Id:
    	

    vpn1.example.com

    Certificates:
    	

    vpn1.example.com

    Description:
    	

    local-vpn1.example.com

Remote Authentication:

    Round:
    	

    0

    Authentication:
    	

    EAP-MSCHAPv2

    EAP Id:
    	

    john@vpn1.example.com

    Description:
    	

    remote-john-eap-mschapv2

Children:

Press + to add a new Child, enable advanced mode with the toggle.

    Start action:
    	

    Trap

    ESP proposals:
    	

    aes256-sha256-modp2048 (Disable default!)

    Local:
    	

    0.0.0.0/0 ::/0

    Rekey time (s):
    	

    600

    Description:
    	

    roadwarrior-john-eap-mschapv2-p2

Save and Apply the configuration.

Note

With children you select the networks your roadwarrior should be able to access. In a split tunnel scenario, you would specify the example LAN nets 192.168.1.0/24 and 2001:db8:1234:1::/64 as local traffic selectors. In a full tunnel scenario (all traffic forced through the tunnel) you would specify 0.0.0.0/0 and ::/0 as local traffic selectors. The following example child will use the full tunnel method. A full tunnel is generally more secure - especially with IPv6 involved - since no traffic can leak.

2.3.2 Create connection for laura@vpn1.example.com:

    Press + to add a new Connection, enable advanced mode with the toggle. You could also clone the connection you already configured.

General Settings:

    Proposals:
    	

    aes256-sha256-modp2048 (Disable default!)

    Version:
    	

    IKEv2

    Local addresses:
    	

    vpn1.example.com

    UDP encapsulation:
    	

    X

    Rekey time:
    	

    2400

    DPD delay:
    	

    30

    Pools:
    	

    pool-roadwarrior-laura-ipv4 pool-roadwarrior-laura-ipv6

    Keyingtries:
    	

    0

    Description:
    	

    roadwarrior-laura-eap-mschapv2-p1

Save to reveal the next options:

Local Authentication:

    Round:
    	

    0

    Authentication:
    	

    Public Key

    Id:
    	

    vpn1.example.com

    Certificates:
    	

    vpn1.example.com

    Description:
    	

    local-vpn1.example.com

Remote Authentication:

    Round:
    	

    0

    Authentication:
    	

    EAP-MSCHAPv2

    EAP Id:
    	

    laura@vpn1.example.com

    Description:
    	

    remote-laura-eap-mschapv2

Children:

Press + to add a new Child, enable advanced mode with the toggle.

    Start action:
    	

    Trap

    ESP proposals:
    	

    aes256-sha256-modp2048 (Disable default!)

    Local:
    	

    0.0.0.0/0 ::/0

    Rekey time (s):
    	

    600

    Description:
    	

    roadwarrior-laura-eap-mschapv2-p2

Save and Apply the configuration.

Note

You have to repeat this workflow for each additional roadwarrior you create. They all need new pools and new connections.
Firewall rules, Outbound NAT and DNS

Now that you have configured split or full tunnel mode, you need rules to allow the traffic into your LAN and to the WAN (Internet). For IPv4 connection to the WAN (Internet) you need an Outbound NAT rule for IP-Masquerading. If you want the OPNsense to handle DNS, you can to configure Unbound so your roadwarriors use it as DNS server to prevent DNS leaks.

Tip

If you have internal IPv4 services (like a mailserver) that have external IPs in their DNS A-Records, you should configure Reflection NAT. There is a tutorial in the How-To section of Network Address Translation. If you follow it, add the ipsec interface in the Port Forward rules you create.
Firewall: Aliases

Create the following aliases:

    Name:
    	

    InternetIPv4

    Type:
    	

    Network(s)

    Content:
    	

    10.0.0.0/8 172.16.0.0/12 192.168.0.0/16 127.0.0.0/8

    Description:
    	

    Internet IPv4 - use inverted

    Note

    The InternetIPv6 alias needs to be your own IPv6 network.

    Name:
    	

    InternetIPv6

    Type:
    	

    Network(s)

    Content:
    	

    2001:db8:1234::/48

    Description:
    	

    Internet IPv6 - use inverted

    Name:
    	

    net_pool_roadwarrior

    Type:
    	

    Network(s)

    Content:
    	

    172.16.203.0/24 2001:db8:1234:ec::/64

    Description:
    	

    Network pool-roadwarrior-ipv4 and ipv6

Additionally, if you created seperate IP pools for individual roadwarriors (Method 2), create the following aliases so you are able to create individual firewall rules per roadwarrior:

    Name:
    	

    host_pool_roadwarrior_john

    Type:
    	

    Host(s)

    Content:
    	

    172.16.203.1/32 2001:db8:1234:ec::1/128

    Description:
    	

    john@vpn1.example.com

    Name:
    	

    host_pool_roadwarrior_laura

    Type:
    	

    Host(s)

    Content:
    	

    172.16.203.2/32 2001:db8:1234:ec::2/128

    Description:
    	

    laura@vpn1.example.com

Firewall: Rules: IPsec

Here you use the aliases you created in the prior step in order to create firewall rules on the IPsec interface in order to allow traffic from the roadwarrior networks to your LAN and to the WAN (Internet).

As first rule it’s a good idea to allow ICMP for troubleshooting purposes. With that rule, roadwarriors can ping the OPNsense firewall. Please note that they can only ping those IPs that are included in the local traffic selectors of the children.

    Action
    	

    Pass

    Interface
    	

    IPsec

    Direction
    	

    In

    TCP/IP Version
    	

    IPv4+IPv6

    Protocol
    	

    ICMP

    Source
    	

    Any

    Source port
    	

    Any

    Destination
    	

    This Firewall

    Destination port
    	

    Any

    Description
    	

    Allow ICMP to this firewall

As second rule, you should allow LAN access from the IPsec roadwarrior networks. If you created individual aliases, you can create multiples of those rules with the aliases of the individuals added instead of the whole network.

    Example for a rule that allows the whole IPsec roadwarrior network to the LAN. LAN net is a predefined alias if you have an interface called LAN:

        Action
        	

        Pass

        Interface
        	

        IPsec

        Direction
        	

        In

        TCP/IP Version
        	

        IPv4+IPv6

        Protocol
        	

        TCP/UDP

        Source
        	

        net_pool_roadwarrior

        Source port
        	

        Any

        Destination
        	

        LAN net

        Destination port
        	

        Any

        Description
        	

        Allow ICMP to this firewall

    Example for an individual allow rule to the LAN:

        Action
        	

        Pass

        Interface
        	

        IPsec

        Direction
        	

        In

        TCP/IP Version
        	

        IPv4+IPv6

        Protocol
        	

        TCP/UDP

        Source
        	

        host_pool_roadwarrior_john

        Source port
        	

        Any

        Destination
        	

        LAN net

        Destination port
        	

        Any

        Description
        	

        Allow john@vpn1.example.com access to LAN net

The last matching rules can allow Internet access if you have configured a full tunnel. Just as the example above, you can also create individual rules to restrict Internet access to some roadwarriors:

    Action
    	

    Pass

    Interface
    	

    IPsec

    Direction
    	

    In

    TCP/IP Version
    	

    IPv4

    Protocol
    	

    Any

    Source
    	

    net_pool_roadwarrior

    Source port
    	

    Any

    Destination / Invert
    	

    X

    Destination
    	

    InternetIPv4

    Destination port
    	

    Any

    Description
    	

    Allow Internet Access IPv4

    Action
    	

    Pass

    Interface
    	

    IPsec

    Direction
    	

    In

    TCP/IP Version
    	

    IPv6

    Protocol
    	

    Any

    Source
    	

    net_pool_roadwarrior

    Source port
    	

    Any

    Destination / Invert
    	

    X

    Destination
    	

    InternetIPv6

    Destination port
    	

    Any

    Description
    	

    Allow Internet Access IPv6

Note

By setting Destination / Invert you invert the match of the alias. Don’t use “Any” as Destination to the Internet, since it also includes all networks that are locally attached to your firewall.
Firewall: NAT: Outbound

For IPv4 Internet access to work, you need to set up an Outbound NAT rule for IP-Masquerading. Start by enabling at least Hybrid outbound NAT rule generation and Save. Otherwise you can’t add your new manual NAT rule.

    Interface
    	

    WAN

    Direction
    	

    In

    TCP/IP Version
    	

    IPv4

    Protocol
    	

    any

    Source
    	

    net_pool_roadwarrior

    Source port
    	

    any

    Destination
    	

    any

    Destination port
    	

    any

    Translation / target
    	

    WAN address

    Description
    	

    IPsec MASQ

Services: Unbound DNS

Note

If you don’t serve internal DNS records (Split DNS) or don’t have an Active Directory you can skip the DNS configuration.

For full control over DNS, you should either use Unbound on the OPNsense or the DNS servers in your own network. If you provide your roadwarriors with external DNS servers (like 8.8.8.8), they can’t resolve your internal ressources and will send those requests to external DNS servers, thus exposing your internal DNS records. (DNS Leak)

Attention

If you created a full tunnel for IPv4 only (0.0.0.0/0 without ::/0), and your roadwarriors are in IPv4+IPv6 dual stack networks, their devices will prefer the link local IPv6 DNS servers provided by SLAAC or DHCPv6 over your IPv4 VPN DNS server.

Enable Unbound and leave the Network Interfaces on All (recommended). Next go to Query Forwarding and input your Custom forwarding servers. For example your Samba or Microsoft Active Directory Domain Controllers.

Unbound listens on port 53 UDP/TCP on all network interfaces of the Opnsense. If you followed all prior steps, access to your LAN is already permitted from the IPsec Network. You can use the IP addresses of the OPNsense in that network as target for the DNS queries.

In this example they are: 192.168.1.1 and 2001:db8:1234:1::1.
Client configuration

In this section there are a few example configurations of different clients. All configurations here are tuned to the exact settings above. If you change anything in the server configuration, make sure you change it here too.

All clients are configured to use the Configuration Payload for virtual IP address, traffic selectors and DNS Server(s). They are pushed by the VPN server to the client.

Note

Import the CA certificate to clients, not the server certificate.
Windows 10/11 native VPN client

Note

    Windows 10/11 native VPN client works best with Method 1, which connects right away on the first authentication round.

    If you use Method 2 you should rather use the NCP client. The Windows VPN client doesn’t send it’s local ID on the first authentication round. That means that users have to type their passwords twice before the connection establishes. You can mitigate one authentication round by saving the username and password into the vpn profile. Attention: If they press cancel or click outside of the authentication window, it will vanish and trying to connect again will fail until the PC is rebooted!

    Open Powershell as user (for userspace import) or as admin (for computer wide import) and apply the following commands:

Add-VpnConnection -Name "vpn1.example.com" -ServerAddress "vpn1.example.com" -TunnelType "Ikev2"

Set-VpnConnectionIPsecConfiguration -ConnectionName "vpn1.example.com" -AuthenticationTransformConstants SHA256 -CipherTransformConstants AES256 -EncryptionMethod AES256 -IntegrityCheckMethod SHA256 -PfsGroup PFS2048 -DHGroup Group14 -PassThru -Force

    Only set this parameter if you want a split tunnel:

Set-VpnConnection -Name "vpn1.example.com" -SplitTunneling $true

Note

If you use Split Tunneling, you have to set all routes manually. For users without admin rights, they have to be added to the “Network Configuration Operators” built-in group. Example Route (can be batched): route add 192.168.1.0 mask 255.255.255.0 172.16.203.254

    Import the CA certificate into the Windows certificate store, please note that you have to be admin for this action:

            Open MMC: Windows + R > Type mmc > Enter.

            Add Certificates Snap-In: File > Add/Remove Snap-in > Certificates > Add > Computer account > Local computer > Finish.

            Install Certificate: Go to Trusted Root Certification Authorities > Certificates > Right-click > All Tasks > Import > Select your CA certificate > Ensure it’s set to Trusted - Root Certification Authorities > Finish.

            Confirm: Check the certificate appears under Trusted Root Certification Authorities.

            Close MMC. Choose ‘No’ if asked to save console settings.

    Connect the new VPN connection and use the following credentials, you can also save them prior to connecting:

            Username: john@vpn1.example.com

            Password: 48o72g3h4ro8123g8r

Optional if DNS Server provisioning via Configuration Payload doesn’t work: - Set up DNS for the VPN:

        Open Network Connections: Windows + R > Type ncpa.cpl > Enter.

        Locate VPN adapter (e.g. “vpn1.example.com”).

        Right-click VPN adapter > Properties.

        For IPv4:

                Select Internet Protocol Version 4 (TCP/IPv4) > Properties.

                Set DNS: 192.168.1.1

        For IPv6:

                Select Internet Protocol Version 6 (TCP/IPv6) > Properties.

                Set DNS: 2001:db8:1234:1::1

        Click OK to apply changes.

iOS native VPN client

    Import the self-signed CA certificate into the iOS certificate store.

    Go to Settings > General > VPN.

    Tap on Add VPN Configuration….

    Select the type of VPN you are using. For this example, it’s IKEv2.

    In the fields provided, enter:

            Description: vpn1.example.com

            Server: vpn1.example.com

            Remote ID: vpn1.example.com

            Local ID: john@vpn1.example.com

    In the Authentication section, select Username.

            Username: john@vpn1.example.com

            Password: 48o72g3h4ro8123g8r

    Tap Done in the top right corner.

    To connect to the VPN, go back to Settings > VPN, then turn the VPN toggle switch to the ON position next to the profile you just created.

Note

iOS doesn’t allow setting a DNS Server for the VPN, and it ignores the DNS Configuration Payload. The only workaround would be to change the DNS Server manually in the Wi-Fi settings each time the tunnel is brought up, and change them back when it’s turned off.
Android StrongSwan VPN client

    Import the self-signed CA certificate into the Android certificate store.

    Install the StrongSwan app from the Google Play Store

    Open the StrongSwan app and create a new VPN profile.

            Server: vpn1.example.com

            VPN Typ: IKEv2 EAP

            Username: john@vpn1.example.com

            Password: 48o72g3h4ro8123g8r

            CA-Certificate: choose the imported CA certificate

            Activate advanced mode:

            IKEv2 Algorithms: aes256-sha256-modp2048

            IPsec/ESP Algorithms: aes256-sha256-modp2048

    You can start the new profile and it should connect. If not, check the Logfile for the error message.

Windows/macOS NCP Secure Entry client

Attention

This is a commercial client and needs to be licensed. It is not affiliated with Deciso B.V. or OPNsense®.

    Install the NCP Secure Entry Client

    Save the following code as example.ini

[GENERAL]
Export=1
Product=NCP Secure Entry Client
Version=13.14 Build 29669
Date=11.09.2023 09:30:42
[PROFILE1]
Name=vpn1.example.com
ConnMedia=21
UseForAuto=0
SeamRoaming=1
NotKeepVpn=0
BootProfile=0
UseRAS=0
SavePw=0
PhoneNumber=
DialerPhone=
ScriptFile=
HttpName=
HttpPw=
HttpScript=
Modem=
ComPort=1
Baudrate=57600
RelComPort=1
InitStr=
DialPrefix=
3GApnSrc=2
3GProvider=
APN=
3GPhone=
3GAuth=0
GprsATCmd=AT+CPIN=
GprsPin=""
BiometricAuth=0
PreAuthEap=0
PreAuthHttp=0
ConnMode=0
Timeout=0
TunnelTrafficMonitoring=0
TunnelTrafficMonitoringAddr=0.0.0.0
QoS=none
PkiConfig=
ExchMode=34
TunnelIpVersion=1
IKEv2Auth=3
IKE-Policy=automatic mode
IKEv2Policy=aes256-sha256
IkeDhGroup=14
IkeLTSec=000:00:40:00
IPSec-Policy=aes256-sha256
PFS=14
IPSecLTType=1
IpsecLTSec=000:00:10:00
IPSecLTKb=50000
UseComp=0
IkeIdType=3
IkeIdStr=john@vpn1.example.com
Gateway=vpn1.example.com
ConnType=1
UsePreShKey=0
XAUTH-Src=0
SplitOptionV4=1
UseTunnel=1
SplitOptionV6=1
VpnBypass=none
UseXAUTH=1
UseUdpEnc=500
UseUdpEncTmp=4500
DisDPD=0
DPDInterval=30
DPDRetrys=8
AntiReplay=0
PathFinder=0
UseRFC7427=1
RFC7427Padding=2
Ikev2AuthPrf=0
CertReqWithData=0
IpAddrAssign=0
IPAddress=
SubnetMask=
DNS1=
DNS2=
DomainName=
DomainInTunnel=
SubjectCert=
IssuerCert=
FingerPrint=
UseSHA1=0
Firewall=0
OnlyTunnel=0
RasOnlyTunnel=0
DNSActiv=1
DNS1Tmp=
DNS2Tmp=
[IKEV2POLICY1]
Ikev2Name=aes256-sha256
Ikev2Crypt=6
Ikev2PRF=5
Ikev2IntAlgo=12
[IPSECPOLICY1]
IPSecName=aes256-sha256
IpsecCrypt=6
IpsecAuth=5

    For other users edit IkeIdStr=john@vpn1.example.com. Change Name=vpn1.example.com and Gateway=vpn1.example.com to your vpn gateway.

    Import the example.ini Profile:

            Launch the NCP Secure Entry Client.

            Navigate to the Profile menu.

            Select the option to Import Profile.

            Browse to the location where your example.ini profile is saved.

            Select the profile and click Open or Import (whichever option appears).

            You can enter the username and password of the user when importing the profile.

                    Username: john@vpn1.example.com

                    Password: 48o72g3h4ro8123g8r

    Import the self-signed CA certificate into the NCP certificate store. Go to C:\ProgramData\NCP\SecureClient\cacerts and copy your the .pem file in there.

    The profile should now be loaded into the NCP Secure Entry Client. You can start it and it should connect. If not, check the Logfile in “Help” for the error message.

Note

There is also a version for macOS, which works with the same configuration as above. The only challenge is finding the right folder for the cacerts. You can find it by going into the terminal and using the command sudo find / -name cacerts. Then you can pinpoint the path and copy the CA certificates there.
Troubleshooting

If the VPN connection doesn’t establish right away there are several steps you can take to troubleshoot the connection. Here’s a short summary where to start. Debugging an IPsec connection takes time, don’t get discouraged if you can’t solve the problem right away.

    If it’s your first IPsec connection, don’t forget to enable IPsec and apply.

    Use tcpdump on the OPNsense to look for incoming packets on port 500 and port 4500 when you connect your VPN client. If you can’t see any, your firewall blocks them, or the remote client can’t send them due to a remote firewall. There could also be a wrong IP Address the packets are sent to.

    If there are packets received, but no packets sent, look into the VPN log files.

    Check /var/logs/ipsec/latest.log or VPN ‣ IPsec ‣ Log File for the connection being processed. Most of the time you can see errors in there you can search on the internet.

    The easiest tool to troubleshoot the connection is the Android StrongSwan Client or the Windows NCP Secure Entry Client. They have powerful inbuild logging so you can check both sides of the connection. In IPsec, you need the log of the server and the client to find the true cause of a connection error.


IPsec - Site to Site tunnel

Site to site VPNs connect two locations with static public IP addresses and allow traffic to be routed between the two networks. This is most commonly used to connect an organization’s branch offices back to its main office, so branch users can access network resources in the main office.
Before you start

Before starting with the configuration of an IPsec tunnel you need to have a working OPNsense installation with a unique LAN IP subnet for each side of your connection (your local network need to be different than that of the remote network).

Note

For the sample we will use a private IP for our WAN connection. This requires us to disable the default block rule on wan to allow private traffic. To do so, go to Interfaces ‣ [WAN] and uncheck “Block private networks”. (Dont forget to save and apply)
../../_images/block_private_networks.png
Sample Setup

For the sample configuration we use two OPNsense boxes to simulate a site to site tunnel, with the following configuration:

Network Site A
Site A

Hostname
	

fw1

WAN IP
	

172.10.1.1/24

LAN Net
	

192.168.1.0/24

LAN IP
	

192.168.1.1/24

LAN DHCP Range
	

192.168.1.100-192.168.1.200




Network Site B
Site B

Hostname
	

fw2

WAN IP
	

172.10.2.1/24

LAN Net
	

192.168.2.0/24

LAN IP
	

192.168.2.1/24

LAN DHCP Range
	

192.168.2.100-192.168.2.200




Full Network Diagram Including IPsec Tunnel

IPsec Site-to-Site tunnel network
Firewall Rules Site A & Site B (part 1)

To allow IPsec Tunnel Connections, the following should be allowed on WAN for on sites (under Firewall ‣ Rules ‣ WAN):

    Protocol ESP

    UDP Traffic on Port 500 (ISAKMP)

    UDP Traffic on Port 4500 (NAT-T)

../../_images/ipsec_wan_rules.png

Note

You can further limit the traffic by the source IP of the remote host.
Step 1 - Phase 1 Site A

(Under VPN ‣ IPsec ‣ Tunnel Settings Press +) We will use the following settings:
General information

Connection method
	

default
	

default is ‘Start on traffic’

Key Exchange version
	

V2
	

Internet Protocol
	

IPv4
	

Interface
	

WAN
	

choose the interface connected to the internet

Remote gateway
	

172.10.2.1
	

the public IP address of your remote OPNsense

Description
	

Site B
	

freely chosen description
Phase 1 proposal (Authentication)

Authentication method
	

Mutual PSK
	

Using a Pre-shared Key

My identifier
	

My IP address
	

Simple identification for fixed ip

Peer identifier
	

Peer IP address
	

Simple identification for fixed ip

Pre-Shared Key
	

At4aDMOAOub2NwT6gMHA
	

Random key. CREATE YOUR OWN!
Phase 1 proposal (Algorithms)

Encryption algorithm
	

AES
	

For our sample we will Use AES/256 bits

Hash algoritm
	

SHA512
	

Use a strong hash like SHA512

DH key group
	

14 (2048 bit)
	

2048 bit should be sufficient

Lifetime
	

28800 sec
	

lifetime before renegotiation
Advanced Options

Disable Rekey
	

Unchecked
	

Renegotiate when connection is about to expire

Disable Reauth
	

Unchecked
	

For IKEv2 only re-authenticate peer on rekeying

NAT Traversal
	

Disabled
	

For IKEv2 NAT traversal is always enabled

Dead Peer Detection
	

Unchecked
	

Save your setting by pressing:
../../_images/btn_save.png

Now you should see the following screen:
../../_images/ipsec_s2s_vpn_p1a_4.png
Step 2 - Phase 2 Site A

Press the button + in front of the phase 1 entry to add a new phase 2.
General information

Mode
	

Tunnel IPv4
	

Select Tunnel mode

Description
	

Local LAN Site B
	

Freely chosen description
Local Network

Local Network
	

LAN subnet
	

Route the local LAN subnet
Remote Network

Type
	

Network
	

Route a remote network

Address
	

192.168.2.0/24
	

The remote LAN subnet
Phase 2 proposal (SA/Key Exchange)

Protocol
	

ESP
	

Choose ESP for encryption

Encryption algorithms
	

AES / 256
	

For the sample we use AES 256

Hash algortihms
	

SHA512
	

Choose a strong hash like SHA512

PFS Key group
	

14 (2048 bit)
	

Not required but enhanced security

Lifetime
	

3600 sec
	

Save your setting by pressing:
../../_images/btn_save.png

Enable IPsec for Site A, Select:
../../_images/ipsec_s2s_vpn_p1a_enable.png

Save:
../../_images/btn_save.png

And Apply changes:
../../_images/ipsec_s2s_vpn_p1a_apply.png ../../_images/ipsec_s2s_vpn_p1a_success.png

You are almost done configuring Site A (only some firewall settings remain, which we’ll address later). We will now proceed setting up Site B.
Step 3 - Phase 1 Site B

(Under VPN ‣ IPsec ‣ Tunnel Settings Press +) We will use the following settings:
General information

Connection method
	

default
	

default is ‘Start on traffic’

Key Exchange version
	

V2
	

Internet Protocol
	

IPv4
	

Interface
	

WAN
	

choose the interface connected to the internet

Remote gateway
	

172.10.1.1
	

the public IP address of your remote OPNsense

Description
	

Site A
	

freely chosen description
Phase 1 proposal (Authentication)

Authentication method
	

Mutual PSK
	

Using a Pre-shared Key

My identifier
	

My IP address
	

Simple identification for fixed ip

Peer identifier
	

Peer IP address
	

Simple identification for fixed ip

Pre-Shared Key
	

At4aDMOAOub2NwT6gMHA
	

Random key. CREATE YOUR OWN!
Phase 1 proposal (Algorithms)

Encryption algorithm
	

AES
	

For our sample we will Use AES/256 bits

Hash algoritm
	

SHA512
	

Use a strong hash like SHA512

DH key group
	

14 (2048 bit)
	

2048 bit should be sufficient

Lifetime
	

28800 sec
	

lifetime before renegotiation
Advanced Options

Disable Rekey
	

Unchecked
	

Renegotiate when connection is about to expired

Disable Reauth
	

Unchecked
	

For IKEv2 only re-authenticate peer on rekeying

NAT Traversal
	

Disable
	

For IKEv2 NAT traversal is always enabled

Dead Peer Detection
	

Unchecked
	

Save your setting by pressing:
../../_images/btn_save.png

Now you should see the following screen:
../../_images/ipsec_s2s_vpn_p1b_4.png
Step 4 - Phase 2 Site B

Press the button + in front of the phase 1 entry to add a new phase 2.
General information

Mode
	

Tunnel IPv4
	

Select Tunnel mode

Description
	

Local LAN Site A
	

Freely chosen description
Local Network

Local Network
	

LAN subnet
	

Route the local LAN subnet
Remote Network

Type
	

Network
	

Route a remote network

Address
	

192.168.1.0/24
	

The remote LAN subnet
Phase 2 proposal (SA/Key Exchange)

Protocol
	

ESP
	

Choose ESP for encryption

Encryption algorithms
	

AES / 256
	

For the sample we use AES 256

Hash algortihms
	

SHA512
	

Choose a strong hash like SHA512

PFS Key group
	

14 (2048 bit)
	

Not required but enhanced security

Lifetime
	

3600 sec
	

Save your setting by pressing:
../../_images/btn_save.png

Enable IPsec for Site B, Select:
../../_images/ipsec_s2s_vpn_p1a_enable.png

Save:
../../_images/btn_save.png

And Apply changes:
../../_images/ipsec_s2s_vpn_p1a_apply.png ../../_images/ipsec_s2s_vpn_p1a_success.png
Firewall Rules Site A & Site B (part 2)

To allow traffic passing to your LAN subnet you need to add a rule to the IPsec interface (under Firewall ‣ Rules ‣ IPsec).
../../_images/ipsec_ipsec_lan_rule.png
IPsec Tunnel Ready

The tunnel should now be up and routing the both networks. Go to VPN ‣ IPsec ‣ Status Overview to see current status. Press on the (i) to see the details of the phase 2 tunnel(s), like this:
../../_images/ipsec_status.png

Note

If the tunnel did not come up, try to restart the service on both ends.
Sample configuration

For test purposes we used two OPNsense boxes integrated into one unit and a cross-cable between the WAN ports.

To route traffic the WAN interfaces have been configured to use a /16 segment and they are each others default gateway. Other than that the sample is equal to this how-to.

Configuration Site A

    Config.xml Site A
Configuration Site B

    Config.xml Site B

Trouble shooting
Phase 1 won’t come up

That is a difficult one. First check you firewall rules to see if you allow the right ports and protocols (ESP, UDP 500 & UDP 4500) for the WAN interface.

Check your ipsec log to see if that reviels a possible cause.

Common issues are unequal settings. Both ends must use the same PSK and encryption standard.
Phase 1 works but no phase 2 tunnels are connected

Did you set the correct local and remote networks. A common mistake is to fill in the IP address of the remote host instead of its network ending with x.x.x.0

Common issues are unequal settings. Both ends must use the same encryption standard.

Note

If you are testing locally with your pc connected to one of the two test boxes as in the sample configuration, then make sure you have no other network connections (Wi-Fi, for example).


IPSec - BINAT (NAT before IPSec)

Assume company A has local LAN 10.0.1.0/24 and company B has local LAN 10.0.2.0/24. Also we assume that on both sides the other networks are already in use, e.g. in company A the network 10.0.2.0/24 is used for Voice and in company B network 10.0.1.0/24 is used for Guest Wi-Fi.

We have to define new networks for the Phase 2 with unused ones and create NAT entries to reach the final systems.

To make it easier we create a Phase2 with company A using 192.168.1.0/24 as Local Network and 192.168.2.0/24 as Remote Network and with company B using 192.168.2.0/24 as Local network and 192.168.1.0/24 as Remote Network. Now we need to add on each side the local LAN in the field “Manual SPD entries”. So for company A we set 10.0.1.0/24 in the field and for B 10.0.2.0/24. This allows the NAT process to speak with the Security Policy Database.

Finally we have to create NAT entries since a client in LAN A (10.0.1.10) tries to reach 192.168.2.10, but this address has to be rewritten to 10.0.2.10 on Firewall B.

Create the rule like in the screenshot and vice versa on Firewall A:
../../_images/opnsense_nat_binat_ipsec.png


IPsec VTI - Route based setup

Most Site-to-Site VPNs are policy-based, which means you define a local and a remote network (or group of networks). Only traffic matching the defined policy is pushed into the VPN tunnel. As the demands for more complex and fault tolerant VPN scenarios growed over the years, most major router vendors implemented a kind of VPN, the route-based IPSec.

The difference is that local and remote network is just 0.0.0.0/0, so anything can travel through the tunnel, it just needs a route. A new Virtual Tunnel Interface (VTI) has to be used for this.

There are two benefits for this kind of VPN:

First, you can set up two tunnels to the same gateway and failover when one line goes down. Second, you can run dynamic routing protocols over the tunnel to create more redundant, or software-defined networks.

Note

For a stable setup, we highly advise using standard IPv4 / IPv6 addresses, although the web interface allows the use of fully qualified domain names (e.g. my.own.domain.xyz), this will have side affects (the tunnel device won’t react on name changes for example).
Before you start

Before starting with the configuration of an IPsec tunnel you need to have a working OPNsense installation wit a unique LAN IP subnet for each side of your connection (your local network needs a different one than the remote network).
Sample Setup

For the sample configuration we use two OPNsense boxes to simulate a site to site tunnel, with the following configuration:

Network Site A
Site A

Hostname
	

fw1

WAN IP
	

1.2.3.4/24

LAN IP
	

192.168.1.1/24

LAN DHCP Range
	

192.168.1.100-192.168.1.200




Network Site B
Site B

Hostname
	

fw2

WAN IP
	

4.3.2.1/24

LAN Net
	

192.168.2.0/24

LAN DHCP Range
	

192.168.2.100-192.168.2.200




Full Network Diagram Including IPsec Tunnel

IPsec Site-to-Site tunnel network
Firewall Rules Site A & Site B (part 1)

To allow IPsec tunnel connections, the following should be allowed on WAN for on sites (under Firewall ‣ Rules ‣ WAN):

    Protocol ESP

    UDP Traffic on port 500 (ISAKMP)

    UDP Traffic on port 4500 (NAT-T)

../../_images/ipsec_wan_rules.png

Note

You can further limit the traffic by the source IP of the remote host.
Step 1 - Phase 1 Site A

(Under VPN ‣ IPsec ‣ Tunnel Settings Press +) We will use the following settings:
General information

Connection method
	

default
	

Default is “Start on traffic”

Key Exchange version
	

V2
	

Internet Protocol
	

IPv4
	

Interface
	

WAN
	

Choose the interface connected to the internet

Remote gateway
	

4.3.2.1
	

The public IP address of your remote OPNsense

Description
	

Site B
	

Freely chosen description
Phase 1 proposal (Authentication)

Authentication method
	

Mutual PSK
	

Using a Pre-shared Key

My identifier
	

My IP address
	

Simple identification for fixed IP

Peer identifier
	

Peer IP address
	

Simple identification for fixed IP

Pre-Shared Key
	

At4aDMOAOub2NwT6gMHA
	

Random key. CREATE YOUR OWN!
Phase 1 proposal (Algorithms)

Encryption algorithm
	

AES
	

For our sample we will use AES/256 bits

Hash algoritm
	

SHA512
	

Use a strong hash like SHA512

DH key group
	

14 (2048 bit)
	

2048 bit should be sufficient

Lifetime
	

28800 sec
	

Lifetime before renegotiation
Advanced Options

Install Policy
	

Unchecked
	

This has to be unchecked since we want plain routing

Disable Rekey
	

Unchecked
	

Renegotiate when connection is about to expire

Disable Reauth
	

Unchecked
	

For IKEv2 only re-authenticate peer on rekeying

NAT Traversal
	

Disabled
	

For IKEv2 NAT traversal is always enabled

Dead Peer Detection
	

Unchecked
	

Save your setting by pressing:
../../_images/btn_save.png
Step 2 - Phase 2 Site A

Press the button + in front of the phase 1 entry to add a new phase 2.

As we do not define a local and remote network, we just use tunnel addresses, you might already know from OpenVPN. In this example we use 10.111.1.1 and 10.111.1.2. These will be the gateway addresses used for routing
General information

Mode
	

Route-based
	

Select Route-based

Description
	

Local LAN Site B
	

Freely chosen description
Tunnel Network

Local Address
	

Local Tunnel IP
	

Set IP 10.111.1.1

Remote Address
	

Remote Tunnel IP
	

Set IP 10.111.1.2
Phase 2 proposal (SA/Key Exchange)

Protocol
	

ESP
	

Choose ESP for encryption

Encryption algorithms
	

AES / 256
	

For the sample we use AES 256

Hash algortihms
	

SHA512
	

Choose a strong hash like SHA512

PFS Key group
	

14 (2048 bit)
	

Not required but enhanced security

Lifetime
	

3600 sec
	

Save your settings by pressing:
../../_images/btn_save.png

Enable IPsec for Site A, select:
../../_images/ipsec_s2s_vpn_p1a_enable.png

Save:
../../_images/btn_save.png

And apply changes:
../../_images/ipsec_s2s_vpn_p1a_apply.png ../../_images/ipsec_s2s_vpn_p1a_success.png

You are almost done configuring Site A (only some firewall settings remain, which will be addressed later). We will now proceed setting up Site B.
Step 3 - Phase 1 Site B

(Under VPN ‣ IPsec ‣ Tunnel Settings Press +) We will use the following settings:
General information

Connection method
	

Default
	

Default is ‘Start on traffic’

Key Exchange version
	

V2
	

Internet Protocol
	

IPv4
	

Interface
	

WAN
	

Choose the interface connected to the internet

Remote gateway
	

1.2.3.4
	

The public IP address of your remote OPNsense

Description
	

Site A
	

Freely chosen description
Phase 1 proposal (Authentication)

Authentication method
	

Mutual PSK
	

Using a Pre-shared Key

My identifier
	

My IP address
	

Simple identification for fixed ip

Peer identifier
	

Peer IP address
	

Simple identification for fixed ip

Pre-Shared Key
	

At4aDMOAOub2NwT6gMHA
	

Random key. CREATE YOUR OWN!
Phase 1 proposal (Algorithms)

Encryption algorithm
	

AES
	

For our sample we will use AES/256 bits

Hash algoritm
	

SHA512
	

Use a strong hash like SHA512

DH key group
	

14 (2048 bit)
	

2048 bit should be sufficient

Lifetime
	

28800 sec
	

Lifetime before renegotiation
Advanced Options

Install Policy
	

Unchecked
	

This has to be unchecked since we want plain routing

Disable Rekey
	

Unchecked
	

Renegotiate when connection is about to expire

Disable Reauth
	

Unchecked
	

For IKEv2 only re-authenticate peer on rekeying

NAT Traversal
	

Disabled
	

For IKEv2 NAT traversal is always enabled

Dead Peer Detection
	

Unchecked
	

Save your setting by pressing:
../../_images/btn_save.png
Step 4 - Phase 2 Site B

Press the button + in front of the phase 1 entry to add a new phase 2.
General information

Mode
	

Route-based
	

Select Route-based

Description
	

Local LAN Site A
	

Freely chosen description
Tunnel Network

Local Address
	

Local Tunnel IP
	

Set IP 10.111.1.2

Remote Address
	

Remote Tunnel IP
	

Set IP 10.111.1.1
Phase 2 proposal (SA/Key Exchange)

Protocol
	

ESP
	

Choose ESP for encryption

Encryption algorithms
	

AES / 256
	

For the sample we use AES 256

Hash algortihms
	

SHA512
	

Choose a strong hash like SHA512

PFS Key group
	

14 (2048 bit)
	

Not required but enhanced security

Lifetime
	

3600 sec
	

Save your setting by pressing:
../../_images/btn_save.png

Enable IPsec for Site B, Select:
../../_images/ipsec_s2s_vpn_p1a_enable.png

Save:
../../_images/btn_save.png

And apply changes:
../../_images/ipsec_s2s_vpn_p1a_apply.png ../../_images/ipsec_s2s_vpn_p1a_success.png
Firewall Rules Site A & Site B (part 2)

To allow traffic passing to your LAN subnet you need to add a rule to the IPsec interface (under Firewall ‣ Rules ‣ IPsec).
../../_images/ipsec_ipsec_lan_rule.png
IPsec Tunnel Ready

The tunnel should now be up and routing the both networks. Go to VPN ‣ IPsec ‣ Status Overview to see current status.
Step 5 - Define Gateways

Now that you have the VPN up and running you have to set up a gateway. Go to System ‣ Gateways ‣ Configuration and add a new gateway.
Gateway Site-A

Name
	

VPNGW
	

Set a name for your gateway

Interface
	

IPSEC1000
	

Choose the IPsec interface

IP Address
	

10.111.1.2
	

Set the peer IP address

Far Gateway
	

Checked
	

This has to be checked as it is a point-to-point connection
Gateway Site-B

Name
	

VPNGW
	

Set a name for your gateway

Interface
	

IPSEC1000
	

Choose the IPsec interface

IP Address
	

10.111.1.1
	

Set the peer IP address

Far Gateway
	

checked
	

This has to be checked as it is a point-to-point connection
Step 5 - Add Static Routes

When gateways are set up you can add a route for the remote network pointing to the new gateway. On Site-A add a route to Site-B and vice versa. Go to System ‣ Routes ‣ Configuration.
Route Site-A

Network Address
	

192.168.2.0/24
	

Set the network of Site-B

Gateway
	

VPNGW
	

Select the VPN gateway
Gateway Site-B

Network Address
	

192.168.1.0/24
	

Set the network of Site-A

Gateway
	

VPNGW
	

Select the VPN gateway

Now you are all set!


IPsec VTI - connect to Microsoft Azure

Microsoft Azure offers three VPN types:

    policy-based (restricted to a single S2S connection)

    route-based

    route-based with BGP (not available in the virtual network gateway SKU “Basic”)

This how-to covers setting up a route-based S2S VPN.
Before you start

Before starting with the configuration of an IPsec tunnel you need to have a working OPNsense installation and an Azure virtual network setup with a unique LAN IP subnets for each side of your connection (your local networks need to be different from your remote networks).

For setting up a Microsoft Azure virtual network and virtual network gateway refer to the Microsoft Azure documentation:

https://docs.microsoft.com/en-us/azure/vpn-gateway/vpn-gateway-howto-site-to-site-resource-manager-portal
Sample Setup

This sample configuration uses an OPNsense box and the basic Azure virtual network gateway, with the following configuration:
OPNsense

Hostname
	

OPNsense

WAN IP
	

1.2.3.4

LAN Network
	

192.168.1.1/24

Azure

Hostname
	

Azure

Virtual Network Gateway Public IP
	

4.3.2.1

Virtual Network Address Space
	

192.168.2.0/24

Firewall Rules OPNsense

To allow IPsec tunnel connections, the following should be allowed on WAN for on sites (under Firewall ‣ Rules ‣ WAN):

    Protocol ESP

    UDP Traffic on port 500 (ISAKMP)

    UDP Traffic on port 4500 (NAT-T)

../../_images/ipsec_wan_rules.png

Note

You can further limit the traffic by the source IP of the remote host.
Step 1 - Phase 1 OPNsense

(Under VPN ‣ IPsec ‣ Tunnel Settings Press +) We will use the following settings:
General information

Connection method
	

Respond only
	

Key Exchange version
	

V2
	

Internet Protocol
	

IPv4
	

Interface
	

WAN
	

Choose the interface connected to the internet

Remote gateway
	

4.3.2.1
	

The public IP address of your Azure virtual network

Description
	

IPsec Azure
	

Freely chosen description
Phase 1 proposal (Authentication)

Authentication method
	

Mutual PSK
	

Using a Pre-shared Key

My identifier
	

My IP address
	

Simple identification for fixed IP

Peer identifier
	

Peer IP address
	

Simple identification for fixed IP

Pre-Shared Key
	

At4aDMOAOub2NwT6gMHA
	

Random key. CREATE YOUR OWN!
Phase 1 proposal (Algorithms)

Encryption algorithm
	

AES 256
	

refer to Azure docs for details

Hash algoritm
	

SHA256
	

DH key group
	

2 (1024 bit)
	

Lifetime
	

28800 sec
	

Lifetime before renegotiation

Note

Possible parameters are listed here: https://docs.microsoft.com/en-us/azure/vpn-gateway/vpn-gateway-about-vpn-devices
Advanced Options

Install Policy
	

Unchecked
	

This has to be unchecked since we want plain routing

Disable Rekey
	

Unchecked
	

Renegotiate when connection is about to expire

Disable Reauth
	

Unchecked
	

For IKEv2 only re-authenticate peer on rekeying

NAT Traversal
	

Disable
	

For IKEv2 NAT traversal is always enabled

Dead Peer Detection
	

Unchecked
	

Save your setting by pressing:
../../_images/btn_save.png
Step 2 - Phase 2 OPNsense

Press the button + in front of the phase 1 entry to add a new phase 2.

As we do not define a local and remote network, we just use tunnel addresses, you might already know from OpenVPN. In this example we use 10.111.1.1 and 10.111.1.2. These will be the gateway addresses used for routing
General information

Mode
	

Route-based
	

Select Route-based

Description
	

Azure VNET
	

Freely chosen description
Tunnel Network

Local Address
	

Local Tunnel IP
	

Set IP 10.111.1.1

Remote Address
	

Remote Tunnel IP
	

Set IP 10.111.1.2
Phase 2 proposal (SA/Key Exchange)

Protocol
	

ESP
	

Choose ESP for encryption

Encryption algorithms
	

AES / 256
	

refer to Azure docs for details

Hash algortihms
	

SHA256
	

PFS Key group
	

off
	

Not supported

Lifetime
	

27000 sec
	

Save your settings by pressing:
../../_images/btn_save.png

Enable IPsec for OPNsense, select:
../../_images/ipsec_s2s_vpn_p1a_enable.png

Save:
../../_images/btn_save.png

And apply changes:
../../_images/ipsec_s2s_vpn_p1a_apply.png ../../_images/ipsec_s2s_vpn_p1a_success.png
Step 3 - Set MSS Clamping

(Under Interfaces ‣ IPsec Azure) We will use the following settings:
Setup

MSS
	

1350
	

Required

Leave the other settings as per default.

Save:
../../_images/btn_save.png

You are almost done configuring OPNsense (only some firewall settings remain, which will be addressed later). We will now proceed setting up Azure.
Step 4 - Azure: Setup local network gateway

(Under All resources press + Add, then search and Create Local network gateway) We will use the following settings:
Setup

Name
	

lng.opnsense
	

Freely chosen name

IP address
	

1.2.3.4
	

The public IP address of your remote OPNsense

Address space
	

192.168.1.0/24
	

LAN Network

Address space
	

10.111.1.1/32
	

Local Tunnel IP

Press the button that says ‘Create’:
../../_images/ipsec_s2s_route_azure_lng.png
Step 5 - Azure: Setup VPN connection

(Under All resources –> Virtual network gateway –> Connections Press + Add) We will use the following settings:
General setup

Name
	

vpn.opnsense
	

Freely chosen name

Connection type
	

Site-to-site (IPsec)
	

Virtual network gateway
	

vpn.gw
	

Select virtual network gateway

Local network gateway
	

lng.opnsense
	

Select local network gateway

Shared Key (PSK)
	

At4aDMOAOub2NwT6gMHA
	

Random key. CREATE YOUR OWN!

Press the button that says ‘OK’:
../../_images/ipsec_s2s_route_azure_conn.png
Firewall Rules OPNsense

To allow traffic passing to your LAN subnet you need to add a rule to the IPsec interface (under Firewall ‣ Rules ‣ IPsec).
../../_images/ipsec_ipsec_lan_rule.png
IPsec Tunnel Ready

The tunnel should now be up and routing the both networks. Go to VPN ‣ IPsec ‣ Status Overview to see current status.
Step 6 - Define Gateways

Now that you have the VPN up and running you have to set up a gateway. Go to System ‣ Gateways ‣ Configuration and add a new gateway.
OPNsense

Name
	

VPNGW
	

Set a name for your gateway

Interface
	

IPSEC1000
	

Choose the IPsec interface

IP Address
	

10.111.1.2
	

Set the peer IP address

Far Gateway
	

Checked
	

This has to be checked as it is a point-to-point connection
Step 7 - Add Static Routes

When the gateway is set up you can add a route for the Azure virtual network pointing to the new gateway. Go to System ‣ Routes ‣ Configuration.
Route OPNsense

Network Address
	

192.168.2.0/24
	

Azure virtual network

Gateway
	

VPNGW
	

Select the VPN gateway

Now you are all set!


Road Warriors - Setup Remote Access

Index

    Road Warriors - Setup Remote Access

        Intro

        Sample Setup

            Company Network

        Firewall Rules Mobile Users

        VPN compatibility

        List of examples

Intro

Remote access to the company’s infrastructure is one of most important and critical services exposed to the internet. IPsec Mobile Clients offer mobile users (formerly known as Road Warriors) a solution that is easy to setup and compatible with most current devices.

With this guide we will show you how to configure the server side on OPNsense with the different authentication methods e.g.

    EAP-MSCHAPv2

    Mutual-PSK + XAuth

    Mutual-RSA + XAuth

    …

Note

For the sample we will use a private ip for our WAN connection. This requires us to disable the default block rule on WAN to allow private traffic. To do so, go to Interfaces ‣ [WAN] and uncheck “Block private networks”. (Don’t forget to save and apply)
../../_images/block_private_networks.png
Sample Setup

All configuration examples are based on the following setup, please read this carefully as all guides depend on it.

Company Network with Remote Client
Company Network

Hostname
	

fw1

WAN IP
	

172.18.0.164

LAN IP
	

192.168.1.0/24

LAN DHCP Range
	

192.168.1.100-192.168.1.200

IPsec Clients
	

10.10.0.0/24
Firewall Rules Mobile Users

To allow IPsec Tunnel Connections, the following should be allowed on WAN.

    Protocol ESP

    UDP Traffic on Port 500 (ISAKMP)

    UDP Traffic on Port 4500 (NAT-T)

../../_images/ipsec_wan_rules.png

To allow traffic passing to your LAN subnet you need to add a rule to the IPsec interface.
../../_images/ipsec_ipsec_lan_rule.png
VPN compatibility

In the next table you can see the existing VPN authentication mechanisms and which client operating systems support it, with links to their configurations. For Linux testing was done with Ubuntu 18.4 Desktop and network-manager-strongswan and libcharon-extra-plugins installed. As Andoid does not support IKEv2 yet we added notes for combinations with strongSwan app installed to have a broader compatibility for all systems. Mutual RSA and PSK without XAuth requires L2TP, since this legacy technology is very error prone we will not cover it here.
VPN combinations

VPN Method
	

Win7
	

Win10
	

Linux
	

Mac OS X
	

IOS
	

Android
	

OPNsense config

IKEv1 Hybrid RSA + XAuth
	

N
	

N
	

N
	

tbd
	

tbd
	

N
	

IPsec: Setup OPNsense for IKEv1 using XAuth

IKEv1 Mutual RSA + XAuth
	

N
	

N
	

N
	

tbd
	

tbd
	

Y IPsec: Setup Android Remote Access
	

IPsec: Setup OPNsense for IKEv1 using XAuth

IKEv1 Mutual PSK + XAuth
	

N
	

N
	

N
	

tbd
	

tbd
	

Y IPsec: Setup Android Remote Access
	

IPsec: Setup OPNsense for IKEv1 using XAuth

IKEv2 EAP-TLS
	

N
	

N
	

N
	

tbd
	

tbd
	

Y IPsec: Setup Android Remote Access
	

IPsec: Setup OPNsense for IKEv2 EAP-TLS

IKEv2 RSA local + EAP remote
	

N
	

N
	

N
	

tbd
	

tbd
	

Y IPsec: Setup Android Remote Access
	

IPsec: Setup OPNsense for IKEv2 EAP-TLS

IKEv2 EAP-MSCHAPv2
	

Y IPsec: Setup Windows Remote Access
	

Y IPsec: Setup Windows Remote Access
	

Y IPsec: Setup Linux Remote Access
	

Y
	

Y
	

Y IPsec: Setup Android Remote Access
	

IPsec: Setup OPNsense for IKEv2 EAP-MSCHAPv2

IKEv2 Mutual RSA + EAP-MSCHAPv2
	

N
	

N
	

N
	

tbd
	

tbd
	

Y IPsec: Setup Android Remote Access
	

IPsec: Setup OPNsense for IKEv2 Mutual RSA + MSCHAPv2

IKEv2 EAP-RADIUS
	

Y IPsec: Setup Windows Remote Access
	

Y IPsec: Setup Windows Remote Access
	

Y IPsec: Setup Linux Remote Access
	

Y
	

Y
	

Y IPsec: Setup Android Remote Access
	

IPsec: Setup OPNsense for IKEv2 EAP-RADIUS
List of examples

    IPsec: Setup OPNsense for IKEv2 EAP-RADIUS
    IPsec: Setup OPNsense for IKEv2 EAP-TLS
    IPsec: Setup OPNsense for IKEv1 using XAuth
    IPsec: Setup OPNsense for IKEv2 EAP-MSCHAPv2
    IPsec: Setup OPNsense for IKEv2 Mutual RSA + MSCHAPv2


IPsec: Setup OPNsense for IKEv2 EAP-RADIUS

Index

    IPsec: Setup OPNsense for IKEv2 EAP-RADIUS

        Step 1 - Create Certificates

        Step 2 - Setup Radius

        Step 3 - Mobile Clients

            IKE Extensions

        Step 4 - Phase 1 Mobile Clients

            Phase 1 General information

            Phase 1 proposal (Authentication)

            Phase 1 proposal (Algorithms)

        Step 5 - Phase 2 Mobile Clients

            General information

            Local Network

            Phase 2 proposal (SA/Key Exchange)

        Step 6 - Add IPsec Users

EAP-RADIUS via IKEv2 is nearly the same as EAP-MSCHAPv2, but authentication is done against a Radius instance. We assume you have read the first part at Road Warriors - Setup Remote Access
Step 1 - Create Certificates

For EAP-RADIUS with IKEv2 you need to create a Root CA and a server certificate for your Firewall.

Go to System ‣ Trust ‣ Authorities and click Add. Give it a Descriptive Name and as Method choose Create internal Certificate Authority. Increase the Lifetime and fill in the fields matching your local values. Now go to System ‣ Trust ‣ Certificates and create a new certificate for the Firewall itself. Important is to change the Type to server. The Common Name can be the hostname of the Firewall and set as Alternative Name the FQDN your Firewall how it is known to the WAN side. This is most important as your VPN will drop when the FQDN does not match the ones of the certificate.

If you already have a CA roll out a server certificate and import the CA itself via System ‣ Trust ‣ Authorities and the certificate with the key in System ‣ Trust ‣ Certificates.
Step 2 - Setup Radius

If you already have a local Radius server, add a new client with the IP address of your Firewall, set a shared secret, go to OPNsense UI to System ‣ Access ‣ Servers and add a new instance:

Descriptive Name
	

Name
	

Give it a name

Type
	

Radius
	

This is what we want

Hostname or IP Address
	

Radius IP
	

Set the IP of your Radius server

Shared Secret
	

s3cureP4ssW0rd
	

Choose a secure password

When you do not have an own Radius instance just use the OPNsense plugin and follow this guide: FreeRADIUS
Step 3 - Mobile Clients

First we will need to setup the mobile clients network and authentication source. Go to VPN ‣ IPsec ‣ Mobile Clients

For our example will use the following settings:
IKE Extensions

Enable
	

checked
	

check to enable mobile clients

User Authentication
	

Nothing
	

As we use Radius, no need to select anything

Group Authentication
	

none
	

Leave on none

Virtual Address Pool
	

10.10.0.0/24
	

Enter the IP range for the remote clients

You can select other options, but we will leave them all unchecked for this example.

Save your settings and select Create Phase1 when it appears. Then enter the Mobile Client Phase 1 setting.
Step 4 - Phase 1 Mobile Clients
Phase 1 General information

Connection method
	

default
	

default is ‘Start on traffic’

Key Exchange version
	

V2
	

only V2 is supported for EAP-RADIUS

Internet Protocol
	

IPv4
	

Interface
	

WAN
	

choose the interface connected to the internet

Description
	

MobileIPsec
	

freely chosen description
Phase 1 proposal (Authentication)

Authentication method
	

EAP-RADIUS
	

This is the method we want here

My identifier
	

Distinguished Name
	

Set the FQDN you used within certificate

My Certificate
	

Certificate
	

Choose the certificate from dropdown list
Phase 1 proposal (Algorithms)

Encryption algorithm
	

AES
	

For our example we will use AES/256 bits

Hash algoritm
	

SHA1, SHA256
	

SHA1 and SHA256 for compatibility

DH key group
	

1024, 2048 bit
	

1024 and 2048 bit for compatibility

Lifetime
	

28800 sec
	

lifetime before renegotiation

Advanced Options are fine by default.

Save your settings.
Step 5 - Phase 2 Mobile Clients

Press the button + in front of the phase 1 entry to add a new phase 2.
General information

Mode
	

Tunnel IPv4
	

Select Tunnel mode

Description
	

MobileIPsecP2
	

Freely chosen description
Local Network

Local Network
	

LAN subnet
	

Route the local LAN subnet
Phase 2 proposal (SA/Key Exchange)

Protocol
	

ESP
	

Choose ESP for encryption

Encryption algorithms
	

AES / 256
	

For this example we use AES 256

Hash algorithms
	

SHA1, SHA256
	

Same as before, mix SHA1 and SHA256

PFS Key group
	

off
	

Most mobile systems do not support PFS in Phase2

Lifetime
	

3600 sec
	

Save your settings and Enable IPsec, Select:
../../_images/ipsec_s2s_vpn_p1a_enable.png

Note

If you already had IPsec enabled and added Road Warrior setup, it is important to restart the whole service via services widget in the upper right corner of IPSec pages or via System ‣ Diagnostics ‣ Services ‣ Strongswan since applying configuration only reloads it, but a restart also loads the required modules of strongSwan.
Step 6 - Add IPsec Users

Go to your RADIUS management console and start adding users! If you are using our FreeRADIUS plugin follow the official guide: FreeRADIUS


IPsec: Setup OPNsense for IKEv2 EAP-TLS

Index

    IPsec: Setup OPNsense for IKEv2 EAP-TLS

        Step 1 - Create Certificates

        Step 2 - Mobile Clients

            IKE Extensions

        Step 3 - Phase 1 Mobile Clients

            Phase 1 General information

            Phase 1 proposal (Authentication)

            Phase 1 proposal (Algorithms)

        Step 3 - Phase 2 Mobile Clients

            General information

            Local Network

            Phase 2 proposal (SA/Key Exchange)

        Step 4 - Add IPsec Users

EAP-TLS via IKEv2 is based on client certificate authentication. Be sure to install the client certificate on your enduser device.
Step 1 - Create Certificates

For EAP-TLS with IKEv2 you need to create a Root CA and a server certificate for your Firewall.

Go to System ‣ Trust ‣ Authorities and click Add. Give it a Descriptive Name and as Method choose Create internal Certificate Authority. Increase the Lifetime and fill in the fields matching your local values. Now go to System ‣ Trust ‣ Certificates and create a new certificate for the Firewall itself. Important is to change the Type to server. The Common Name can be the hostname of the Firewall and set as Alternative Name the FQDN your Firewall how it is known to the WAN side. This is most important as your VPN will drop when the FQDN does not match the ones of the certificate.

If you already have a CA roll out a server certificate and import the CA itself via System ‣ Trust ‣ Authorities and the certificate with the key in System ‣ Trust ‣ Certificates.
Step 2 - Mobile Clients

First we will need to setup the mobile clients network and authentication source. Go to VPN ‣ IPsec ‣ Mobile Clients

For our example we will use the following settings:
IKE Extensions

Enable
	

checked
	

check to enable mobile clients

User Authentication
	

Local Database
	

For the example we use the Local Database

Group Authentication
	

none
	

Leave on none

Virtual Address Pool
	

10.10.0.0/24
	

Enter the IP range for the remote clients

You can select other options, but we will leave them all unchecked for this example.

Save your settings and select Create Phase1 when it appears. Then enter the Mobile Client Phase 1 setting.
Step 3 - Phase 1 Mobile Clients
Phase 1 General information

Connection method
	

default
	

default is ‘Start on traffic’

Key Exchange version
	

V2
	

only V2 is supported for EAP-TLS

Internet Protocol
	

IPv4
	

Interface
	

WAN
	

choose the interface connected to the internet

Description
	

MobileIPsec
	

freely chosen description
Phase 1 proposal (Authentication)

Authentication method
	

EAP-TLS
	

This is the method we want here

My identifier
	

Distinguished Name
	

Set the FQDN you used within certificate

My Certificate
	

Certificate
	

Choose the certificate from dropdown list

Note

Some clients require RSA as remote like Strongswan Android App. If you encounter problem with your client devices replace Authentication method to RSA (local) + EAP-TLS (remote)
Phase 1 proposal (Algorithms)

Encryption algorithm
	

AES
	

For our example we will use AES/256 bits

Hash algoritm
	

SHA1, SHA256
	

SHA1 and SHA256 for compatibility

DH key group
	

1024, 2048 bit
	

1024 and 2048 bit for compatibility

Lifetime
	

28800 sec
	

lifetime before renegotiation

Advanced Options are fine by default.

Save your settings.
Step 3 - Phase 2 Mobile Clients

Press the button + in front of the phase 1 entry to add a new phase 2.
General information

Mode
	

Tunnel IPv4
	

Select Tunnel mode

Description
	

MobileIPsecP2
	

Freely chosen description
Local Network

Local Network
	

LAN subnet
	

Route the local LAN subnet
Phase 2 proposal (SA/Key Exchange)

Protocol
	

ESP
	

Choose ESP for encryption

Encryption algorithms
	

AES / 256
	

For this example we use AES 256

Hash algorithms
	

SHA1, SHA256
	

Same as before, mix SHA1 and SHA256

PFS Key group
	

off
	

Most mobile systems do not support PFS in Phase2

Lifetime
	

3600 sec
	

Save your settings and Enable IPsec, Select:
../../_images/ipsec_s2s_vpn_p1a_enable.png

Note

If you already had IPsec enabled and added Road Warrior setup, it’s important to restart the whole service via services widget in the upper right corner of IPSec pages or via System ‣ Diagnostics ‣ Services ‣ Strongswan since applying configuration only reloads it, but a restart also loads the required modules of strongSwan.
Step 4 - Add IPsec Users

Go to System ‣ Trust ‣ Certificates and create a new client certificate. Just click Add, choose your CA and probably increase the lifetime. Everything else besides the CN can be left default. Give a Common Name and Save. Download the newly created certificate as PKCS12 and export it to your end user device.


IPsec: Setup OPNsense for IKEv1 using XAuth

Index

    IPsec: Setup OPNsense for IKEv1 using XAuth

        Step 1 - Create Certificates (only for RSA variants)

        Step 2 - Mobile Clients

            IKE Extensions

        Step 3 - Phase 1 Mobile Clients

            Phase 1 General information

            Phase 1 proposal (Authentication)

            Phase 1 proposal (Algorithms)

        Step 3 - Phase 2 Mobile Clients

            General information

            Local Network

            Phase 2 proposal (SA/Key Exchange)

        Step 4 - Add IPsec Users

        Step 5 - Add client certificate (for Mutual RSA)

        Step 6 - Configure Client

        Configure macOS Client

        Configure iOS Client

        Configure Android Client

XAuth was an addition to IKEv1 supporting user authentication credentials additionally to pre-shared keys or certificates. There are three different types supported by OPNsense which we will describe here.

Mutual PSK + XAuth: You define a pre-shared key which is the same for every user and after securing the channel the user authentication via XAuth comes into play. Mutual RSA + XAuth: Instead of using a pre-shared key, every device needs a client certificate to secure the connection plus XAuth for authentication. This is the most secure variant for IKEv1/XAuth but also with the most work to do. Hybrid RSA + XAuth: Hybrid RSA is the same as Mutual, without the need for a client certificate. Only the server will be authenticated (like using HTTPS) to prevent man-in-the-middle attacks like with Mutual PSK. It is more secure than PSK but does not need the complete roll-out process like with Mutual RSA.

We assume you have read the first part at Road Warriors - Setup Remote Access
Step 1 - Create Certificates (only for RSA variants)

For Mutual RSA + XAuth and Hybrid RSA + XAuth you need to create a Root CA and a server certificate for your Firewall.

Go to System ‣ Trust ‣ Authorities and click Add. Give it a Descriptive Name and as Method choose Create internal Certificate Authority. Increase the Lifetime and fill in the fields matching your local values. Now go to System ‣ Trust ‣ Certificates and create a new certificate for the Firewall itself. Important is to change the Type to server. The Common Name can be the hostname of the Firewall and set as Alternative Name the FQDN your Firewall how it is known to the WAN side. This is most important as your VPN will drop when the FQDN does not match the ones of the certificate.

If you already have a CA roll out a server certificate and import the CA itself via System ‣ Trust ‣ Authorities and the certificate with the key in System ‣ Trust ‣ Certificates.
Step 2 - Mobile Clients

First we will need to setup the mobile clients network and authentication source. Go to VPN ‣ IPsec ‣ Mobile Clients

For our example will use the following settings:
IKE Extensions

Enable
	

checked
	

check to enable mobile clients

User Authentication
	

Local Database
	

For the example we use the Local Database

Group Authentication
	

none
	

Leave on none

Virtual Address Pool
	

10.10.0.0/24
	

Enter the IP range for the remote clients

You can select other options, but we will leave them all unchecked for this example.

Save your settings and select Create Phase1 when it appears. Then enter the Mobile Client Phase 1 setting.
Step 3 - Phase 1 Mobile Clients
Phase 1 General information

Connection method
	

default
	

default is ‘Start on traffic’

Key Exchange version
	

V1
	

XAuth only works on V1

Internet Protocol
	

IPv4
	

Interface
	

WAN
	

choose the interface connected to the internet

Description
	

MobileIPsec
	

freely chosen description
Phase 1 proposal (Authentication)

Authentication method
	

XAuth
	

Choose one of the three available options

Negotiation mode
	

Main Mode
	

Use Main Mode here

My identifier
	

Distinguished Name
	

Set the FQDN you used within certificate, for PSK use “My IP address”

Pre-shared Key
	

Shared secret
	

For Mutual PSK + XAuth use this PSK, otherwise certificate below

My Certificate
	

Certificate
	

Choose the certificate from dropdown list, only valid for RSA variants
Phase 1 proposal (Algorithms)

Encryption algorithm
	

AES
	

For our example we will use AES/256 bits

Hash algoritm
	

SHA1, SHA256
	

SHA1 and SHA256 for compatibility

DH key group
	

1024, 2048 bit
	

1024 and 2048 bit for compatibility

Lifetime
	

28800 sec
	

lifetime before renegotiation

Advanced Options are fine by default.

Save your settings.
Step 3 - Phase 2 Mobile Clients

Press the button + in front of the phase 1 entry to add a new phase 2.
General information

Mode
	

Tunnel IPv4
	

Select Tunnel mode

Description
	

MobileIPsecP2
	

Freely chosen description
Local Network

Local Network
	

LAN subnet
	

Route the local LAN subnet
Phase 2 proposal (SA/Key Exchange)

Protocol
	

ESP
	

Choose ESP for encryption

Encryption algorithms
	

AES / 256
	

For this example we use AES 256

Hash algorithms
	

SHA1, SHA256
	

Same as before, mix SHA1 and SHA256

PFS Key group
	

off
	

Most mobile systems do not support PFS in Phase2

Lifetime
	

3600 sec
	

Save your settings and Enable IPsec, Select:
../../_images/ipsec_s2s_vpn_p1a_enable.png

Note

If you already had IPsec enabled and added Road Warrior setup, it is important to restart the whole service via services widget in the upper right corner of IPSec pages or via System ‣ Diagnostics ‣ Services ‣ Strongswan since applying configuration only reloads it, but a restart also loads the required modules of strongSwan.
Step 4 - Add IPsec Users

Go to System ‣ Access ‣ Users and press the + sign in the lower right corner to add a new user.

Enter the following into the form:

User Name
	

expert

Password
	

&test!9T

Save to apply.
Step 5 - Add client certificate (for Mutual RSA)

This step is only needed for Mutual RSA + XAuth!

Go to System ‣ Trust ‣ Certificates and create a new client certificate. Just click Add, choose your CA and probably increase the lifetime. Everything else besides the CN can be left default. Give a Common Name and Save. Download the newly created certificate as PKCS12 and export it to you enduser device.
Step 6 - Configure Client

To illustrate the client setup we will look at the configuration under macOS, including some screenshots. The configurations for Android and iOS will be settings only.

Note

Configuration samples listed here where created using latest macOS, iOS and Android devices on time of publication in February 2016.
Configure macOS Client

Start with opening your network settings (System Preferences ‣ Network) and Add a new network by pressing the + in the lower left corner.

Now select VPN and Cisco IPSec, give your connection a name and press Create.
../../_images/osx-ipsec-new.png

Now enter the details for our connection:
../../_images/osx-ipsec-conf1.png

Next press Authentication Settings to add the group name and pre-shared key.
../../_images/osx-ipsec-conf2.png

Press OK to save these settings and then Apply to apply them.

Now test the connection by selecting it from the list and hit Connect.
../../_images/osx-ipsec-connected.png

Done
Configure iOS Client

To add a VPN connection on an iOS device go to Settings ‣ General ‣ VPN. Select Add VPN Configuration chose IPsec and use the Following Settings:

Description
	

IPsec OPNsense
	

Freely chosen description

Server
	

172.18.0.164
	

Our server address

Account
	

expert
	

Username of the remote account

Password
	

&test!9T
	

Leave blank to be prompted every time

Preshared IPsec-key
	

At4aDMOAOub2NwT6gMHA
	

Our PSK
Configure Android Client

To add a VPN connection on an Android device go to Settings ‣ Connections ‣ more networks, select VPN. Press the + in the top right corner to add a new VPN connection.

Use the Following Settings:

Name
	

IPsec OPNsense
	

Freely chosen name

Type
	

IPSec Xauth PSK
	

As configured in OPNsense

Server address
	

172.18.0.164
	

Our server address

Preshared IPsec-key
	

At4aDMOAOub2NwT6gMHA
	

Our PSK

Save and try connecting. To connect enter Username and Password for the user expert we created in this example.


IPsec: Setup OPNsense for IKEv2 EAP-MSCHAPv2

Index

    IPsec: Setup OPNsense for IKEv2 EAP-MSCHAPv2

        Step 1 - Create Certificates

        Step 2 - Mobile Clients

            IKE Extensions

        Step 3 - Phase 1 Mobile Clients

            Phase 1 General information

            Phase 1 proposal (Authentication)

            Phase 1 proposal (Algorithms)

        Step 3 - Phase 2 Mobile Clients

            General information

            Local Network

            Phase 2 proposal (SA/Key Exchange)

        Step 4 - Add IPsec Users

EAP-MSCHAPv2 via IKEv2 is the most compatible combination. We assume you have read the first part at Road Warriors - Setup Remote Access
Step 1 - Create Certificates

For EAP-MSCHAPv2 with IKEv2 you need to create a Root CA and a server certificate for your Firewall.

Go to System ‣ Trust ‣ Authorities and click Add. Give it a Descriptive Name and as Method choose Create internal Certificate Authority. Increase the Lifetime and fill in the fields matching your local values. Now go to System ‣ Trust ‣ Certificates and create a new certificate for the Firewall itself. Important is to change the Type to server. The Common Name can be the hostname of the Firewall and set as Alternative Name the FQDN your Firewall how it is known to the WAN side. This is most important as your VPN will drop when the FQDN does not match the ones of the certificate.

If you already have a CA roll out a server certificate and import the CA itself via System ‣ Trust ‣ Authorities and the certificate with the key in System ‣ Trust ‣ Certificates.
Step 2 - Mobile Clients

First we will need to setup the mobile clients network and authentication source. Go to VPN ‣ IPsec ‣ Mobile Clients

For our example will use the following settings:
IKE Extensions

Enable
	

checked
	

check to enable mobile clients

User Authentication
	

Local Database
	

For the example we use the Local Database

Group Authentication
	

none
	

Leave on none

Virtual Address Pool
	

10.10.0.0/24
	

Enter the IP range for the remote clients

You can select other options, but we will leave them all unchecked for this example.

Save your settings and select Create Phase1 when it appears. Then enter the Mobile Client Phase 1 setting.
Step 3 - Phase 1 Mobile Clients
Phase 1 General information

Connection method
	

default
	

default is ‘Start on traffic’

Key Exchange version
	

V2
	

only V2 is supported for EAP-MSCHAPv2

Internet Protocol
	

IPv4
	

Interface
	

WAN
	

choose the interface connected to the internet

Description
	

MobileIPsec
	

freely chosen description
Phase 1 proposal (Authentication)

Authentication method
	

EAP-MSCHAPv2
	

This is the method we want here

My identifier
	

Distinguished Name
	

Set the FQDN you used within certificate

My Certificate
	

Certificate
	

Choose the certificate from dropdown list
Phase 1 proposal (Algorithms)

Encryption algorithm
	

AES
	

For our example we will use AES/256 bits

Hash algoritm
	

SHA1, SHA256
	

SHA1 and SHA256 for compatibility

DH key group
	

1024, 2048 bit
	

1024 and 2048 bit for compatibility

Lifetime
	

28800 sec
	

lifetime before renegotiation

Advanced Options are fine by default.

Save your settings.
Step 3 - Phase 2 Mobile Clients

Press the button + in front of the phase 1 entry to add a new phase 2.
General information

Mode
	

Tunnel IPv4
	

Select Tunnel mode

Description
	

MobileIPsecP2
	

Freely chosen description
Local Network

Local Network
	

LAN subnet
	

Route the local LAN subnet
Phase 2 proposal (SA/Key Exchange)

Protocol
	

ESP
	

Choose ESP for encryption

Encryption algorithms
	

AES / 256
	

For this example we use AES 256

Hash algorithms
	

SHA1, SHA256
	

Same as before, mix SHA1 and SHA256

PFS Key group
	

off
	

Most mobile systems do not support PFS in Phase2

Lifetime
	

3600 sec
	

Save your settings and Enable IPsec, Select:
../../_images/ipsec_s2s_vpn_p1a_enable.png

Note

If you already had IPsec enabled and added Road Warrior setup, it is important to restart the whole service via services widget in the upper right corner of IPSec pages or via System ‣ Diagnostics ‣ Services ‣ Strongswan since applying configuration only reloads it, but a restart also loads the required modules of strongSwan.
Step 4 - Add IPsec Users

Go to VPN ‣ IPsec ‣ Pre-Shared Keys and press Add.

Enter the following into the form:

Identifier
	

expert

Pre-Shared Key
	

&test!9T

Type
	

EAP

Save to apply and you are done here.

IPsec: Setup OPNsense for IKEv2 Mutual RSA + MSCHAPv2

Index

    IPsec: Setup OPNsense for IKEv2 Mutual RSA + MSCHAPv2

        Step 1 - Create Certificates

        Step 2 - Mobile Clients

            IKE Extensions

        Step 3 - Phase 1 Mobile Clients

            Phase 1 General information

            Phase 1 proposal (Authentication)

            Phase 1 proposal (Algorithms)

        Step 3 - Phase 2 Mobile Clients

            General information

            Local Network

            Phase 2 proposal (SA/Key Exchange)

        Step 4 - Add IPsec Users

Mutual RSA + MSCHAPv2 via IKEv2 is based on client certificate authentication combined with username and password via MSCHAPv2. Be sure that the client certificate is installed on your users device.
Step 1 - Create Certificates

For Mutual RSA + MSCHAPv2 with IKEv2 you need to create a Root CA and a server certificate for your Firewall.

Go to System ‣ Trust ‣ Authorities and click Add. Give it a Descriptive Name and as Method choose Create internal Certificate Authority. Increase the Lifetime and fill in the fields matching your local values. Now go to System ‣ Trust ‣ Certificates and create a new certificate for the Firewall itself. Important is to change the Type to server. The Common Name can be the hostname of the Firewall and set as Alternative Name the FQDN your Firewall how it is known to the WAN side. This is most important as your VPN will drop when the FQDN does not match the ones of the certificate.

If you already have a CA roll out a server certificate and import the CA itself via System ‣ Trust ‣ Authorities and the certificate with the key in System ‣ Trust ‣ Certificates.
Step 2 - Mobile Clients

First we will need to setup the mobile clients network and authentication source. Go to VPN ‣ IPsec ‣ Mobile Clients

For our example will use the following settings:
IKE Extensions

Enable
	

checked
	

check to enable mobile clients

User Authentication
	

Local Database
	

For the example we use the Local Database

Group Authentication
	

none
	

Leave on none

Virtual Address Pool
	

10.10.0.0/24
	

Enter the IP range for the remote clients

You can select other options, but we will leave them all unchecked for this example.

Save your settings and select Create Phase1 when it appears. Then enter the Mobile Client Phase 1 setting.
Step 3 - Phase 1 Mobile Clients
Phase 1 General information

Connection method
	

default
	

default is ‘Start on traffic’

Key Exchange version
	

V2
	

only V2 is supported for this type

Internet Protocol
	

IPv4
	

Interface
	

WAN
	

choose the interface connected to the internet

Description
	

MobileIPsec
	

freely chosen description
Phase 1 proposal (Authentication)

Authentication method
	

Mutual RSA + MSCHAPv2
	

This is the method we want here

My identifier
	

Distinguished Name
	

Set the FQDN you used within certificate

My Certificate
	

Certificate
	

Choose the certificate from dropdown list
Phase 1 proposal (Algorithms)

Encryption algorithm
	

AES
	

For our example we will use AES/256 bits

Hash algoritm
	

SHA1, SHA256
	

SHA1 and SHA256 for compatibility

DH key group
	

1024, 2048 bit
	

1024 and 2048 bit for compatibility

Lifetime
	

28800 sec
	

lifetime before renegotiation

Advanced Options are fine by default.

Save your settings.
Step 3 - Phase 2 Mobile Clients

Press the button + in front of the phase 1 entry to add a new phase 2.
General information

Mode
	

Tunnel IPv4
	

Select Tunnel mode

Description
	

MobileIPsecP2
	

Freely chosen description
Local Network

Local Network
	

LAN subnet
	

Route the local LAN subnet
Phase 2 proposal (SA/Key Exchange)

Protocol
	

ESP
	

Choose ESP for encryption

Encryption algorithms
	

AES / 256
	

For this example we use AES 256

Hash algorithms
	

SHA1, SHA256
	

Same as before, mix SHA1 and SHA256

PFS Key group
	

off
	

Most mobile systems do not support PFS in Phase2

Lifetime
	

3600 sec
	

Save your settings and Enable IPsec, Select:
../../_images/ipsec_s2s_vpn_p1a_enable.png

Note

If you already had IPsec enabled and added Road Warrior setup, it is important to restart the whole service via services widget in the upper right corner of IPSec pages or via System ‣ Diagnostics ‣ Services ‣ Strongswan since applying configuration only reloads it, but a restart also loads the required modules of strongSwan.
Step 4 - Add IPsec Users

Go to System ‣ Trust ‣ Certificates and create a new client certificate. Just click Add, choose your CA and probably increase the lifetime. Everything else besides the CN can be left default. Give a Common Name and Save. Download the newly created certificate as PKCS12 and export it to you enduser device.

Switch to VPN -> IPsec -> Pre-Shared Keys and press Add. Enter the following into the form:

Identifier
	

expert

Pre-Shared Key
	

&test!9T

Type
	

EAP


IPsec: Setup Android Remote Access

Index

    IPsec: Setup Android Remote Access

        Step 1 - Install Certificate

        Step 2 - Add VPN Connection

        Mutual PSK + XAuth

        Mutual RSA + XAuth

        IKEv2 + EAP-MSCHAPv2 or EAP-RADIUS

        IKEv2 + EAP-TLS

        IKEv2 + Mutual RSA + EAP-MSCHAPv2

Here you can see the configuration options for all compatible VPN types. We assume that you are familiar with adding a new VPN connection.

All screenshot were taken from Android version 7.
Step 1 - Install Certificate

For all RSA or IKEv2 related VPN configurations we need to install the Root CA and sometimes also the client certificate. Please export it do your device in a secure way like with an USB stick or a local file exchange service like Nextcloud. Under settings search for “cert” and you will be prompted for Install certificates. Navigate to the download directory and install the Root CA and - when configured - the client certificate.
Step 2 - Add VPN Connection

Add a new VPN connection via Settings ‣ More ‣ VPN, enter a Name and choose the type you need. Under Server address use your FQDN of the Firewall. Also keep in mind that it has to match with the CN of your certificate! Opening Advanced options you can set DNS search domains, DNS servers or Forwarding routes, which is the network you configured in Phase2 of your mobile VPN.

If you want to use IKEv2 you have to use the strongSwan app via App Store, as Android stock VPN only supports IKEv1.

See the following screenshots for the different VPN types:
Mutual PSK + XAuth
../../_images/ipsec_rw_android_mutualpsk1.png ../../_images/ipsec_rw_android_mutualpsk2.png
Mutual RSA + XAuth
../../_images/ipsec_rw_android_mutualrsa1.png ../../_images/ipsec_rw_android_mutualrsa2.png
IKEv2 + EAP-MSCHAPv2 or EAP-RADIUS
../../_images/ipsec_rw_android_ikev2-mschap1.png ../../_images/ipsec_rw_android_ikev2-mschap2.png ../../_images/ipsec_rw_android_ikev2-mschap3.png
IKEv2 + EAP-TLS

For EAP-TLS choose RSA (local)+ EAP-TLS (remote) in your OPNsense configuration.
../../_images/ipsec_rw_android_ikev2-cert.png
IKEv2 + Mutual RSA + EAP-MSCHAPv2

This is the most secure combination!
../../_images/ipsec_rw_android_ikev2-certeap.png


IPsec: Setup Linux Remote Access

Index

    IPsec: Setup Linux Remote Access

        Step 1 - Download Certificate

        Step 2 - Add VPN Connection

        IKEv2 + EAP-MSCHAPv2 or EAP-RADIUS

Here you can see the configuration options for all compatible VPN types. We assume that you are familiar with adding a new VPN connection.

The tests were done with Ubuntu 18.04 and network-manager-stronswan installed, Ubuntu only supports OpenVPN and PPTP with the default install.

It can be installed using the following command on the command line:

apt install network-manager-strongswan

Step 1 - Download Certificate

Download the Root CA from the OPNsense Firewall since it is needed for all EAP types with IKEv2.
Step 2 - Add VPN Connection

Open the network manager and add a new VPN connction. Choose IPSec/IKEv2, enter a Name and set the Address to the FQDN matching the one of the certificate at your Firewall.
IKEv2 + EAP-MSCHAPv2 or EAP-RADIUS
../../_images/ipsec-rw-linux-eapmschap.PNG


IPsec: Setup Windows Remote Access

Index

    IPsec: Setup Windows Remote Access

        Step 1 - Install Certificte

        Step 2 - Add VPN Connection

        Step 3 - Finetuning

        IKEv2 + EAP-MSCHAPv2 or EAP-RADIUS

Here you can see the configuration options for all compatible VPN types. We assume that you are familiar with adding a new VPN connection.

The tests were done with Windows 7 and 10.

All screenshot were taken from Network and Sharing Center ‣ Change adapter settings.
Step 1 - Install Certificte

Since Windows 7 also supports IKEv2 we need to install your Root Certificate Authority. Hit the Windows Start button and type mmc in search box. Go to File ‣ Add/Remove Snap-In. Choose Certificates ‣ Add ‣ Computer account. Open Certificate and navigate to Trusted Root Certificate Authorities, right click, All taks and import. Select the Root CA and install.

If you are using client certificates for authentication (e.g EAP-TLS) use a PKCS12/PFX and install it under Personal instead of Trusted Root Certificate Authorities. All included certificates will be installed in the correct folders.
../../_images/ipsec-rw-w7-cert.png
Step 2 - Add VPN Connection

Add a new VPN connection via Network and Sharing Center and choose as Internet Address the correct FQDN. This is imporatant when using certificates since the FQDN of your connection and the one in the certificate has to match! Then set a Username and Password and leave Domain emtpy.
Step 3 - Finetuning

Via Network and Sharing Center go to Change adapter settings and open the properties of your newly created adapter. Check that the FQDN is correct:
../../_images/ipsec-rw-w7-1.png

On tab Networking in IPv4 configuration under Advanced is the option Use defaut gateway on remote network. If this option is enabled, all traffic will be sent through the VPN (if IPsec SA matches). When unchecked, you have to set specific routes sent via VPN.
../../_images/ipsec-rw-w7-2.png
IKEv2 + EAP-MSCHAPv2 or EAP-RADIUS
../../_images/ipsec-rw-w7-eapmschap.png


Setup SSL VPN site to site tunnel

Site to site VPNs connect two locations with static public IP addresses and allow traffic to be routed between the two networks. This is most commonly used to connect an organization’s branch offices back to its main office, so branch users can access network resources in the main office.

Note

When using the site to site example with SSL/TLS instead of a shared key, make sure to configure “client specific overrides” as well to correctly bind the remote networks to the correct client.
Before you start

Before starting with the configuration of an OpenVPN SSL tunnel you need to have a working OPNsense installation with a unique LAN IP subnet for each side of your connection (your local network needs to be different than that of the remote network).

Note

For the sample we will use a private IP for our WAN connection. This requires us to disable the default block rule on WAN to allow private traffic. To do so, go to Interfaces ‣ [WAN] and uncheck “Block private networks”. (Don’t forget to save and apply)
../../_images/block_private_networks.png
Sample Setup

For the sample configuration we use two OPNsense boxes to simulate a site to site tunnel, with the following configuration:

Network Site A
Site A - Server

Hostname
	

fw1

WAN IP
	

172.10.1.1/16

LAN IP
	

192.168.1.1/24

LAN DHCP Range
	

192.168.1.100-192.168.1.200

Tunnel Network
	

10.10.0.0/24




Network Site B
Site B - Client

Hostname
	

fw2

WAN IP
	

172.10.2.1/16

LAN Net
	

192.168.2.0/24

LAN DHCP Range
	

192.168.2.100-192.168.2.200

Tunnel Network
	

10.10.0.0/24




Full Network Diagram Including SSL VPN Tunnel

SSL VPN Site-to-Site tunnel network
Step 1 - Add SSL Server

Adding a new SSL VPN server is relatively simple. We’ll start by adding a server that uses a shared key. This setup offers a good protection and it is easy to setup.

Go to VPN ‣ OpenVPN ‣ Servers and click on click Add in the top right corner of the form.

For our example will use the following settings (leave everything else on its default):

Server Mode
	

Peer to Peer (Shared Key)

Protocol
	

UDP

Device Mode
	

tun

Interface
	

WAN

Local port
	

1194

Description
	

SSL VPN Server

Shared Key
	

Leave on enabled (checked) to create a new key

DH Parameters Length
	

4096

Encryption algorithm
	

AES-256-CBC (256-bit)

Auth Digest Algorithm
	

SHA512 (512-bit)

IPv4 Tunnel Network
	

10.10.0.0/24

IPv4 Local Network/s
	

192.168.1.0/24

IPv4 Remote Network/s
	

192.168.2.0/24

Compression
	

Enabled with Adaptive Compression

    Click Save to add the new server.
    ../../_images/sslvpn_server.png 

Step 2 - Copy Shared Key

To copy the newly created shared key, click on the pencil icon next to the newly created SSL VPN server.

You will see the shared key, copy this and keep it safe!

Sample key:

#
# 2048 bit OpenVPN static key
#
-----BEGIN OpenVPN Static key V1-----
0960c87c3aafa8f306fe270c1564380b
7922543563a17b5d2636b4ef9412dd09
9ad44974ca1b293963e0f8ac9cbdd97c
2c31bf35f0df45c9e928ccb033e6d51d
2caaec02d649ad081c68d7bc7d28030e
9182c9597a83024097bea860e52d9c66
1b9e0048fbf951ce8659bc56edb7f9a1
14f7740fc9231a3750557e02eb112712
ac4b9980d4c740ec96a4357f3940ed90
d1bbf8eed3de135c886fe2eff8e8b943
ab1f52b59def4c9ebeacc5eb48425189
c43887a6237c29e0724f5f45a0f70635
10680bec8bfb67c21bf2b4866268594c
9ba093668064f9a898e6a6ad103b401d
b2047132f0dc8db2230db38444d689fa
ddba46bf6f892ae90c59415f94b82750
-----END OpenVPN Static key V1-----

Step 3 - Server Firewall Rules

To allow SSL VPN client connections, we should allow access to the OpenVPN server port on the WAN interface. When using multiple servers we need to open up each port.

For our configuration we only use one server accessible on UDP port 1194.
../../_images/sslvpn_wan_rule.png

Next we also need to allow traffic from the VPN client network (192.168.2.0/24). For our example we will allow client to access anything on our local network(s), however you may decide just to allow traffic to one or more IPs.
../../_images/sslvpn_openvpn_rule.png

You are done configuring Site A.
Step 4 - Site B Client

Now we will have to setup the client. Login to the second firewall, go to VPN ‣ OpenVPN ‣ Clients and click on add client in the upper right corner of the form.

Now enter the following into the form (and leave everything else default):

Server Mode
	

Peer to Peer (Shared Key)

Protocol
	

UDP

Device Mode
	

tun

Interface
	

WAN

Server host or address
	

172.10.1.1

Server port
	

1194

Description
	

SSL VPN Client

Shared Key
	

Uncheck to paste the shared key

…
	

Paste your shared key

Server Certificate
	

SSLVPN Server Certificate (CA: SSL VPN CA)

DH Parameters Length
	

4096

Encryption algorithm
	

AES-256-CBC (256-bit)

Auth Digest Algorithm
	

SHA512 (512-bit)

Hardware Crypto
	

No Hardware Crypto Acceleration

IPv4 Tunnel Network
	

10.10.0.0/24

IPv4 Remote Network/s
	

192.168.1.0/24

Compression
	

Enabled with Adaptive Compression

Now click on Save to apply your settings.

The Connection Status can be viewed under VPN ‣ OpenVPN ‣ Connection Status
../../_images/sslvpn_connection_status.png
Step 5 - Client Firewall Rules

To allow traffic from the remote network just add a rule under Firewall ‣ Rules OpenVPN tab.
../../_images/sslvpn_firewall_rule_client.png

Done


Setup SSL VPN Road Warrior
../../_images/sslvpn_image_new.png

Road Warriors are remote users who need secure access to the companies infrastructure. OPNsense uses OpenVPN for its SSL VPN Road Warrior setup and offers OTP (One Time Password) integration with standard tokens and Googles Authenticator.

Tip

Did you know that OPNsense offers two-factor authentication throughout the entire system? See for more information: Two-factor authentication

The main advantages of using SSL VPN for Road Warriors instead of IPsec are:

    Easy setup on almost all mobile clients using OPNsense’s Client Configuration Export.

    Fine grained access control by using multiple servers or Client Specific Overrides.

    No issues with NAT without NAT-T

With this how-to we’ll show you how to configure OPNsense’s SSL VPN for road warriors and give you configuration examples for:

    Two Factor Authentication (2FA)

    Multi Factor Authentication ( Client Certificate + Password + OTP )

    Client configuration on Windows, macOS, iOS and Android

Note

For the sample we will use a private IP for our WAN connection. This requires us to disable the default block rule on wan to allow private traffic. To do so, go to Interfaces ‣ [WAN] and uncheck “Block private networks”. (Dont forget to save and apply)
../../_images/block_private_networks.png
Sample Setup

For the sample configuration we configure OPNsense

Company Network with Remote Client
Company Network

Hostname
	

fw1

WAN IP
	

172.18.0.129

LAN IP
	

192.168.1.1/24

LAN DHCP Range
	

192.168.1.100-192.168.1.200

SSL VPN Clients
	

10.10.0.0/24
Step 0 - Preparation

For our example we will use two factor authentication (2FA) and multi factor authentication. So before we start with the SSL VPN configuration we will need an TOTP server and a valid signing certificate authority.

For completeness of this how-to we will also prepare a user.
Configure TOTP server

To configure a Time based One Time Password server go to System ‣ Access ‣ Servers and click Add in the top right corner of the form.

Tip

You can also use the quick-search to jump right into the the Access Server configuration. Try it by typing Ac… and see for yourself:
../../_images/qs-access_server.png

Now first change the Type to Local + Timebased One time Password Enter a Descriptive name such as TOTP VPN Access Server

For our example we leave everything else default as we will be using Google’s Authenticator and the defaults are correct for that.

When using other tokens you may need to change the Token length.

Click Save to add the new server.
Add Certificate Authority

The VPN server needs a certificate authority to sign client or server certificates.

To setup a new certificate authority go to System ‣ Trust ‣ Authorities and click Add in the top right corner of the form.

For our example we will use the following setting:

Descriptive name
	

SSL VPN CA

Method
	

Create an internal Certificate Authority

Key length (bits)
	

4096

Digest Algorithm
	

SHA512

Lifetime (days)
	

365

Country Code
	

NL

State or Province
	

ZH

City
	

Middelharnis

Organization
	

OPNsense

Email Address
	

spam@opnsense.org

Common Name
	

internal-sslvpn-ca

Click Save to add the new Certificate Authority.
Create a Server Certificate

After creating the Authority we will also need a certificate. To create a new certificate, go to System ‣ Trust ‣ Certificates and click Add in the upper right corner of the form.

Fill in the form with (leave the rest default):

Method
	

Create an internal Certificate

Descriptive name
	

SSLVPN Server Certificate

Certificate authority
	

SSL VPN CA

Type
	

Server Certificate

Key length (bits)
	

4096

Digest Algorithm
	

SHA512

Lifetime (days)
	

365

Country Code
	

NL

State or Province
	

ZH

City
	

Middelharnis

Organization
	

OPNsense

Email Address
	

spam@opnsense.org

Common Name
	

SSLVPN Server Certificate

Click Save to create the certificate.
Adding a User

To add a new user go to System ‣ Access ‣ Users and click Add in the top right corner.

Creating a user will be done in two steps, the first one is adding a basic user with a username, password, TOTP seed and user certificate. The second step (after saving) will be to activate the generated OTP seed with a Google Authenticator compatible app.

For the first step we enter:

Username
	

Donald

Password (2x)
	

S3cr3tP@ssw0rd

Full name
	

Donald Duck

Certificate
	

Check “Click to create a user certificate”

OTP seed
	

Check “Generate new secret”

    Click Save and you will be redirected to create the User Certificate. Fill in the Certificate form with the following for our example (leave anything not listed on its presented defaults):

Method
	

Create an internal Certificate

Descriptive Name
	

Leave default (Donald)

Certificate authority
	

SSL VPN CA

Type
	

Client Certificate

Key length
	

4096

Digest Algorithm
	

SHA512

Click Save and you will be redirected to the User page. Now we will activate your newly created seed with your Google Authenticator compatible app. To do so click in the Click to unhide button in the OTP QR code row and you will get a QR code to scan with your smartphone. See also: Configure 2FA TOTP & Google Authenticator

Note

Always make sure to use the same Certificate authority as the certificate authority created earlier, as this links the clients / users to the correct openvpn server.
Step 1 - Add SSL Server

Adding a new SSL VPN server is relatively simple. We’ll start by adding one that uses our two factor authentication. This setup offers a good protection and it is easy to setup on the clients as each client can use the same configuration.

Go to VPN ‣ OpenVPN ‣ Servers and click Add in the top right corner of the form.

For our example will use the following settings:

Description
	

My SSL VPN Server

Server Mode
	

Remote Access (SSL/TLS + User Auth)

Backend for authentication
	

TOTP VPN Access Server

Protocol
	

UDP

Device Mode
	

tun

Interface
	

WAN

Local port
	

1194

TLS Authentication
	

Leave both on enabled (checked)

Peer Certificate Revocation List
	

N/A

Server Certificate
	

SSLVPN Server Certificate (CA: SSL VPN CA)

DH Parameters Length
	

4096 bit

Encryption algorithm
	

AES-256-CBC (256-bit key, 128-bit block)

Auth Digest Algorithm
	

SHA512 (512-bit)

Certificate Depth
	

One (Client+Server)

IPv4 Tunnel Network
	

10.10.0.0/24

IPv6 Tunnel Network
	

Leave Empty

Redirect Gateway
	

Leave Unchecked

IPv4 Local Network/s
	

192.168.1.0/24

IPv6 Local Network/s
	

Leave Empty

IPv4 Remote Network/s
	

Leave Empty

IPv6 Remote Network/s
	

Leave Empty

Concurrent connections
	

Leave Empty

Compression
	

Enabled with Adaptive Compression

Type-of-Service
	

Leave Unchecked

Duplicate Connections
	

Leave Unchecked

Disable IPv6
	

Checked

Dynamic IP
	

Leave Unchecked

Address Pool
	

Leave Checked

Topology
	

Leave Unchecked

DNS Default Domain
	

Leave Unchecked

DNS Servers
	

Leave Unchecked

Force DNS cache update
	

Leave Unchecked

NTP Servers
	

Leave Unchecked

NetBIOS Options
	

Leave Unchecked

Client Management Port
	

Leave Unchecked

Renegotiate time
	

0

Note

Renegotiate time is used to renegotiate data channel key after n seconds (default=3600).When using a one time password, be advised that your connection will automatically drop because your password is not valid anymore.Set to 0 to disable, remember to change your client when changed later.

Click Save to add the new server.
../../_images/sslvpn_server.png

Tip

Use Strict User/CN Matching to force the usage of the same username as certificate CN, this prevents people from logging in using other credentials than the certificate name supplied. (e.g. fred can’t login as root)

Tip

The option Enforce local group can be used to constraint access to only users in a specific (set of) group(s)
Step 2 - Firewall Rules

To allow SSL VPN client connections, we should allow access to the OpenVPN server port on the WAN interface. When using multiple servers we need to open up each port.

For our configuration we only use one server, accessible on UDP port 1194.
../../_images/sslvpn_wan_rule.png

Next we also need to allow traffic from the VPN clients to our LAN interface. For our example we will allow client to access anything on our local area network, however you may decide just to allow traffic to one or more servers.
../../_images/sslvpn_openvpn_rule.png
Step 3 - Export Client Configuration

Using the Remote Access Server dropdown you can select the server for which you want to download client files, when there are certificates connected (using the same authority) it will list all available client certificates and attached users.
macOS & Windows

For macOS & Windows users we recommend using Viscosity from Sparklabs (https://www.sparklabs.com/viscosity/). Viscosity is very easy to setup and use and works well on both platforms.

Go to VPN ‣ OpenVPN ‣ Client Export and select the newly created VPN server from the list. Leave everything default and Download the Viscosity type from the list of export options under Export type.

Now on your Mac or Windows PC unpack the bundle and import the Viscosity.visc file. Double clicking it should be enough to get it imported. When asked for an application to open the file with search and select Viscosity.

Some sample screenshots (macOS):
../../_images/viscosity_files.png

Import Configuration
../../_images/viscosity_imported.png

Connect & login

In the password field enter your TOTP token first followed by your password.
../../_images/viscosity_login.png

Connected
../../_images/viscosity_connected.png
Android

For Android users we recommend using OpenVPN for Android (https://play.google.com/store/apps/details?id=de.blinkt.openvpn) from Arne Schwabe.

Go to VPN ‣ OpenVPN ‣ Client Export and select the newly created VPN server from the list. Leave everything default and Download the inline File only configuration from the list of export options under Export type.

Import the hostname-udp-1194-android-config.ovpn file into OpenVPN for Android. Clicking the file should be enough to get it imported. When asked for an application to open the file with, select OpenVPN for Android.
iOS

For iOS users we recommend using OpenVPN Connect (https://itunes.apple.com/us/app/openvpn-connect/id590379981) from OpenVPN Technologies.

Go to VPN ‣ OpenVPN ‣ Client Export and select the newly created VPN server from the list. Leave everything default and Download the inline File only configuration from the list of export options under Export type.

Import the hostname-udp-1194-ios-config.ovpn file into OpenVPN Connect. Clicking the file should be enough to get it imported. When asked for an application to open the file with, select OpenVPN Connect.
Step 4 - Multi Factor Authentication

For two factor authentication you need the factors username/password and a token. OPNsense supports another layer, namely a user certificate. This means that every user will be uniquely identified by the user certificate. In this case the multi factors are:

    User certificate

    Username/Password

    Token (TOTP)

Go to VPN ‣ OpenVPN ‣ Servers and click the pencil icon next to the server we just created to change the 2FA to multi factor authentication.

Now change Server Mode to Remote Access (SSL/TLS + User Auth) and leave everything else unchanged. Click Save on the bottom of the form.

Now when you go to the client exporter, you will see that each user is listed separately. In our case we see Donald listed. Exporting and importing this configuration works exactly the same as before, the only difference is that each user requires a User certificate and therefore their own configuration.
../../_images/sslvpn_client_certificate.png


Setup SSL VPN site to site tunnel

Site to site VPNs connect two locations with static public IP addresses and allow traffic to be routed between the two networks. This is most commonly used to connect an organization’s branch offices back to its main office, so branch users can access network resources in the main office.

Index

    Setup SSL VPN site to site tunnel

        Before you start

        Network topology

        Preparations

            Trust

            Static keys

            Prepare Site A

        Create a server instance (Site B)

        Create a client instance (Site A)

        Test connectivity

Before you start

Before starting with the configuration of an OpenVPN SSL tunnel you need to have a working OPNsense installation with a unique LAN IP subnet for each side of your connection (your local network needs to be different than that of the remote network).

Note

For the sample we will use a private IP for our WAN connection. This requires us to disable the default block rule on WAN to allow private traffic. To do so, go to Interfaces ‣ [WAN] and uncheck “Block private networks”. (Don’t forget to save and apply)
../../_images/block_private_networks.png
Network topology

The schema below describes the situation we are implementing. Two networks (A,B) and a transit network (10.10.8.0/24) to peer both firewalls. We will create a tunnel network 10.1.8.0/24 between both sites.
Preparations
Trust

In order to setup a tunnel on both ends, we need to configure certificates to warrant trust between both machines. We have chosen to setup the server on “Site B”, so we start with Trust configuration there.

    First we need an Authority which we are going to create in System ‣ Trust ‣ Authorities

            Select Create an internal Certificate Authority

            Choose cryptographic settings and a lifetime (you may want to increase the default as after this time you do need to redistribute certificates to both server and client).

            Add descriptive information for this CA (Descriptive name, City, Email, ..`)

            Set the Common Name to something descriptive for this certificate, like “Office-ovpn”

    Next generate a Certficate for the server using System ‣ Trust ‣ Certificates

        Select Create an internal Certificate

        Choose the just created authority in Certificate authority

        Add descriptive information for this CA (Descriptive name, whereabouts are copied from the CA)

        Set Type to Server

        Choose cryptographic settings, lifetime determines the validaty of the server certificate (you do need to track this yourself), it’s allowed to choose a longer period here

        Set the Common Name to the fqdn of this machine.

    As the client (Site A) will also need a Certificate, we need to create a certificate, also using System ‣ Trust ‣ Certificates

            Select Create an internal Certificate

            Choose the just created authority in Certificate authority

            Add descriptive information for this CA (Descriptive name, whereabouts are copied from the CA)

            Set Type to Client

            Choose cryptographic settings, lifetime determines the validaty of the server certificate (you do need to track this yourself), it’s allow to choose a longer period here

            Set the Common Name to username the other end will use for identification. For this example we use test-client

Note

It’s a best practice to offer each user it’s own certificate using the same common name as the username, although it is also possible to clients to share a certificate. When adding a certificate from the user manager the CN is automatically set to its name. In this example we will only authenticate using the certificate, no additional user or password will be required.
Static keys

We create a static key and define it’s use in VPN ‣ OpenVPN ‣ Instances ‣ Static Keys, for this example select auth as mode and click the gear button to generate one. Provide a description for this key.
Prepare Site A

    Copy the public part of the certificate authority to the firewall at Site A (use the download button and copy the contents into a new CA on this host)

    Copy the public and private part of the client certificate into a new one on Site A

    Copy the contents of the static key to a new entry and select the same type

Create a server instance (Site B)

Now the generic setup is done, we can configure a new server type instance via VPN ‣ OpenVPN ‣ Instances

Property
	

site B

Role
	

Server

Description
	

MyServer

Protocol
	

UDP (IPv4)

Port number
	

1194

Bind address
	

10.10.8.2 1

Server (IPv4)
	

10.1.8.0/24 (the tunnel network used)

Certificate
	

choose the prepared server certificate

TLS static key
	

choose the prepared static key

Local Network
	

192.168.8.0/24

Remote Network
	

10.0.8.0/24 2

Note 1

Leave empty to bind to all addresses assigned to this machine or use a loopback address combined with a port forward when the external address is not static.

Note 2

The network(s) served by this openvpn instance, after startup routes will be created. In order to bind the network to the correct client a Client Specific Overwrite is also needed.

Hit the apply button when the instance is configured and add a client specific overwrite in VPN ‣ OpenVPN ‣ Client Specific Overrides

Property
	

site B

Servers
	

leave empty or select our server

Common name
	

test-client

Remote Network
	

10.0.8.0/24 1

Note 1

The remote network bound to this common name, without this entry the traffic will not be routed between hosts.

Next go to Firewall ‣ Rules ‣ WAN and add a rule to allow traffic on port 1194/UDP from the other host. At minimum we should add a rule similar to this one:

Property
	

site B

Interface
	

WAN

Protocol
	

UDP

Destination port range
	

1194

Finally we are going to allow traffic on the tunnel itself by adding a rule to Firewall ‣ Rules ‣ OpenVPN, for this example we keep it simple and add one to allow all, in which case we can save the defaults when adding a rule.
Create a client instance (Site A)

With the server in place it’s time to setup the client on OPNsense, for this we go to VPN ‣ OpenVPN ‣ Instances and add a new instance using the following settings.

Property
	

site A

Role
	

Client

Description
	

MyClient

Protocol
	

UDP (IPv4)

Remote
	

10.10.8.2

Certificate
	

choose the prepared client certificate

TLS static key
	

choose the prepared static key

Remote Network
	

192.168.8.0/24
Test connectivity

Use the VPN: OpenVPN: Connection Status page to watch the status of both server and client, when passing traffic over the link on both ends the counters should increase.

Now try to ping from Site A (10.0.8.20) to Site B (192.168.8.20).


Setup SSL VPN Road Warrior
../../_images/sslvpn_image_new.png

Road Warriors are remote users who need secure access to the companies infrastructure. OPNsense uses OpenVPN for its SSL VPN Road Warrior setup and offers OTP (One Time Password) integration with standard tokens and Googles Authenticator.

Tip

Did you know that OPNsense offers two-factor authentication throughout the entire system? See for more information: Two-factor authentication

Note

For the sample we will use a private IP for our WAN connection. This requires us to disable the default block rule on wan to allow private traffic. To do so, go to Interfaces ‣ [WAN] and uncheck “Block private networks”. (Dont forget to save and apply)
../../_images/block_private_networks.png

Index

    Setup SSL VPN Road Warrior

        Before you start

        Network topology

        Preparations

            Trust

            Static keys

        Create a server instance

        Export client profile

        Test connectivity

Before you start

Before starting with the configuration of an OpenVPN SSL tunnel you need to have a working OPNsense installation with a unique LAN IP subnet for each side of your connection (your local network needs to be different than that of the remote network).

Note

For the sample we will use a private IP for our WAN connection. This requires us to disable the default block rule on WAN to allow private traffic. To do so, go to Interfaces ‣ [WAN] and uncheck “Block private networks”. (Don’t forget to save and apply)
../../_images/block_private_networks.png
Network topology

The schema below describes the situation we are implementing. One client using an “external” ip address of 10.0.8.2/24 a firewall we are connecting to at 10.0.8.1/24 constructing a tunnel using 10.2.8.0/24 to reach 192.168.8.0/24.
Preparations
Trust

In order to setup a tunnel on both ends, we need to configure certificates to warrant trust between the client and this server.

    First we need an Authority which we are going to create in System ‣ Trust ‣ Authorities

            Select Create an internal Certificate Authority

            Choose cryptographic settings and a lifetime (you may want to increase the default as after this time you do need to redistribute certificates to both server and client).

            Add descriptive information for this CA (Descriptive name, City, Email, ..`)

            Set the Common Name to something descriptive for this certificate, like “Office-ovpn”

    Next generate a Certficate for the server using System ‣ Trust ‣ Certificates

        Select Create an internal Certificate

        Choose the just created authority in Certificate authority

        Add descriptive information for this CA (Descriptive name, whereabouts are copied from the CA)

        Set Type to Server

        Choose cryptographic settings, lifetime determines the validaty of the server certificate (you do need to track this yourself), it’s allow to choose a longer period here

        Set the Common Name to the fqdn of this machine.

    For the client pc we will create a user and a certificate, from the System ‣ Access ‣ Users menu.

            Hit the [+] sign to create a new user, for this test we will call it test1

            Check the “Certificate -> Click to create a user certificate” option and hit “save”

            Next step in the certificate window, select “Create an internal Certificate” and “save”

Note

It’s a best practice to offer each user it’s own certificate using the same common name as the username, although it is also possible to clients to share a certificate. When adding a certificate from the user manager the CN is automatically set to its name. In this example we will only authenticate using the certificate, no additional user or password will be required.
Static keys

We create a static key and define it’s use in VPN ‣ OpenVPN ‣ Instances ‣ Static Keys, for this example select auth as mode and click the gear button to generate one. Provide a description for this key.
Create a server instance

Now the generic setup is done, we can configure a new server type instance via VPN ‣ OpenVPN ‣ Instances

Property
	

site B

Role
	

Server

Description
	

MyServer

Protocol
	

UDP (IPv4)

Port number
	

1194

Bind address
	

10.10.8.1 1

Server (IPv4)
	

10.1.8.0/24 (the tunnel network used)

Certificate
	

choose the prepared server certificate

TLS static key
	

choose the prepared static key

Authentication
	

Local Database 2

Strict User/CN Matching
	

[V] 3

Local Network
	

192.168.8.0/24

Redirect gateway
	

Leave empty 4

Note 1

Leave empty to bind to all addresses assigned to this machine or use a loopback address combined with a port forward when the external address is not static.

Note 2

When users are also required to use a one-time-password, just select an authentication server that supports the additional token.

Note 3

Selecting the “Strict User/CN Matching” option warrants only matching user/certificate can login, when sharing a single vertificate between clients this option needs to be deselected.

Note 4

If you want all outgoing IP traffic to be redirected over the VPN, you can set the option to default. For this to work, a manual NAT outbound rule must be created.

Next go to Firewall ‣ Rules ‣ WAN and add a rule to allow traffic on port 1194/UDP from the other host. At minimum we should add a rule similar to this one:

Property
	

site B

Interface
	

WAN

Protocol
	

UDP

Destination port range
	

1194

Finally we are going to allow traffic on the tunnel itself by adding a rule to Firewall ‣ Rules ‣ OpenVPN, for this example we keep it simple and add one to allow all, in which case we can save the defaults when adding a rule.
Export client profile

With the server in place it’s time to setup the client on OPNsense, for this we go to VPN ‣ OpenVPN ‣ Client Export and export a profile for the remote client.

Property
	

Value

Remote Access Server
	

select the Roadwarrior server “MyServer”

Export type
	

File Only 1

Hostname
	

10.10.8.1

Note 1

Most clients support the standard ovpn format, when using a tool like Viscosity from Sparklabs (https://www.sparklabs.com/viscosity/) you can also choose the proper type here.

Next client on the certificate with link user in the grid below and install the certificate on the client.
Test connectivity

After connecting the client, use the VPN: OpenVPN: Connection Status page to watch the status of the connected client. It should show the client with byte counters.

Now try to ping from Site A (10.0.8.20) to Site B (192.168.8.20).


WireGuard Site-to-Site Setup
Introduction

WireGuard is a simple and fast modern VPN protocol. It aims to be less complicated than IPSec, working more like ssh with private and public keys. It has fewer lines of code and is more easily audited than other VPN protocols. Initially released for the Linux kernel, it is now cross-platform and widely deployable.

Attention

Wireguard is useful for simple routed site to site tunnels and roadwarrior setups. To this date, it doesn’t play too nicely with high availability setups. That’s because the peer may keep polling a stale interface and misinterpret the other instance as being the one that is down and keep sending traffic there. Also, because Wireguard is bound to all interfaces (and not explicitely the CARP VIP), both High Availability firewalls will send handshakes and fight against each other for the remote Wireguard peer. This behavior was mitigated in 23.7.6 with Wireguard CARP vhid tracking that disables the Wireguard Instance with CARP VIPs in Backup state. In case of critical workloads and high availability, IPsec could still be the better choice.

Note

The following example covers an IPv4 Site to Site Wireguard Tunnel between two OPNsense Firewalls with public IPv4 addresses on their WAN interfaces. You will connect Site A LAN Net 172.16.0.0/24 to Site B LAN Net 192.168.0.0/24 using the Wireguard Transfer Net 10.2.2.0/24. Site A Public IP is 203.0.113.1 and Site B Public IP is 203.0.113.2.

Tip

You can also easily expand this Site to Site tunnel with IPv6 Global Unicast addresses (GUA) or Unique Local Addresses (ULA) to create a Dual Stack tunnel. Just add these IPv6 Networks (usually with /64 Prefix) to the allowed IPs and create Firewall rules to allow the traffic.
Step 1 - Installation

Install the os-wireguard plugin in System ‣ Firmware ‣ Plugins, refresh the GUI and you will soon find VPN ‣ WireGuard.
Step 2a - Setup WireGuard Instance on OPNsense Site A

Go to tab Instances and press + to create a new instance.

Enable the advanced mode toggle.

    Enabled
    	

    Checked

    Name
    	

    wgopn-site-a

    Public Key
    	

    Generate with “Generate new keypair” button

    Private Key
    	

    Generates automatically

    Listen Port
    	

    51820

    MTU
    	

    1420 (default) or 1412 if you use PPPoE

    Tunnel Address
    	

    10.2.2.1/24

    Peers
    	

    Populated in later step

Press Save and Apply.
Step 2b - Setup WireGuard Instance on OPNsense Site B

Go to tab Instance and press + to create a new instance.

Enable the advanced mode toggle.

    Enabled
    	

    Checked

    Name
    	

    wgopn-site-b

    Public Key
    	

    Generate with “Generate new keypair” button

    Private Key
    	

    Generates automatically

    Listen Port
    	

    51820

    MTU
    	

    1420 (default) or 1412 if you use PPPoE

    Tunnel Address
    	

    10.2.2.2/24

    Peers
    	

    Populated in later step

Press Save and Apply.
Step 3a - Setup WireGuard Peer on OPNsense Site A

Go to tab Peers and press + to create a new peer.

Enable the advanced mode toggle.

    Enabled
    	

    Checked

    Name
    	

    wgopn-site-b

    Public Key
    	

    Insert the public key of the instance from wgopn-site-b

    Shared Secret
    	

    Leave empty

    Allowed IPs
    	

    10.2.2.2/32 192.168.0.0/24

    Endpoint Address
    	

    203.0.113.2

    Endpoint Port
    	

    51820

Press Save and Apply.

Go to tab Instances and edit wgopn-site-a.

    Peers
    	

    wgopn-site-b

Press Save and Apply.
Step 3b - Setup WireGuard Peer on OPNsense Site B

Go to tab Peers and press + to create a new peer.

Enable the advanced mode toggle.

    Enabled
    	

    Checked

    Name
    	

    wgopn-site-a

    Public Key
    	

    Insert the public key of the instance instance from wgopn-site-a

    Shared Secret
    	

    Leave empty

    Allowed IPs
    	

    10.2.2.1/32 172.16.0.0/24

    Endpoint Address
    	

    203.0.113.1

    Endpoint Port
    	

    51820

Press Save and Apply.

Go to tab Instances and edit wgopn-site-b.

    Peers
    	

    wgopn-site-a

Press Save and Apply.

Tip

If one of your sites has a dynamic WAN IP address, you can leave the Endpoint Address on the site with the static IP address empty. The site with the dynamic IP will then be the initiator, and the site with the static IP will be the responder. Adjust the Firewall rule accordingly to allow any Source IP to connect to the static site.

Note

If you use hostnames in the Endpoint Address, Wireguard will only resolve them once when you start the tunnel. If both sites have dynamic Endpoint Addresses set, the tunnel will stop working when they both use DynDNS hostnames, and one (or both) sites receive a new WAN IP lease from the ISP. You could probably mitigate this with a cron job that restarts wireguard periodically.

Note

If a site is behind NAT, a keepalive has to be set on the site behind the NAT. The keepalive should be 25 seconds as stated in the official wireguard docs. It keeps the UDP session open when no traffic flows, preventing the wireguard tunnel from becoming stale because the outbound port changes.
Step 4a - Setup Firewall Site A

Go to Firewall ‣ Rules ‣ WAN add a new rule to allow incoming wireguard traffic from Site B.

    Action
    	

    Pass

    Interface
    	

    WAN

    Direction
    	

    In

    TCP/IP Version
    	

    IPv4

    Protocol
    	

    UDP

    Source
    	

    203.0.113.2

    Destination
    	

    203.0.113.1

    Destination port
    	

    51820

    Description
    	

    Allow Wireguard from Site B to Site A

Press Save and Apply.

Go to Firewall ‣ Settings ‣ Normalization and add a new rule to prevent fragmentation of traffic going through the wireguard tunnel.

    Interface
    	

    WireGuard (Group)

    Direction
    	

    Any

    Protocol
    	

    any

    Source
    	

    any

    Destination
    	

    any

    Destination port
    	

    any

    Description
    	

    Wireguard MSS Clamping Site A

    Max mss
    	

    1380 or lower, subtract at least 40 bytes from the Wireguard MTU

Note

By creating the normalization rules, you ensure that IPv4 TCP can pass through the Wireguard tunnel without being fragmented. Otherwise you could get working ICMP and UDP, but some encrypted TCP sessions will refuse to work. If you want to use IPv6 TCP, lower the MSS by 60 bytes instead of 40 bytes.
Step 4b - Setup Firewall Site B

Go to Firewall ‣ Rules ‣ WAN add a new rule to allow incoming wireguard traffic from Site A.

    Action
    	

    Pass

    Interface
    	

    WAN

    Direction
    	

    In

    TCP/IP Version
    	

    IPv4

    Protocol
    	

    UDP

    Source
    	

    203.0.113.1

    Destination
    	

    203.0.113.2

    Destination port
    	

    51820

    Description
    	

    Allow Wireguard from Site A to Site B

Press Save and Apply.

Go to Firewall ‣ Settings ‣ Normalization and add a new rule to prevent fragmentation of traffic going through the wireguard tunnel.

    Interface
    	

    WireGuard (Group)

    Direction
    	

    Any

    Protocol
    	

    any

    Source
    	

    any

    Destination
    	

    any

    Destination port
    	

    any

    Description
    	

    Wireguard MSS Clamping Site B

    Max mss
    	

    1380 or lower, subtract at least 40 bytes from the Wireguard MTU

Step 4c - Enable Wireguard on Site A and Site B

Go to VPN ‣ WireGuard ‣ Settings on both sites and Enable WireGuard

Press Apply and check VPN ‣ WireGuard ‣ Diagnostics. You should see Send and Received traffic and Handshake should be populated by a number. This happens as soon as the first traffic flows between the sites.

Your tunnel is now up and running.
Step 5 - Allow traffic between Site A LAN Net and Site B LAN Net

Go to OPNsense Site A Firewall ‣ Rules ‣ LAN A add a new rule.

    Action
    	

    Pass

    Interface
    	

    LAN A

    Direction
    	

    In

    TCP/IP Version
    	

    IPv4

    Protocol
    	

    Any

    Source
    	

    172.16.0.0/24

    Source port
    	

    Any

    Destination
    	

    192.168.0.0/24

    Destination port
    	

    Any

    Description
    	

    Allow LAN Site A to LAN Site B

Press Save and Apply.

Go to OPNsense Site A Firewall ‣ Rules ‣ Wireguard (Group) add a new rule.

    Action
    	

    Pass

    Interface
    	

    Wireguard (Group)

    Direction
    	

    In

    TCP/IP Version
    	

    IPv4

    Protocol
    	

    Any

    Source
    	

    192.168.0.0/24

    Source port
    	

    Any

    Destination
    	

    172.16.0.0/24

    Destination port
    	

    Any

    Description
    	

    Allow LAN Site B to LAN Site A

Press Save and Apply. Allowed IPs

Go to OPNsense Site B Firewall ‣ Rules ‣ LAN A add a new rule.

    Action
    	

    Pass

    Interface
    	

    LAN B

    Direction
    	

    In

    TCP/IP Version
    	

    IPv4

    Protocol
    	

    Any

    Source
    	

    192.168.0.0/24

    Source port
    	

    Any

    Destination
    	

    172.16.0.0/24

    Destination port
    	

    Any

    Description
    	

    Allow LAN Site B to LAN Site A

Press Save and Apply.

Go to OPNsense Site B Firewall ‣ Rules ‣ Wireguard (Group) add a new rule.

    Action
    	

    Pass

    Interface
    	

    Wireguard (Group)

    Direction
    	

    In

    TCP/IP Version
    	

    IPv4

    Protocol
    	

    Any

    Source
    	

    172.16.0.0/24

    Source port
    	

    Any

    Destination
    	

    192.168.0.0/24

    Destination port
    	

    Any

    Description
    	

    Allow LAN Site A to LAN Site B

Press Save and Apply.

Note

Now both sites have full access to the LAN of the other Site through the Wireguard Tunnel. For additional networks just add more Allowed IPs to the Wireguard Endpoints and adjust the firewall rules to allow the traffic.


WireGuard Road Warrior Setup
Introduction

WireGuard is a simple, fast VPN protocol using modern cryptography. It aims to be faster and less complex than IPsec whilst also being a considerably more performant alternative to OpenVPN. Initially released for the Linux kernel, it is now cross-platform and widely deployable.

This how-to describes setting up a central WireGuard Instance (server) on OPNsense and configuring one or more client peers to create a tunnel to it.
Step 1 - Configure the Wireguard Instance

    Go to VPN ‣ WireGuard ‣ Instances

    Click + to add a new Instance configuration

    Configure the Instance configuration as follows (if an option is not mentioned below, leave it as the default):

        Enabled
        	

        Checked

        Name
        	

        Call it whatever you want (eg HomeWireGuard )

        Public Key
        	

        This will initially be blank; Press the cogwheel to auto-generate new keys.

        Private Key
        	

        This will initially be blank; Press the cogwheel to auto-generate new keys.

        Listen Port
        	

        51820 or a higher numbered unique port

        MTU
        	

        1420 (default) or 1412 if you use PPPoE; it’s 80 bytes less than your WAN MTU

        Tunnel Address
        	

        For example, 10.10.10.1/24. See note below

        Peers
        	

        The (client) peers will be specified here; leave it blank initially until the Peer configuration is created in Step 2

        Disable Routes
        	

        Unchecked

Note

The tunnel address must be in CIDR notation and must be a unique IP and subnet for your network, such as if it was on a physically different routed interface. The subnet should be an appropriate size that includes all the client peers that will use the tunnel. For IPv4 it should be a private (RFC1918) address, for example 10.10.10.1/24. For IPv6, it could either be a unique ULA /64 address, or a unique GUA /64 address derived from your prefix delegation. Do not use a tunnel address that is a /32 (IPv4) or a /128 (IPv6)

Note

Leave the DNS Server field (which appears if advanced mode is selected) blank. Otherwise WireGuard will overwrite OPNsense’s DNS configuration

    Save the Instance configuration, and then click Save again

    Re-open the Instance configuration

    Copy the public key that has been generated in the configuration. This will be needed for the client device - see Step 6

    Save or Cancel to exit the configuration

Step 2 - Configure the client peer

    Go to VPN ‣ WireGuard ‣ Peers

    Click + to add a new Peer

    Configure the Peer as follows (if an option is not mentioned below, leave it as the default):

        Enabled
        	

        Checked

        Name
        	

        Call it whatever you want (eg Phone )

        Public Key
        	

        Insert the public key from the client; if needed skip ahead and start Step 6 to generate the client public key

        Allowed IPs
        	

        Unique tunnel IP address (IPv4 and/or IPv6) of client - it should be a /32 or /128 (as applicable) within the subnet configured on the WireGuard Instance. For example, 10.10.10.2/32

    Save the Peer configuration, and then click Save again

    Now go back to VPN ‣ WireGuard ‣ Instances

    Open the Instance configuration that was created in Step 1 (eg HomeWireGuard)

    In the Peers dropdown, select the newly created Peer (eg Phone)

    Save the Instance configuration again, and then click Save once more

    Repeat this Step 2 for as many clients as you wish to configure

Step 3 - Turn on/restart WireGuard

    Turn on WireGuard under VPN ‣ WireGuard ‣ General if it is not already on (click Apply after checking the checkbox)

    Otherwise, restart WireGuard - you can do this by turning it off and on under VPN ‣ WireGuard ‣ General (click Apply after both unchecking and checking the checkbox)

Step 4 - Assignments and routing

Note

The steps outlined in Steps 4(a) and 4(b) below may not be required at all in your circumstances. Strictly speaking, if you only intend for your clients to use the tunnel to access local IPs/subnets behind OPNsense, then neither step is actually necessary. If you intend to use the WireGuard tunnel to also access IPs outside of the local network, for example the public internet, then at least one, and perhaps both, of the steps will be required. This is explained below

However, it is useful to complete Step 4(a) anyway, for the reasons explained in that step
Step 4(a) - Assign an interface to WireGuard (recommended)

Hint

This step is not strictly necessary in any circumstances for a road warrior setup. However, it is useful to implement, for several reasons:

First, it generates an alias for the tunnel subnet(s) that can be used in firewall rules. Otherwise you will need to define your own alias or at least manually specify the subnet(s)

Second, it automatically adds an IPv4 outbound NAT rule, which will allow the tunnel to access IPv4 IPs outside of the local network (if that is desired), without needing to manually add a rule

Finally, it allows separation of the firewall rules of each WireGuard instance (each wgX device). Otherwise they all need to be configured on the default WireGuard group that OPNsense creates. This is more an organisational aesthetic, rather than an issue of substance

    Go to Interfaces ‣ Assignments

    In the dropdown next to “New interface:”, select the WireGuard device (wg1 if this is your first one)

    Add a description (eg HomeWireGuard)

    Click + to add it, then click Save

    Then select your new interface under the Interfaces menu

    Configure it as follows (if an option is not mentioned below, leave it as the default):

        Enable
        	

        Checked

        Lock
        	

        Checked

        Description
        	

        Same as under Assignments, if this box is not already populated

        IPv4 Configuration Type
        	

        None

        IPv6 Configuration Type
        	

        None

Note

There is no need to configure IPs on the interface. The tunnel address(es) specified in the Instance configuration for your server will be automatically assigned to the interface once WireGuard is restarted

    Save the interface configuration and then click Apply changes

    Restart WireGuard - you can do this by turning it off and on under VPN ‣ WireGuard ‣ General (click Apply after both unchecking and checking the checkbox)

Tip

When assigning interfaces, gateways can be added to them. This is useful if balancing traffic across multiple tunnels is required or in more complex routing scenarios. To do this, go to System ‣ Gateways ‣ Configuration and add a new gateway. Choose the relevant WireGuard interface and set the Gateway to dynamic. These scenarios are otherwise beyond the scope of this how-to

Tip

If Unbound DNS is configured with all interfaces registered it requires a reload of Unbound DNS to get the new Wireguard interface added. This is necessary to get DNS working through the VPN tunnel.
Step 4(b) - Create an outbound NAT rule

Hint

This step is only necessary (if at all) to allow client peers to access IPs outside of the local IPs/subnets behind OPNsense - see the note under Step 4. If an interface has already been assigned under Step 4(a), then it is not necessary for IPv4 traffic, and is only necessary for IPv6 traffic if the tunnel uses IPv6 ULAs (IPv6 GUAs don’t need NAT). So in many use cases this step can be skipped

    Go to Firewall ‣ NAT ‣ Outbound

    Select “Hybrid outbound NAT rule generation” if it is not already selected, and click Save and then Apply changes

    Click Add to add a new rule

    Configure the rule as follows (if an option is not mentioned below, leave it as the default):

        Interface
        	

        WAN

        TCP/IP Version
        	

        IPv4 or IPv6 (as applicable)

        Protocol
        	

        any

        Source invert
        	

        Unchecked

        Source address
        	

        If you assigned an interface under Step 4(a), select the generated alias for the interface subnet(s) (eg HomeWireGuard net ) - see note below if you didn’t assign this interface

        Source port
        	

        any

        Destination invert
        	

        Unchecked

        Destination address
        	

        any

        Destination port
        	

        any

        Translation / target
        	

        Interface address

        Description
        	

        Add one if you wish to

    Save the rule, and then click Apply changes

    Restart WireGuard - you can do this by turning it off and on under VPN ‣ WireGuard ‣ General (click Apply after both unchecking and checking the checkbox)

Hint

If you didn’t assign an interface as suggested in Step 4(a), then you will need to manually specify the source IPs/subnet(s) for the tunnel (for example, 10.10.10.0/24). It’s probably easiest to define an alias (via Firewall ‣ Aliases) for those IPs/subnet(s) and use that. If you have only one WireGuard Instance and only one WireGuard Peer configured, you can use the default WireGuard net, although this is generally not recommended due to unexpected behaviour
Step 5 - Create firewall rules

This will involve two steps - first creating a firewall rule on the WAN interface to allow clients to connect to the OPNsense WireGuard server, and then creating a firewall rule to allow access by the clients to whatever IPs they are intended to have access to.

    Go to Firewall ‣ Rules ‣ WAN

    Click Add to add a new rule

    Configure the rule as follows (if an option is not mentioned below, leave it as the default):

        Action
        	

        Pass

        Quick
        	

        Checked

        Interface
        	

        WAN

        Direction
        	

        in

        TCP/IP Version
        	

        IPv4 or IPv4+IPv6 (as desired, depending on how you want clients to connect to the server; note this is distinct from what type of traffic is allowed in the tunnel once established)

        Protocol
        	

        UDP

        Source / Invert
        	

        Unchecked

        Source
        	

        any

        Destination / Invert
        	

        Unchecked

        Destination
        	

        WAN address

        Destination port range
        	

        The WireGuard port specified in the Instance configuration in Step 1

        Description
        	

        Add one if you wish to

    Save the rule, and then click Apply Changes

    Then go to Firewall ‣ Rules ‣ [Name of interface assigned in Step 4(a)] - see note below if you didn’t assign this interface

    Click Add to add a new rule

    Configure the rule as follows (if an option is not mentioned below, leave it as the default):

        Action
        	

        Pass

        Quick
        	

        Checked

        Interface
        	

        Whatever interface you are configuring the rule on (eg HomeWireGuard ) - see note below

        Direction
        	

        in

        TCP/IP Version
        	

        IPv4 or IPv4+IPv6 (as applicable)

        Protocol
        	

        any

        Source / Invert
        	

        Unchecked

        Source
        	

        If you assigned an interface under Step 4(a), select the generated alias for the interface subnet(s) (eg HomeWireGuard net ) - see note below if you didn’t assign this interface

        Destination / Invert
        	

        Unchecked

        Destination
        	

        Specify the IPs that client peers should be able to access, eg “any” or specific IPs/subnets

        Destination port range
        	

        any

        Description
        	

        Add one if you wish to

    Save the rule, and then click Apply Changes

Note

If you didn’t assign an interface as suggested in Step 4(a), then the second firewall rule outlined above will need to be configured on the automatically created WireGuard group that appears once the Instance configuration is enabled and WireGuard is started. You will also need to manually specify the source IPs/subnet(s) for the tunnel. It’s probably easiest to define an alias (via Firewall ‣ Aliases) for those IPs/subnet(s) and use that. If you have only one WireGuard Instance and only one WireGuard Peer configured, you can use the default WireGuard net, although this is generally not recommended due to unexpected behaviour
Step 5a - Create normalization rules

    Go to Firewall ‣ Settings -> Normalization and press + to create one new normalization rule.

    If you only pass IPv4 traffic through the wireguard tunnel, create the following rule:

        Interface
        	

        WireGuard (Group)

        Direction
        	

        Any

        Protocol
        	

        any

        Source
        	

        any

        Destination
        	

        any

        Destination port
        	

        any

        Description
        	

        Wireguard MSS Clamping IPv4

        Max mss
        	

        1380 (default) or 1372 if you use PPPoE; it’s 40 bytes less than your Wireguard MTU

    Save the rule

    If you pass IPv4+IPv6 - or only IPv6 traffic - through the wireguard tunnel, create the following rule:

        Interface
        	

        WireGuard (Group)

        Direction
        	

        Any

        Protocol
        	

        any

        Source
        	

        any

        Destination
        	

        any

        Destination port
        	

        any

        Description
        	

        Wireguard MSS Clamping IPv6

        Max mss
        	

        1360 (default) or 1352 if you use PPPoE; it’s 60 bytes less than your Wireguard MTU

    Save the rule

Tip

    The header size for IPv4 is usually 20 bytes, and for TCP 20 bytes. In total thats 40 bytes for IPv4 TCP.

    IPv6 has a larger header size with 40 bytes. That encreases the total to 60 bytes for IPv6 TCP.

Note

By creating the normalization rules, you ensure that IPv4 TCP and IPv6 TCP can pass through the Wireguard tunnel without being fragmented. Otherwise you could get working ICMP and UDP, but some encrypted TCP sessions will refuse to work.
Step 6 - Configure the WireGuard client

Tip

Key generation can be performed on an appropriate device with WireGuard client tools installed. A one-liner for generating a matching private and public keypair is wg genkey | tee private.key | wg pubkey > public.key. Alternatively, WireGuard apps that can be used on some devices can automate key generation for you

Client configuration is largely beyond the scope of this how-to since there is such a wide array of possible targets (and corresponding configuration methods). An example client (and server) configuration is in the Appendix. The key pieces of information required to configure a client are described below:

    [Interface]
    	

    Address
    	

    Refers to the IP(s) specified as Allowed IPs in the Peer configuration on OPNsense. For example, 10.10.10.2/32

    PrivateKey
    	

    Refers to the private key that (along with a public key) needs to be manually or automatically generated on the client. The corresponding public key must then be copied into the Peer configuration on OPNsense for the relevant client peer - see Step 2

    DNS
    	

    Refers to the DNS servers that the client should use for the tunnel - see note below

    [Peer]
    	

    PublicKey
    	

    Refers to the public key that is generated on OPNsense. Copy the public key from the Instance configuration on OPNsense - see Step 1

    Endpoint
    	

    Refers to the public IP address or publicly resolvable domain name of your OPNsense host, and the port specified in the Instance configuration on OPNsense

    AllowedIPs
    	

    Refers to the traffic (by destination IPs/subnets) that is to be sent via the tunnel. For example, if all traffic on the client is to be sent through the tunnel, specify 0.0.0.0/0 (IPv4) and/or ::/0 (IPv6)

Note

If the DNS server(s) specified are only accessible over the tunnel, or you want them to be accessed over the tunnel, make sure they are covered by the AllowedIPs
Appendix - Example configurations

Warning

Do not re-use these example keys!

An example client configuration file:

[Interface]
PrivateKey = 8GboYh0YF3q/hJhoPFoL3HM/ObgOuC8YI6UXWsgWL2M=
Address = 10.10.10.2/32, fd00:1234:abcd:ef09:10:2/128
DNS = 192.168.1.254, fd00:1234:abcd:ef09:1:254

[Peer]
PublicKey = OwdegSTyhlpw7Dbpg8VSUBKXF9CxoQp2gAOdwgqtPVI=
AllowedIPs = 0.0.0.0/0, ::/0
Endpoint = opnsense.example.com:51820

An example server configuration file:

[Interface]
Address = 10.10.10.1/24, fd00:1234:abcd:ef09:10:1/64
ListenPort = 51820
PrivateKey = YNqHwpcAmVj0lVzPSt3oUnL7cRPKB/geVxccs0C0kk0=

[Peer]
PublicKey = CLnGaiAfyf6kTBJKh0M529MnlqfFqoWJ5K4IAJ2+X08=
AllowedIPs = 10.10.10.2/32, fd00:1234:abcd:ef09:10:2/128


WireGuard AzireVPN Road Warrior Setup
Introduction

AzireVPN is an international VPN provider, co-locating in multiple datacenters and offering secure tunneling in respect to privacy. To set up a WireGuard VPN to AzireVPN we assume you are familiar with the concepts of WireGuard you that you have read the basic howto WireGuard Road Warrior Setup.
Step 1 - Get AzireVPN configuration

For an automated rollout of configuration, AzireVPN will create a private key in your browser and send the public key via an API call to their servers. To get a configuration login to your account

Via Options you can select the country where you want to break out, choose a port (default ist fine), and set the protocol to tunnel (we only cover IPv4).

Hit Download at the end of the page to get the preconfigured text file and open it in your favorite text editor.
Step 2 - Setup WireGuard Instance

Go to tab Instances and create a new instance. Give it a Name and set a desired Listen Port. If you have more than one server instance be aware that you can use the Listen Port only once. In the field Private Key insert the value from your text file and leave Public Key empty. DNS and Tunnel Address has also to be taken from the configuration. Hit Save and go to Peers tab.

On Peers tab create a new Peer, give it a Name, set 0.0.0.0/0 in Allowed IPs and set the DNS name from your configuration in Endpoint Address. Don’t forget to do this also for the port.

Go back to tab Instances, open the instance and choose the newly created peer in Peers.

Now we can Enable the VPN in tab General and continue with the setup.
Step 3 - Assignments and Routing

To let you internal clients go through the tunnel you have to add a NAT entry. Go to Firewall ‣ NAT ‣ Outbound and add a rule. Check that rule generation is set to manual or hybrid. Add a rule and select Wireguard as Interface. Source should be your LAN network and set Translation / target to interface address.

When assigning interfaces we can also add gateways to them. This would offer you the chance to balance traffic via different VPN providers or do more complex routing scenarios.


WireGuard MullvadVPN Road Warrior Setup
Introduction

MullvadVPN is a cloud-based VPN provider, offering secure tunneling in respect to privacy. To set up a WireGuard VPN to MullvadVPN we assume you are familiar with the concepts of WireGuard you that you have read the basic howto WireGuard Road Warrior Setup.
Step 1 - Setup WireGuard Instance

Go to tab Instances and create a new instance. Give it a Name and set a desired Listen Port. If you have more than one server instance be aware that you can use the Listen Port only once. In the field Tunnel Address insert an unsused private IP address and subnet mask. We don’t need it in the first step, but as it is required we can’t go on without it. Every other field can be left blank.

Hit Save and open your instance again to write down your public key. You need it to get the rest of the configuration from the Mullvad API servers.

Now change to your OPNsense CLI via SSH or Console and execute either of the curl strings below. Please replace YOURACCOUNTNUMBER with your own ID you got from MullvadVPN and YOURPUBLICKEY with the one in your Instances

The command below is for Mullvad’s standard API. DNS requests through a tunnel that uses tunnel IPs generated via this API are “hijacked”, so that Mullvad’s DNS servers are used to avoid leaks:

curl -sSL https://api.mullvad.net/wg/ -d account=YOURACCOUNTNUMBER --data-urlencode pubkey=YOURPUBLICKEY

The alternative command below is for Mullvad’s other API. DNS requests through the tunnel are not hijacked when using tunnel IPs generated via this API:

curl -sSL https://api.mullvad.net/app/v1/wireguard-keys -H "Content-Type: application/json" -H "Authorization: Token YOURACCOUNTNUMBER" -d '{"pubkey":"YOURPUBLICKEY"}'

What you receive is what WireGuard calls Allowed IP for your WireGuard Instance. Edit your instance again and remove the value of Tunnel Address you used when setting it up and change it to the one you got.

On Peers tab create a new Peer, give it a Name, set 0.0.0.0/0 in Allowed IPs and set the DNS to 193.138.218.74. This is the one MulladVPN provides for privacy.

Now go to the WireGuard server list and choose the one you like to use as your breakout. Write down it’s public key and set it as Public Key.

Also do not forget Endpoint Address and Endpoint Port. The Endpoint Port is 51820. The Endpoint Address will depend on which Mullvad server you wish to use. For example, if you want to use the “nl1-wireguard” server, the Endpoint Address will be nl1-wireguard.mullvad.net.

Go back to tab Instances, open the instance and choose the newly created peer in Peers.

Now we can Enable the VPN in tab General and continue with the setup.
Step 2 - Assignments and Routing

To let you internal clients go through the tunnel you have to add a NAT entry. Go to Firewall ‣ NAT ‣ Outbound and add a rule. Check that rule generation is set to manual or hybrid. Add a rule and select Wireguard as Interface. Source should be your LAN network and set Translation / target to interface address.

When assigning interfaces we can also add gateways to them. This would offer you the chance to balance traffic via different VPN providers or do more complex routing scenarios.

See the how-to on selective routing for further information WireGuard Selective Routing to External VPN Endpoint


WireGuard ProtonVPN Road Warrior Setup
Introduction

ProtonVPN is a cloud-based VPN provider, offering secure tunneling with respect to privacy. To set up a WireGuard VPN to ProtonVPN we assume you are familiar with the concepts of WireGuard that you have read the basic howto WireGuard Road Warrior Setup.
Step 1 - Download ProtonVPN configuration

The configuration is available in the ProtonVPN website. The landing page appears after signing in. Click on Downloads from the left hand panel or go to the downloads page and scroll down to the WireGuard configuration

The existing WireGuard configurations appear first with their expiration dates and following are the options to generate new ones.
../../_images/proton_wireguard_configuration.png

    Select a name for the generated configuration

Note

If a name is not provided a unique ID will be generated by ProtonVPN

    Select Router as a platform

    Select VPN options

        There are 3 options for NetShield blocker filtering

            No filtering

            Block malware

            Block malware, ads and trackers

        There are also options to enable Moderate NAT, NAT-PMP (Port Forwarding) and VPN accelerator as well. The features are documented in the ProtonVPN website.

        Pick the options that satisfy your requirements and move on to the next section.

    Select a server to connect to

        ProtonVPN proposes the best server or allows the user to select manually.

        When selecting manually there are 2 main choices:

            Standard vs Secure Core configuration

            Exit country

        Pick the one that satisfies your requirements and click on Create to generate the configuration.

        Upon successful completion a window like the following will appear on the screen.

../../_images/proton_configuration_1.png

The full configuration looks like this:

[Interface]
# Bouncing = 0
# NetShield = 1
# Moderate NAT = off
# NAT-PMP (Port Forwarding) = off
# VPN Accelerator = on
PrivateKey = 2Kh7TlGz+7PCFa0jEHat8IWkYZgPmDLAiagGq+dyLks=
Address = 10.2.0.2/32
DNS = 10.2.0.1

[Peer]
# NO#21
PublicKey = KOITt3KQ72LHPbpVp7kp4cQo/qw2qvKPrN732UTWWFw=
AllowedIPs = 0.0.0.0/0
Endpoint = 146.70.170.18:51820

Note

The private key disappears after creating the configuration so it must be stored. It will be used in the following section to generate the public key. Both are needed for successful configuration.

Warning

Do not re-use the private keys in these examples
Step 2 - Generate public key from private key

ProtonVPN, unlike Mullvad or other WG implementations, only provides a private key. The private key appears briefly when generating the configuration in the web UI. The public key will be derived from the private key with the “wg pubkey” command.

Windows

echo wgPrivateKey | wg pubkey

Linux

wg pubkey < wgPrivateKey

Step 3 - Setup WireGuard Instance

    Go to VPN ‣ WireGuard ‣ Settings ‣ Instances

    Click + to add a new Instance configuration

    Turn on “advanced mode”

    Configure the Instance from the downloaded ProtonVPN configuration as follows (if an option is not mentioned below, leave it as the default):

        Enabled
        	

        Checked

        Name
        	

        Call it whatever you want (eg ProtonVPN-ExitCountry )

        Public Key
        	

        Insert the derived public key from the previous step

        Private Key
        	

        Insert the PrivateKey field from the [Interface] section

        Listen Port
        	

        51820 or a higher numbered unique port

        MTU
        	

        Needs to be 80 bytes shorter than normal MTU. Default 1420

        DNS Server
        	

        Insert the DNS field from the [Interface] section as is (without subnet mask)

        Tunnel Address
        	

        Insert the Address field from the [Interface] section` in CIDR format, eg 10.2.0.2/32

        Peers
        	

        Leave blank for now

        Disable Routes
        	

        Checked

        Gateway
        	

        Insert the same address as in the DNS Server field above

    Save the Instance configuration, and then click Apply

Step 4 - Configure the peer

    Go to VPN ‣ WireGuard ‣ Settings ‣ Peers

    Click + to add a new Peer

    Configure the Peer from the downloaded ProtonVPN configuration as follows (if an option is not mentioned below, leave it as the default):

        Enabled
        	

        Checked

        Name
        	

        Call it whatever you want (eg ProtonVPN_Location )

        Public Key
        	

        Insert the PublicKey field from the [Peer] section

        Allowed IPs
        	

        0.0.0.0/0

        Endpoint Address
        	

        Insert the IP address from the Endpoint field in the [Peer] section

        Endpoint Port
        	

        Insert the port number from the Endpoint field in the [Peer] section

        Instances
        	

        Select the instance configured in the previous step

        Keepalive
        	

        25

    Save the Peer configuration, and then click Apply

Note

The UI for configuring the Instances and Peers changed with OPNsense verion 23.7.9 so some of the fields may be in different places.
Step 5 - Turn on WireGuard

Turn on WireGuard under VPN ‣ WireGuard ‣ Settings ‣ General if it is not already on
Step 6 - Configure assignments, gateways and routing

The rest of the steps are mostly the same as described in the how-to on selective routing WireGuard Selective Routing to External VPN Endpoint
ProtonVPN DNS leaks

Since ProtonVPN provides a DNS server an extra firewall rule may be required to route the DNS traffic to the WireGuard gateway.

    Go to Firewall ‣ Rules ‣ [Name of interface for network in which hosts/network resides, eg LAN for LAN hosts]

    Click Add to add a new rule

    Configure the rule as follows (if an option is not mentioned below, leave it as the default):

        Action
        	

        Pass

        Quick
        	

        Checked

        Interface
        	

        Whatever interface you are configuring the rule on

        Direction
        	

        in

        TCP/IP Version
        	

        IPv4

        Protocol
        	

        TCP/UDP

        Source / Invert
        	

        Unchecked

        Source
        	

        IP of your DNS server

        Destination / Invert
        	

        Checked

        Destination
        	

        Select the RFC1918_Networks Alias you created above in the dropdown

        Destination port range
        	

        DNS - DNS

        Description
        	

        Add one if you wish to

        Gateway
        	

        Select the WireGuard gateway created according to the selective routing how-to page (eg WAN_ProtonVPN )

    Save the rule, and then click Apply Changes

    Then make sure that the new rule is above any other rule on the interface that would otherwise interfere with its operation. For example, you want your new rule to be above the “Default allow LAN to any rule”

In layman terms if the DNS server makes any requests to a non-local address it will go through the VPN gateway.

All images from ProtonVPN website are the property of ProtonVPN and are used with written permission.


WireGuard Selective Routing to External VPN Endpoint
Introduction

This how-to is designed to assist with setting up WireGuard on OPNsense to use selective routing to an external VPN peer - most commonly to an external VPN provider.

These circumstances may apply where only certain local hosts are intended to use the VPN tunnel. Or it could apply where multiple connections to the VPN provider are desired, with each connection intended to be used by different specific local hosts.

This how-to focuses on the configuration of OPNsense. You will also have to configure the peer at your VPN provider - consult your VPN provider’s documentation as to how to do that.

Your OPNsense WireGuard Instance public key will need to be registered with your VPN provider, and you will need to get your VPN provider’s endpoint public key and the VPN tunnel IP provided for your WireGuard Instance by your VPN provider. In some cases, you will not be able to get the Peer public key and VPN tunnel IP until you register your WireGuard Instance public key. In that case, create the OPNsense Instance configuration first, using a dummy tunnel IP and no peer selected, so that the public key is generated, and then update the configuration later once the other information is known.

For an example of configuring the peer at a VPN provider (Mullvad), see Step 1 of the how-to WireGuard MullvadVPN Road Warrior Setup.

This how-to primarily focuses on IPv4 configuration. It can be readily adapted for IPv6 as well. See Configuring IPv6 below.
Step 1 - Configure the peer

    Go to VPN ‣ WireGuard ‣ Peers

    Click + to add a new Peer

    Configure the Peer as follows (if an option is not mentioned below, leave it as the default):

        Enabled
        	

        Checked

        Name
        	

        Call it whatever you want (eg VPNProviderName_Location )

        Public Key
        	

        Insert the public key from your VPN provider

        Allowed IPs
        	

        0.0.0.0/0

        Endpoint Address
        	

        Insert the public IP address (desirably) or domain name of your VPN provider, as provided by it

        Endpoint Port
        	

        Insert the port of your VPN provider, as provided by it

        Keepalive
        	

        25

    Save the Peer configuration, and then click Save again

Step 2 - Configure the WireGuard Instance

    Go to VPN ‣ WireGuard ‣ Instances

    Click + to add a new Instance configuration

    Turn on “advanced mode”

    Configure the Instance configuration as follows (if an option is not mentioned below, leave it as the default):

        Enabled
        	

        Checked

        Name
        	

        Call it whatever you want (eg VPNProviderName )

        Public Key
        	

        This will initially be blank; it will be populated once the configuration is saved

        Private Key
        	

        This will initially be blank; it will be populated once the configuration is saved

        Listen Port
        	

        51820 or a higher numbered unique port

        DNS Server
        	

        Leave this blank, otherwise WireGuard will overwrite OPNsense’s DNS configuration

        Tunnel Address
        	

        Insert the WireGuard Instance VPN tunnel IP provided by your VPN provider, in CIDR format, eg 10.24.24.10/32

        Peers
        	

        In the dropdown, select the Peer you configured above

        Disable Routes
        	

        Checked

        Gateway
        	

        Specify an IP that is 1 number below your VPN tunnel IP, eg 10.24.24.9 - see note below

Note

The IP you choose for the Gateway is essentially arbitrary; pretty much any unique IP will do. The suggestion here is for convenience and to avoid conflicts

    Save the Instance configuration, and then click Save again

Step 3 - Turn on WireGuard

Turn on WireGuard under VPN ‣ WireGuard ‣ General if it is not already on
Step 4 - Assign an interface to WireGuard and enable it

    Go to Interfaces ‣ Assignments

    In the dropdown next to “New interface:”, select the WireGuard device (wg0 if this is your first one)

    Add a description (eg WAN_VPNProviderName)

    Click + to add it, then click Save

    Then select your new interface under the Interfaces menu

    Configure it as follows (if an option is not mentioned below, leave it as the default):

        Enable
        	

        Checked

        Lock
        	

        Checked if you wish to

        Description
        	

        Same as under Assignments, if this box is not already populated

        IPv4 Configuration Type
        	

        None

        IPv6 Configuration Type
        	

        None

    Save the interface configuration and then click Apply changes

Step 5 - Restart WireGuard

Now restart WireGuard - you can do this from the Dashboard (if you have the services widget) or by turning it off and on under VPN ‣ WireGuard ‣ General
Step 6 - Create a gateway

    Go to System ‣ Gateways ‣ Configuration

    Click Add

    Configure the gateway as follows (if an option is not mentioned below, leave it as the default):

        Name
        	

        Call it whatever you want, easiest to name it the same as the interface

        Description
        	

        Add one if you wish to

        Interface
        	

        Select your newly created interface in the dropdown

        Address Family
        	

        Select IPv4 in the dropdown

        IP address
        	

        Insert the gateway IP that you configured under the WireGuard Instance configuration

        Far Gateway
        	

        Checked

        Disable Gateway Monitoring
        	

        Unchecked

        Monitor IP
        	

        Insert the endpoint VPN tunnel IP (NOT the public IP) of your VPN provider - see note below

Note

Specifying the endpoint VPN tunnel IP is preferable. As an alternative, you could include an external IP such as 1.1.1.1 or 8.8.8.8, but be aware that this IP will only be accessible through the VPN tunnel (OPNsense creates a static route for it), and therefore will not be accessible from local hosts that are not using the tunnel

Some VPN providers will include the VPN tunnel IP of the endpoint in the configuration data they provide. For others (such as Mullvad), you can get the IP by running a traceroute from a host that is using the tunnel - the first hop after OPNsense is the VPN provider’s tunnel IP

    Save the gateway configuration and then click Apply changes

Step 7 - Create an Alias for the relevant local hosts that will access the tunnel

    Go to Firewall ‣ Aliases

    Click + to add a new Alias

    Configure the Alias as follows (if an option is not mentioned below, leave it as the default):

        Enabled
        	

        Checked

        Name
        	

        Call it whatever your want, eg WG_VPN_Hosts

        Type
        	

        Select either Host(s) or Network(s) in the dropdown, depending on whether you want specific host IPs to use the tunnel, or an entire local network (such as a VLAN)

        Content
        	

        Enter the host IPs, or the network in CIDR format

        Description
        	

        Add one if you wish to

    Save the Alias, and then click Apply

Step 8 - Create a firewall rule

The purpose of this step is to create a firewall rule to allow the relevant hosts to access the tunnel. At the same time, it also ensures that the relevant hosts using the tunnel can still access local resources as necessary - such as a local DNS server, or file storage

The step has two parts - first creating a second Alias for all local (private) networks, and then creating the firewall rule itself. The ultimate effect of these two steps is that only traffic from the relevant hosts that is destined for non-local destinations will be sent down the tunnel

Note

The rule below will mean that no local (private) IPs can be accessed over the tunnel. You may have a need however to access certain IPs or networks at the VPN endpoint, such as a DNS server or monitor IP. In that case, you will need to create an additional firewall rule in OPNsense to ensure that requests to those IPs/networks use the tunnel gateway rather than the normal WAN gateway. This rule would be similar to that created below, except that the destination would be the relevant IPs/networks (or a new Alias for them) and the destination invert box would be unchecked. This rule would also need to be placed above the rule created below

Warning

If the hosts that will use the tunnel are configured to use local DNS servers (such as OPNsense itself or another local DNS server), then the configuration below will likely result in DNS leaks - that is, DNS requests for the hosts will continue to be processed through the normal WAN gateway, rather than through the tunnel. See Dealing with DNS leaks for a discussion of potential solutions to this

    First go to Firewall ‣ Aliases

    Click + to add a new Alias

    Configure the Alias as follows (if an option is not mentioned below, leave it as the default):

        Enabled
        	

        Checked

        Name
        	

        RFC1918_Networks

        Type
        	

        Select Network(s) in the dropdown

        Content
        	

        192.168.0.0/16 10.0.0.0/8 172.16.0.0/12

        Description
        	

        All local (RFC1918) networks

    Save the Alias, and then click Apply

    Then go to Firewall ‣ Rules ‣ [Name of interface for network in which hosts/network resides, eg LAN for LAN hosts]

    Click Add to add a new rule

    Configure the rule as follows (if an option is not mentioned below, leave it as the default):

        Action
        	

        Pass

        Quick
        	

        Checked

        Interface
        	

        Whatever interface you are configuring the rule on

        Direction
        	

        in

        TCP/IP Version
        	

        IPv4

        Protocol
        	

        any

        Source / Invert
        	

        Unchecked

        Source
        	

        Select the relevant hosts Alias you created above in the dropdown (eg WG_VPN_Hosts )

        Destination / Invert
        	

        Checked

        Destination
        	

        Select the RFC1918_Networks Alias you created above in the dropdown

        Destination port range
        	

        any

        Description
        	

        Add one if you wish to

        Gateway
        	

        Select the gateway you created above (eg WAN_VPNProviderName )

    Save the rule, and then click Apply Changes

    Then make sure that the new rule is above any other rule on the interface that would otherwise interfere with its operation. For example, you want your new rule to be above the “Default allow LAN to any rule”

Step 9 - Configure routing

    Then go to Firewall ‣ Rules ‣ Floating

    Click Add to add a new rule

    Configure the rule as follows (if an option is not mentioned below, leave it as the default). You need to click the Show/Hide button next to “Advanced Options” to reveal the last setting:

        Action
        	

        Pass

        Quick
        	

        Unchecked

        Interface
        	

        Do not select any

        Direction
        	

        out

        TCP/IP Version
        	

        IPv4

        Protocol
        	

        any

        Source / Invert
        	

        Unchecked

        Source
        	

        Select the interface address for your WireGuard VPN (eg WAN_VPNProviderName address )

        Destination / Invert
        	

        Checked

        Destination
        	

        Select the interface network for your WireGuard VPN (eg WAN_VPNProviderName net )

        Destination port range
        	

        any

        Description
        	

        Add one if you wish to

        Gateway
        	

        Select the gateway you created above (eg WAN_VPNProviderName )

        allow options
        	

        Checked

    Save the rule, and then click Apply Changes

Step 10 - Create an outbound NAT rule

    Go to Firewall ‣ NAT ‣ Outbound

    Select “Hybrid outbound NAT rule generation” if it is not already selected, and click Save and then Apply changes

    Click Add to add a new rule

    Configure the rule as follows (if an option is not mentioned below, leave it as the default):

        Interface
        	

        Select the interface for your WireGuard VPN (eg WAN_VPNProviderName )

        TCP/IP Version
        	

        IPv4

        Protocol
        	

        any

        Source invert
        	

        Unchecked

        Source address
        	

        Select the Alias for the hosts/networks that are intended to use the tunnel (eg WG_VPN_Hosts )

        Source port
        	

        any

        Destination invert
        	

        Unchecked

        Destination address
        	

        any

        Destination port
        	

        any

        Translation / target
        	

        Interface address

        Description
        	

        Add one if you wish to

    Save the rule, and then click Apply changes

Step 11 - Add a kill switch (optional)

If the VPN tunnel gateway goes offline, then traffic intended for the VPN may go out the normal WAN gateway. There are a couple of ways to avoid this, one of which is outlined here:

    First, go back to the firewall rule you created under Step 7

    Click on the Show/Hide button next to “Advanced Options”

    Then, in the Set local tag field, add NO_WAN_EGRESS

    Save the rule, and then click Apply changes

    Then go to Firewall ‣ Rules ‣ Floating

    Click Add to add a new rule

    Configure the rule as follows (if an option is not mentioned below, leave it as the default). You need to click the Show/Hide button next to “Advanced Options” to reveal the last setting:

        Action
        	

        Block

        Quick
        	

        Checked

        Interface
        	

        WAN

        Direction
        	

        out

        TCP/IP Version
        	

        IPv4

        Protocol
        	

        any

        Source / Invert
        	

        Unchecked

        Source
        	

        any

        Destination / Invert
        	

        Unchecked

        Destination
        	

        any

        Destination port range
        	

        any

        Description
        	

        Add one if you wish to

        Match local tag
        	

        NO_WAN_EGRESS

    Save the rule, and then click Apply Changes

Configuring IPv6

Some VPN providers (such as Mullvad) allow you to send both IPv4 and IPv6 traffic down the tunnel. This will be evident if you receive both an IPv4 and IPv6 tunnel IP in the configuration data provided by the VPN provider. The IPv6 tunnel IP is likely to be a ULA, ie within fc00::/7.

To configure the tunnel to use IPv6, you essentially need to replicate the steps above for IPv4. That is, you need to:

    add the IPv6 tunnel IP to Tunnel Address on the WireGuard Instance configuration (see further below)

    add ::/0 to the Allowed IPs on the WireGuard Endpoint configuration

    create an IPv6 gateway (see further below)

    add to the hosts alias the IPv6 addresses of the hosts/networks that are to use the tunnel

    if necessary, create a separate local IPs alias for IPv6, so they can be excluded from the IPv6 firewall rule destination

    create an IPv6 firewall rule (specifying the IPv6 gateway in the rule)

    configure an IPv6 floating rule for routing (specifying the IPv6 gateway in the rule)

    create an IPv6 outbound NAT rule

    (optionally) add the kill switch tag to the IPv6 firewall rule and change the associated Floating rule to IPv4+IPv6

Note, however, that there are a couple of differences:

    First, the WireGuard Instance configuration will only accept one entry in the Gateway field. Just leave the IPv4 gateway address there.

    Second, there is no concept of a Far Gateway for IPv6. So to successfully set up a gateway for IPv6, you need to do two things:

        When adding the IPv6 address to Tunnel Address in the WireGuard Instance configuration, specify a /127 mask, rather than a /128

        Then, when creating an IPv6 Gateway for the tunnel, specify the IP address to be another IPv6 address that is within the /127 subnet of the Tunnel Address

Dealing with DNS leaks

As noted in Step 8, if your network is configured to use a local DNS server - for example, unbound on OPNsense or on another local host - this how-to is likely to result in DNS requests from the hosts using the tunnel to be routed through the normal WAN gateway, rather than through the tunnel. This will result in the WAN IP being exposed.

If you wish to avoid that, there are several possible solutions. Obviously what solution works best will depend on your network configuration and desired outcomes.

The solutions include:

    Force the local DNS server to use the tunnel as well. For a local DNS server that is not OPNsense, include the local IPs of that server in the Alias created in Step 7 for the relevant VPN hosts. For OPNsense itself, configure the DNS server to use the tunnel gateway. Implementing this solution will mean that all DNS traffic for your network will go through the tunnel, not just the DNS traffic for the hosts that are in the Alias (and, indeed, for a local DNS server that is not OPNsense, all traffic from that server, not just DNS traffic, will be forced through the tunnel). This may not be desirable for your circumstances

    If possible, intercept DNS traffic coming from the relevant hosts using the tunnel, and forward that traffic (by using a port forward rule in OPNsense) to a DNS server supplied by your VPN provider (see note below), or to a public DNS server. Note that this will break local DNS resolution. Note also that this will not always be possible to do - if the local DNS server that is configured generally for your network is not OPNsense itself and is on the same subnet as the hosts using the tunnel, then DNS requests will not be routed through OPNsense and so a port forward on OPNsense will not work

    Assuming you have configured DHCP static mappings in OPNsense for the hosts using the tunnel, specify in that configuration either the DNS servers supplied by your VPN provider (see note below), or public DNS servers. This will override the network-wide DNS settings for those hosts

    Configure public DNS servers for your whole local network, rather than local DNS servers

    Manually override the DNS settings on the relevant hosts themselves (assuming that is possible) so that the DNS servers provided by DHCP are ignored, and either the DNS servers supplied by your VPN provider (see note below), or public DNS servers, are used instead

Note

If the DNS servers supplied by your VPN provider are local IPs (ie, within the scope of the RFC1918_Networks Alias created in Step 8), then, as discussed in Step 8, you will need to create an additional firewall rule in OPNsense to ensure that requests to those servers use the tunnel gateway rather than the normal WAN gateway. This rule would be similar to that created in Step 8, except that the destination would be your VPN provider’s DNS server IPs and the destination invert box would be unchecked. This rule would also need to be placed above the rule created in Step 8


OpenConnect Setup
Introduction

OpenConnect is a SSL VPN client initially created to support Cisco’s AnyConnect SSL VPN. It has since been ported to support the Juniper SSL VPN which is now known as Pulse Connect Secure. Palo Altos Global Protect will also be supported in future and of course the own OpenConnect Server.
Step 1 - Installation

Go to System ‣ Firmware ‣ Plugins and search for os-openconnect. Install the plugin as usual, refresh and page and the you’ll find the client via VPN ‣ OpenConnect.
Step 2 - Setup

The setup of the client is very simple. Just tick Enable and fill out VPN Server, Username and Password. Be sure that the FQDN matches the name in the certificate or you will receive an error. Also wildcard certificates can produce errors.

Once enabled, a new interface will be available for specifying firewall rules; Firewall ‣ Rules ‣ OpenConnect will appear.
Step 3 - Troubleshoot problems

To troubleshoot connection problems it’s best to login via CLI and start OpenConnect manually:

# /usr/local/etc/rc.d/opnsense-openconnect start

Look out for errors like

To trust this server in future, perhaps add this to your command line: --servercert sha256:9f97a3395d18093a14f0d8e768dabee231af34d9ba35432dfe838d58dd633333

Now the field Certificate Hash comes into play, so please insert the string above without the hash size and set this one in field Certificate Hash Type.


Stunnel

Stunnel in OPNsense can be used to forward tcp connections securely using TLS mutual authentication. Although the application itself supports authentication based on pre-shared keys, our plugin only supports certificate based authentication, which is more secure but comes with more (connect) overhead (https://www.stunnel.org/perf.html).

The above diagram shows the basic functionality as provided by this plugin, the client part (not delivered by this plugin) connects to to the server at a predefined port and starts forwarding local received packets to the other end of the tunnel.

Securing http proxy traffic is one of the more common use-cases of stunnel.
Prerequisites

Before setting up our new secured tunnel, we need to make sure we have a Certificate Authority available together with certificates which can be used for both ends of the tunnel.

The simplest way to create a CA is to use an internal self signed one, which you can do in System -> Trust -> Authorities , choose “Create an internal Certificate Authority” as method and fill in all the details.

When you have a CA available, you can create a certificate for the server (this machine) and the client. Just go to System -> Trust -> Certificates and create an internal certificate, choose the right type (server for this end of the tunnel) and select the created CA from the previous step. The common name identifies both ends of the tunnel, you can choose a fully qualified domain name here for the server and a username for the client (for example).

Note

The example setup assumes a proxy server is already configured and functional.

Note

The plugin itself can be installed using the System ‣ Firmware ‣ Plugins menu (search for stunnel).
Configure the server

To add a new tunnel, go to VPN -> Stunnel -> Configuration and click the [+] to add a new record.

Listen address

    The address to listen on, we generally advice to use a loopback interface here and forward traffic to it using a port forward. Leave this default (127.0.0.1) for our example.

Note

When choosing a non loopback interface, make sure to use a static one.

Listen port

    The portnumber to listen on (where the stunnel client connects to). For our example we choose 31280 here.
Target hostname

    The hostname or ip number of the service to connect to, for this example the internal ip address of the proxy server.
Target port

    Port the service uses, in this case it would be 3128 (the default squid proxy port)
Certificate

    This servers certificate, select the one created for the server in the prerequisites.
CA to validate connections to

    Certificate authority to use, this stunnel will only accept connections which use a certificate issued by the same CA.
enable CRL

    Enable certificate revocation lists, when selected a CRL with the format XXXXXXXX.r0 is required in the (/var/run/stunnel/certs/) directory. If certificates are managed from this machine, all attached CRLs will be generated automatically. For more information about this option, see CRLpath in stunnels manual.

Warning

If configured and a valid CRL is not available, all connections will be denied. Additions may need a restart of stunnel (when the certificate was already used).

Description

    Enter a user friendly description here to identify this tunnel, something like “corporate proxy”

Tip

To forward traffic to the loopback address from your wan interface, go to Firewall -> NAT -> Port Forward and add a new rule with the following settings: Interface WAN, Protocol TCP, Destination WAN address, Destination port range 31280, Redirect target IP 127.0.0.1 and Redirect target port 31280

Note

For additional security you can enable chroot mode in VPN -> Stunnel -> General, there is however a downside in using this feature. If for some reason the system logging facility (syslog) is restarted, stunnel will loose connection to that facility, causing a lack of visibilty afterwards.
Configure the client

Before configuring the client, make sure to install stunnel for your platform, download the public key of your CA and the certificate created for this client.

[proxy]
client = yes
accept = 127.0.0.1:3128
connect = our.opnsense.address:31280
requireCert = yes
verifyChain = yes
cert = /path/to/client.pem
CAfile = /path/to/ca.pem

Note

client.pem contains both the public and private key part of this clients certificate.
Test

When the tunnel connection is established, you should be able to connect to 127.0.0.1:3128 on the connecting machine using your browsers proxy settings.
Enable Identd

Our stunnel plugin is packed with an additional service providing an ident (RFC 1413) protocol service. This service depends on a custom patch we ship in stunnel, making sure authenticated TLS sessions are logged properly, so our ident service can filter them to track a user that belongs to an stunnel session.

When a TLS session is authenticated, a log record like the one below will be send to syslog.

stunnel: LOG5[xxxxx]: IDENT Service [xx-xx-xx-xx-xx] from 127.0.0.2:11446 --> C=NL, ST=Zuid-Holland, L=Middelharnis, O=OPNsense, emailAddress=contact_at_domain, CN=test_client.opnsense.local

Our ident service interprets this as 127.0.0.2 connected using source port 11446 as test_client.opnsense.local (only the CN part is returned)

Note

Since our indent services binds to 0.0.0.0:113 it’s not compatible with other ident services likely using the same port, it also highly advisable to deny access to this services from other hosts than the consumers of this service (which is usually the firewall itself).

This functionality can easily be validated using two telnet sessions, one from the stunnel client keeping a session open, the other connecting to the same host using ident. The example log line above would result in the following request/response scenario:

# telnet 127.0.0.2 113
Trying 127.0.0.2...
Connected to OPNsense.localdomain.
Escape character is '^]'.
11446,3128
11446, 3128 : USERID : OTHER : test_client.opnsense.local
Connection closed by foreign host.

Note

Please note the 127.0.0.2 host is the same as the service connecting to was running on, using a different address attached to the same firewall would result in a NO-USER error.


Zerotier Configuration

Note

It is strongly recommended that the reader familiarise themselves with the Zerotier Manual, in order to further understand the concepts behind this plugin.
Prerequisites

Firstly, it is important that you have signed up to Zerotier at the Zerotier Portal. Second, you will need to create at least one network on the portal in order to obtain a Network Id that this plugin uses to join this node to the created Zerotier network. This network will become your private network that by default is visible only to your nodes - in other words, other nodes that are on that network can talk to each other, but nothing else can talk to them - they are completely transparent to the internet in general. In effect you are layering a private network over the public internet and all intra-node communication is encrypted and private between them. This is further hinted at by the fact that the assigned IP addresses are normally RFC1918 addresses, i.e., non-routable across the internet.

Finally, in order to have a fully functioning private VPN between Zerotier nodes, a combination of this plugin plus some configuration on the portal will be required.
Installation

From the Plugins view under System...Firmware, install the os-zerotier package. Once the new plugin has been installed, perform a page reload and a new menu item should appear under VPN called Zerotier.
../../_images/zerotier-0.png

Clicking on the Zerotier menu item will reveal two further sub-menu items - namely Settings and Overview. Clicking on “Settings” will present a new view with two named tabs. The first tab is called Settings and the second tab is called Networks. These are further described below.
../../_images/zerotier-1.png
Settings

This tab controls the overall operation of Zerotier. Anything changed here is applied globally to all defined networks and to the Zerotier service itself.

Enabled

    Controls if the service should be running. If it is disabled, then access to the Networks tab will be disabled. If it is enabled, access to the Networks tab will be enabled and the service will also start at boot time.
API Access Token (optional)

    This optional entry is for future use and further development of the Zerotier plugin. The API access token can be generated by logging into your portal and creating a new API Access Token. When the token has been generated, copy the value into this input box.
local.conf settings (optional)

    As described in the Zerotier Manual, a local.conf can be created to enable or disable custom node-specific configuration overrides. Further details of permitted options can be found on the ZeroTier Manual. Please note that the local.conf must be a valid JSON document otherwise the service will fail to start.

Networks

This table allows for the creation, modification and deletion of Zerotier networks. Adding a Network here will join your OPNsense installation to the specified Zerotier network.

Note

Remember, you will have to log into the Zerotier portal, select the network and authorise the node before it can be assigned an IP address (or indeed, talk to other nodes on that network).
../../_images/zerotier-2.png

Adding a network is quite straight-forward. Simply click on the + symbol key in the following:

Network Id

    This is the 64-bit (16 character hex) address that is generated on the portal when creating a Zerotier network.
Local Description (optional)

    You may key in a description here that will help you remember what the network is for. Please note that this field is not the same as the name/description of the Zerotier network - it’s simply an aide-mémoire to help you remember what the network is for.

Adding a network does not automatically cause your OPNsense installation to join that network. In order to join that network it must be Enabled first. Likewise, to remove your OPNsense node from the configured network simply deselect Enabled, thus disabling the network.

Once a network has been added and enabled the node must be authorised to join the network on the portal. Simply enabling the network on your OPNsense installation marks that node as a member of that network. It now has to request permission to talk to the other nodes on that network. To achieve this, you log into the portal, select the network, find the node address (this can found on the OPNsense Zerotier Overview menu item, under the Information tab) and authorise it by clicking on the “Auth?” check box beside the node. It should go from “red” to “green” to indicate that it has been authorised.

Some final “Network” operations:

If you wish to completely remove the network, simply select the network and click on the Bin icon.

If you wish to edit the network, click on the Pencil icon.

To “clone” the network entry, click on the Copy icon. Please ensure you change the Network Id, as having two networks with the same id is an invalid configuration.

For a very quick overview of the Zerotier network information, click on the Information icon. A more detailed view of the network can be found under the Overview...Networks menu item.
ZeroTier Overview

The following 3 tabs reveal Global, Network and Peer information. They can only be viewed if the Zerotier plugin is enabled, so please ensure that the service is enabled first. For information on the terminology used, please refer to the Zerotier Manual.
../../_images/zerotier-3.png
Information Overview

This tab shows “Global” information concerning the overall health of the Zerotier service.
Networks Overview

This tab shows each configured and enabled network that this OPNsense installation has joined. If no networks are enabled, no information is shown.
Peers Overview

This tab shows the peers (leaf, planets and moons - Zerotier terminology) known by this node.
Interface Assignment

Warning

It is highly recommended that the interface have auto-assignment of IP addresses turned off for this particular node only. You want to give the interface a statically assigned, stable IP address (from the Zerotier network IP range) and not have the Zerotier service auto-assign an IP address. Auto-assignment of IP addresses for nodes is controlled on the Zerotier Portal

After joining a Zerotier network (and authorising it on the portal) you may now wish to assign the Zerotier virtual interface on OPNsense in order to avail of OPNsense functionality such as firewalling and routing (using OSPF for example).
../../_images/zerotier-4.png

To achieve this:

Click on the Interfaces menu item, then click on Assignments. There you should discover a new interface currently unassigned that begins with the letters zt. Next, click on the + symbol to assign it. In this example it creates a new interface called OPT1. Clicking on OPT1 shows the Enable and Lock options. Check both options.

Warning

It is very important that Lock (i.e., Prevent interface removal) is enabled. This is because Zerotier is a software interface and not guaranteed to be brought “up” whilst the system is booting. It could happen shortly afterwards, hence locking the interface tells OPNsense not to remove it, thinking it’s gone bad.

Once the new interface has been enabled, it is recommended to change the Description away from OPT1 to something more descriptive for your needs.

For IPv4 Configuration Type, choose Static IPv4 then in the appropriate input boxes, key in the IPv4 address that you have assigned to this node via the Zerotier portal. Keep the IPv4 Upstream Gateway set to None.
../../_images/zerotier-5.png

You may choose to do the same for IPv6 Configuration Type.

Once the interface has been assigned with an IP, it show now also show up on Firewall Rules etc…plus any other operations that be done on a interfaces can also be applied to your assigned interface.


Services
_images/black-black-and-white-close-up-1496139.jpg

Your security appliance comes with quite some services to ease network operation, these can be found in the services menu.

    Captive portal & GuestNET
    DHCP
    Dnsmasq DNS
    Intrusion Prevention System
        IPS SSLBlacklists & Feodo Tracker
        IPS Block SSL certificates
        IPS Bypass local traffic from inspection
    Monit
    Network Time
    OpenDNS
    Unbound DNS
    Router Advertisements
    Log Files

Setup guides

    Setup a Guest Network


Captive portal & GuestNET

A Captive Portal allows you to force authentication, or redirection to a click through page for network access. This is commonly used on hotspot networks, but is also widely used in corporate networks for an additional layer of security on wireless or Internet access.
../_images/hotspot_login.png
Overview and terminology
Typical Applications

    Guest Network

    Hotel & Camping Wi-Fi Access

    Bring Your Own Device (BYOD)

Template Management

OPNsense’s unique template manager makes setting up your own login page an easy task. At the same time it offers additional functionalities, such as:

    URL redirection

    Option for your own Pop-up

    Custom Splash page

../_images/captiveportal_template_folder.png
Zone Management

Different zones can be setup on each interface or multiple interfaces can share one zone setup. Each Zone can use a different Captive Portal Template or share it with another zone.
Authentication

Secure authentication via HTTPS or splash-only portal with URL redirection to a given page Different sources can be used to authenticate a user in a zone:

    LDAP [Microsoft Active Directory]

    Radius

    Local user manager

    Vouchers / Tickets

    No authentication (Splash Screen Only)

    Multiple (a combination of above)

Voucher Manager

OPNsense’s Captive Portal has an easy voucher creation system that exports the vouchers to a csv file for use with your favorite application. The export allows you to print vouchers by merging them with your Microsoft Word or LibreOffice template and create a good looking handout with your logo and company style.
Timeouts & Welcome Back

Connection can be terminated after the user has been idle for a certain amount of time (idle timeout) and/or force a disconnect when a number of minutes have passed even if the user is still active (hard timeout). In case a user reconnects within the idle timeout and/or hard timeout no login is required and the user can resume its active session.
Bandwidth Management

The Built-in traffic shaper can be utilized to:

    Share bandwidth evenly

    Give priority to protocols port numbers and/or IP addresses

See also: Traffic Shaping
Portal bypass

MAC and IP addresses can be white listed to bypass the portal.
Platform Integration

Through the integrated REST API the captive portal application can be integrated with other services. See: Use the API
Administration

The Administration menu offers access to zone configuration and template management.

When creating a zone, a couple of options are available which we will try to explain briefly in the grid below:

Enabled
	

Enable the zone, which will install a network trap on the interfaces specified

Zone number
	

Read-only sequence of the configured zone

Interfaces
	

Interfaces which should be guarded by this captive portal

Allow inbound
	

Select interfaces from which to allow inbound (stateful) traffic. This can be convenient if the zone in question contains machines/servers which should be accessible from other networks attached to this firewall.

Authenticate using
	

Select an authenticator specified in System ‣ Access ‣ Servers

Always send accounting requests
	

[RADIUS only] This will make the captive portal always send accounting requests, rather than just when there is a need for accounting (e.g. when there is a daily session limit).

Enforce local group
	

Restrict access to users in the selected (local)group, to validate group membership, see System ‣ Access ‣ Groups

Idle timeout (minutes)
	

Clients will be disconnected after this amount of inactivity. They may log in again immediately, though.

Hard timeout (minutes)
	

Clients will be disconnected after this amount of time, regardless of activity. They may log in again immediately, though.

Concurrent user logins
	

If this option is set, users can login on multiple machines at once. If disabled subsequent logins will cause machines previously logged in with the same username to be disconnected.

SSL certificate
	

Certificate to use on the captive portal login system. Leave empty for HTTP only.

Hostname
	

Hostname (of this machine) to redirect login page to, leave blank to use this interface IP address, otherwise make sure the client can access DNS to resolve this location. When using a SSL certificate, make sure both this name and the cert name are equal.

Allowed addresses
	

Avoid authentication for addresses and subnets specified in this list

Allowed MAC addresses
	

Avoid authentication for MAC addresses specified in this list

Extended pre auth data
	

Offer extended data to the login template before authentication (mac addresses for upstream use).

Custom template
	

Template to use for the login page, specified in the templates tab.
In the templates tab you can manage your templates, the default template can be fetched using the button in the bottom right corner.

The file offered is a standard zip file, which can be unpacked locally and modified to your needs, the new contents can be saved into a new zip file and uploaded in a new template ()
Sessions

Basic Real Time Reporting is Integrated using the sessions menu, this shows the following information for each zone.

    Live top IP bandwidth usage (Traffic Graph)

    Active Sessions

    Time left on Vouchers

Vouchers

Here you can create new vouchers for all voucher servers configured in System ‣ Access ‣ Servers
Examples

To setup a hotspot controller for business or hotel usage see: Setup a Guest Network


DHCP

DHCP is used to automatically provide clients with an IP address (instead of clients having to set one themselves). DHCP is available for both IPv4 and IPv6 clients, referred to as DHCPv4 and DHCPv6, respectively.
Context and future

By default OPNsense implements the widely used ISC DHCP server, but as this product has reached its end of life we choose to add an alternative (KEA) as of version 24.1 as a first step in deprecating this piece of software.

Since the code in our system is rather old (originates from M0n0wall) and the data behind it is not structured in a way that would be easily migratable to something more modern, we choose to add KEA as a second option and will not try to build a drop-in replacement. Long term ISC will be removed from OPNsense, but no official date has been set yet.

If you want to tryout KEA in OPNsense, just disable the legacy dhcp server on the specific interface and go to the KEA DHCP menu available under Services ‣ Kea DHCP.
Reservations

Both ISC DHCP and KEA DHCP offer the possibility to reserve an IP address for a specific client. This is useful when a client needs to have the same IP address every time it connects to the network. Both services also offer the ability to define reservations inside and outside of the assigned pool of dynamic IP addresses. However, you should only define reservations outside of the pool. Unless you can guarantee that this client is online at all times when the reservation is in the dynamic range, the DHCP server is free to offer this IP address to a different client when the first client goes offline.
ISC DHCP
Settings overview

DHCPv4 settings can be found at Services ‣ ISC DHCPv4. DHCPv6 settings can be found at Services ‣ ISC DHCPv6.

The DHCPv4 submenu further consists of:

    An entry per interface of general settings, like a toggle to enable/disable DHCPv4 for this interface, DHCP range, DNS servers…

    Leases: Shows all IP addresses that are handed out to clients.

    Log File: Shows the log file of the DHCPv4 server.

The DHCPv6 submenu further consists of:

    Leases: Shows all IP addresses that are handed out to clients.

Using DHCPv4

A typical DHCPv4 usage scenario is using it on your LAN with an IP range of 192.168.1.x, where x can be a number from 1 through 254. This means a subnet mask of 255.255.255.0. The range can also be written as 192.168.1.0/24. (The “1” in the third group can also be another number, and there are also other ranges available for private use. These are described in RFC 1918.)

The LAN IP of the OPNsense device that serves DHCP to the LAN should fall in the same DHCP IP range. Typically, it gets the address ending in .1 (so 192.168.1.1 in this example).

To set the LAN IP, go to Interfaces ‣ [LAN], set “IPv4 Configuration Type” to “Static”, and under “Static IPv4 configuration”, set “IPv4 address” to 192.168.1.1 and the subnet dropdown to “24”. Then click Save.

To set the DHCP settings, go to Services ‣ ISC DHCPv4 ‣ [LAN]. Under “Gateway”, put 192.168.1.1. Under range, put 192.168.1.100 as the start address and 192.168.1.200 as the end address. Then click Save. After saving, click the “Apply Settings” button.
Using DHCPv6

When IPv6 addresses should be provisioned over DHCPv6 the Services‣ ISC DHCPv6 ‣[Interface] is the place to look at. Like in the IPv4 scenario, you can provide a range here, offer settings like default DNS servers and create static assignments based on the clients unique DHCP identifier (DUID).

Always make sure Router advertisements are properly configured before debugging DHCPv6 issues, these two daemons depend on eachother.

If a Prefix Delegation Range is specified, downstream routers may request prefixes (IA_PD). Routing a delegated prefix to a downstream router requires OPNsense to be aware of the router’s IPv6 WAN address. This can be achieved in two ways:

    Dynamic DHCPv6 address lease: If an address range is specified in the DHCPv6 service settings and the downstream router requests both an address (IA_NA) and prefix (IA_PD), the prefix will be routed to the leased address.

    Static mapping: If the DUID of an active prefix lease matches the DUID of a DHCPv6 static mapping, the delegated prefix will be unconditionally routed to the static mapping’s IPv6 address. The DHCPv6 service doesn’t have to be configured with an address range and the downstream router doesn’t have to request an address. The address in the static mapping may be a GUA, ULA or link-local address. This allows downstream prefix delegation to routers which only request a prefix, not an address.

Advanced settings

To configure options that are not available in the GUI one can add custom configuration files on the firewall itself. Files can be added in /usr/local/etc/dhcpd.opnsense.d/ for IPv4 and /usr/local/etc/dhcpd6.opnsense.d/ for IPv6, these should use as extension .conf (e.g. custom-options.conf). When more files are placed inside the directory, all will be included in alphabetical order.

Warning

It is the sole responsibility of the administrator which places a file in the extension directory to ensure that the configuration is valid.
Diagnostics

As mentioned in the settings overview, the current leased IP addresses can be seen in the Leases page for diagnostic purposes. Both IPv4 and IPv6 have their own leases page. This page reflects the current facts as reported by DHCPd in the /var/dhcpd/var/db/dhcpd(6).leases database. By default this page only shows the current active leases. To show all configured leases, check the “inactive” box. You are also able to filter on interfaces by using the dropdown showing “All Interfaces”.

    All times are reported in local time as specified in Administration

    Clients are considered online if they exist the ARP table for IPv4 or NDP table for IPv6.

    The different possible states a lease can be in is documented in the dhcpd.leases page. If failover is enabled, checking the inactive box will reveal all IP addresses currently reserved by DHCPd with a backup state. These are leases that are available for allocation by the failover secondary. The amount shown will vary depending on the configured failover split value or range.

    The lease type can either by dynamic or static. This is provided for ease of sorting.

    A static mapping for a dynamic lease can be configured by clicking on the plus sign of a row.

    A lease can also be directly deleted from the leases database.

    for DHCPv4, a hostname for a client will be shown if the client specifies their hostname as part of the protocol.

    For DHCPv6, a MAC address will be shown if it exists in the NDP table or if the MAC address exists in the DUID, but only if this MAC address maps to a known vendor. This is because a MAC address cannot reliably be fetched from a DUID.

    The DHCPv6 leases page also shows the delegated prefixes in a separate tab.

DHCRelay

DHCP relaying is the forwarding of DHCP requests received on one interface to the DHCP server of another. DHCP relaying is available for both DHCPv4 and DHCPv6. The settings can be found at Services ‣ DHCRelay.
Destinations

Setting
	

Explanation

Name
	

A descriptive name of the reusable relay destination

Server
	

A comma separated list of IPs to which the requests should be forwarded. Can be IPv4 or IPv6 exclusively.
Relays

Setting
	

Explanation

Enable
	

Check to enable this entry

Interface
	

Which interface to apply relaying to. Only interfaces with an Ethernet address can be selected. Only one interface per destination per address family is allowed.

Destination
	

The target destination of the relay from the pool of previously set up destinations.

Agent Information
	

If this is checked, the DHCP relay will append the circuit ID (interface number) and the agent ID to the DHCP request.
KEA DHCP

Kea is the next generation of DHCP software, developed by Internet Systems Consortium (ISC).
Control Agent

The Kea Control Agent (CA) is a daemon which exposes a RESTful control interface for managing Kea servers. When building a high available dhcp setup, the control agent is a requirement for these kind of setups.

Enabled
	

Enable control agent

Bind address
	

Address on which the RESTful interface should be available, usually this is localhost (127.0.0.1)

Bind port
	

Choose an unused port for communication here.

Note

Although the control agent is required to use high availability peers, it does not have to listen on a non loopback address. The peer configuration by default uses the so called “Multi-Threaded Configuration (HA+MT)”, in which case it starts a separate listener for the HA communication.
Kea DHCPv4

This is the DHCPv4 service available in KEA, which offers the following tab sheets with their corresponding settings:

    Settings

        Generic settings for this service

    Subnets

        Subnets and associated pools

    Reservations

        Machine static reservations

    HA Peers

        Define HA peers for this cluster. All nodes should contain the exact same definitions (usually two hosts, a primary and a standby host)

Settings
	

General\Enabled
	

Enable DHCPv4 service

General\Interfaces
	

Interfaces to listen on for dhcp[v4] requests

General\Valid lifetime
	

Defines how long the addresses (leases) given out by the server are valid (in seconds)

High Availability\Enabled
	

Enable high availability setup, requires an active control agent.

High Availability\This server name
	

This servername, when unspecified the hostname for this firewall is used.

Subnets
	

Subnet
	

Subnet in cidr presentation (e.g. 192.168.1.0/24)

Pools
	

List of pools (available addresses) for this service

Auto collect option data
	

When set, collect primary address to be used as gateway and dns for the connected clients.

Routers (gateway)
	

Default gateway to offer

DNS servers
	

Default DNS servers to offer to the client

NTP servers
	

Default NTP (time) servers to offer to the client

TFTP server
	

TFTP (etherboot) location to offer the client

TFTP bootfile name
	

TFTP boot filename to use

Reservations
	

Subnet
	

Select a subnet to which this reservation belongs

IP address
	

Address to offer the client

MAC address
	

Hardware address which identifies this client

Hostname
	

Hostname to offer the client

Description
	

User friendly description for this reservation

HA Peers
	

Role
	

Choose if the selected host is a primary or a standby machine

Url
	

This specifies the URL of our server instance, which should use a different port than the control agent. For example http://192.0.2.1:8001/

Tip

When using a CARP / HA setup, you usually should specify gateways and dns entries manually. Make sure to disable “Auto collect option data” in that case.

To configure a server with a minimal setup on LAN (like offered on a default OPNsense using ISC-DHCP) using the 192.168.1.0/24 network offering addresses in the range 192.168.1.100 - 192.168.1.199. Follow the following steps:

    Enable the service (General\Enabled)

    Choose LAN as listen interface (General\Interfaces)

    Add a new subnet containing the following settings

        Subnet : 192.168.1.0/24

        Pools : 192.168.1.100 - 192.168.1.199

        Auto collect option data: [x]

    Click on the Apply button.

Leases DHCPv4

This page offers an overview of the (non static) leases being offered by KEA DHCPv4.


Dnsmasq DNS

Dnsmasq is a lightweight, easy to configure, DNS forwarder, which can be used to answer to dns queries from your network.

Similar functionality is also provided by “Unbound DNS”, our standard enabled forward/resolver service.

In some cases people prefer to use dnsmasq or combine it with our default enabled resolver (Unbound).

Note

Since OPNsense 17.7 Unbound has been our standard DNS service, the main reason for Dnsmasq being shipped in our product is for compatibility. Although there are some use-cases that require Dnsmasq specifically, most users better opt for Unbound.
General settings

Most settings are pretty straightforward here when the service is enabled, it should just start forwarding dns requests when received from the network.

Enable
	

Enable our DNS Forwarder

Listen Port
	

The port used for responding to DNS queries, when empty the standard (53) will be used.

Network Interfaces
	

The interfaces to listen on, when using dynamic interfaces it’s not recommended to bind to addresses from these interfaces. [All] is the standard, in which case you can limit access using the firewall.

Bind Mode / strict binding
	

When network interfaces are provided, only bind to the interfaces containing the IP addresses selected above, rather than binding to all interfaces and discarding queries to other addresses. This option does not work with IPv6. If set, Dnsmasq will not bind to IPv6 addresses.

DNSSEC
	

Validate DNS replies and cache DNSSEC data.

Register ISC DHCP4 Leases
	

Register dhcp leases in Dnsmasq, so that their hostnames can be resolved. (IPv4 only)

DHCP Domain Override
	

When set use the domain name specified here instead of the system domain for registering addresses.

Register ISC DHCP Static Mappings
	

Register static dhcp addresses as well.

Query DNS servers sequentially
	

If this option is set, Dnsmasq will query the DNS servers sequentially in the order specified (System: General Setup: DNS Servers), rather than all at once in parallel.

Require domain
	

If this option is set, Dnsmasq will not forward A or AAAA queries for plain names, without dots or domain parts, to upstream name servers. If the name is not known from /etc/hosts or DHCP then a “not found” answer is returned.

Do not forward private reverse lookups
	

If this option is set, Dnsmasq will not forward reverse DNS lookups (PTR) for private addresses (RFC 1918) to upstream name servers. Any entries in the Domain Overrides section forwarding private “n.n.n.in-addr.arpa” names to a specific server are still forwarded. If the IP to name is not known from /etc/hosts, DHCP or a specific domain override then a “not found” answer is immediately returned.

Log Queries
	

Send the results of dns queries to the log.
Host overrides

Here you define static hostnames, which allow you to reply a specific address when being asked, per entry the following options are available.

Host
	

The hostname to register

Domain
	

The domain name to use

IP address
	

IP address of the host, can be an IPv4 (A record) or an IPv6 address (AAAA record)

Description
	

Descriptive text for this host

Aliases
	

Register alternative host + domain names for the same IP address
Domain Overrides

If a specific domain should be answered by a different DNS server, you can configure it here.

Domain
	

The domain name to use

IP address
	

IP address of the authoritative DNS server for this domain

Port
	

Port number of the target dns server, leave blank for default (53)

Source IP
	

Source IP address for queries to the DNS server for the override domain. Leave blank unless your DNS server is accessed through a VPN tunnel.

Description
	

Descriptive text for this entry
Advanced settings

To configure options that are not available in the gui one can add custom configuration files on the firewall itself. Files can be added in /usr/local/etc/dnsmasq.conf.d/, these should use as extension .conf (e.g. custom-options.conf). When more files are placed inside the directory, all will be included in alphabetical order.

Warning

It is the sole responsibility of the administrator which places a file in the extension directory to ensure that the configuration is valid.

Note

This method replaces the Custom options settings in the Dnsmasq configuration, which was removed in version 21.1.


Intrusion Prevention System

The Intrusion Prevention System (IPS) system of OPNsense is based on Suricata and utilizes Netmap to enhance performance and minimize CPU utilization. This deep packet inspection system is very powerful and can be used to detect and mitigate security threats at wire speed.
IDS and IPS

It is important to define the terms used in this document. An Intrustion Detection System (IDS) watches network traffic for suspicious patterns and can alert operators when a pattern matches a database of known behaviors. An Intrusion Prevention System (IPS) goes a step further by inspecting each packet as it traverses a network interface to determine if the packet is suspicious in some way. If it matches a known pattern the system can drop the packet in an attempt to mitigate a threat.

The Suricata software can operate as both an IDS and IPS system.
Choosing an interface

You can configure the system on different interfaces. One of the most commonly asked questions is which interface to choose. Considering the continued use IPv4, usually combined with Network Address Translation, it is quite important to use the correct interface. If you are capturing traffic on a WAN interface you will see only traffic after address translation. This means all the traffic is originating from your firewall and not from the actual machine behind it that is likely triggering the alert.

Rules for an IDS/IPS system usually need to have a clear understanding about the internal network; this information is lost when capturing packets behind NAT.

Without trying to explain all the details of an IDS rule (the people at Suricata are way better in doing that), a small example of one of the ET-Open rules usually helps understanding the importance of your home network.

alert tls $HOME_NET any -> $EXTERNAL_NET any (msg:"ET TROJAN Observed Glupteba CnC Domain in TLS SNI"; flow:established,to_server; tls_sni; content:"myinfoart.xyz"; depth:13; isdataat:!1,relative; metadata: former_category MALWARE; reference:md5,4cc43c345aa4d6e8fd2d0b6747c3d996; classtype:trojan-activity; sid:2029751; rev:2; metadata:affected_product Windows_XP_Vista_7_8_10_Server_32_64_Bit, attack_target Client_Endpoint, deployment Perimeter, signature_severity Major, created_at 2020_03_30, updated_at 2020_03_30;)

The $HOME_NET can be configured, but usually it is a static net defined in RFC 1918. Using advanced mode you can choose an external address, but bear in mind you will not know which machine was really involved in the attack and it should really be a static address or network.

$EXTERNAL_NET is defined as being not the home net, which explains why you should not select all traffic as home since likely none of the rules will match.

Since the firewall is dropping inbound packets by default it usually does not improve security to use the WAN interface when in IPS mode because it would drop the packet that would have also been dropped by the firewall.

Note

IDS mode is available on almost all (virtual) network types. When your network card is not (fully) supported, you can set the tunable dev.netmap.admode to the value 2 in which case emulated mode will be enforced (Configurable in System ‣ Settings ‣ Tunables). A list of natively supported physical adapters is available in the FreeBSD man page.
General setup

The settings page contains the standard options to get your IDS/IPS system up and running.

Enabled
	

Enable Suricata

IPS mode
	

When enabled, the system can drop suspicious packets. In order for this to work, your network card needs to support netmap. The action for a rule needs to be “drop” in order to discard the packet, this can be configured per rule or ruleset (using an input filter)

Promiscuous mode
	

Listen to traffic in promiscuous mode. (all packets in stead of only the ones addressed to this network interface)

Enable syslog alerts
	

Send alerts to syslog, using fast log format

Enable eve syslog output
	

Send alerts in EVE format to syslog, using log level info. This will not change the alert logging used by the product itself. Drop logs will only be send to the internal logger, due to restrictions in suricata.

Pattern matcher
	

Controls the pattern matcher algorithm. Aho–Corasick is the default. On supported platforms, Hyperscan is the best option. On commodity hardware if Hyperscan is not available the suggested setting is “Aho–Corasick Ken Steele variant” as it performs better than “Aho–Corasick”.

Interfaces
	

Interfaces to protect. When in IPS mode, this need to be real interfaces supporting netmap. (when using VLAN’s, enable IPS on the parent)

Rotate log
	

Log rotating frequency, also used for the internal event logging (see Alert tab)

Save logs
	

Number of logs to keep

Tip

When using an external reporting tool, you can use syslog to ship your EVE log easily. Just enable “Enable EVE syslog output” and create a target in System ‣ Settings ‣ Logging / Targets. (filter application “suricata” and level “info”)

Note

When using IPS mode make sure all hardware offloading features are disabled in the interface settings (Interfaces ‣ Settings). Prior to version 20.7, “VLAN Hardware Filtering” was not disabled which may cause issues for some network cards.
Advanced options

Some less frequently used options are hidden under the “advanced” toggle.

Home networks
	

Define custom home networks, when different than an RFC1918 network. In some cases, people tend to enable IDPS on a wan interface behind NAT (Network Address Translation), in which case Suricata would only see translated addresses in stead of internal ones. Using this option, you can define which addresses Suricata should consider local.

default packet size
	

With this option, you can set the size of the packets on your network. It is possible that bigger packets have to be processed sometimes. The engine can still process these bigger packets, but processing it will lower the performance.
Download rulesets

When enabling IDS/IPS for the first time the system is active without any rules to detect or block malicious traffic. The download tab contains all rulesets available on the system (which can be expanded using plugins).

In this section you will find a list of rulesets provided by different parties and when (if installed) they where last downloaded on the system. In previous versions (prior to 21.1) you could select a “filter” here to alter the default behavior of installed rules from alert to block. As of 21.1 this functionality will be covered by Policies, a separate function within the IDS/IPS module, which offers more fine grained control over the rulesets.

Note

When migrating from a version before 21.1 the filters from the download rulesets page will automatically be migrated to policies.
Policies

The policy menu item contains a grid where you can define policies to apply to installed rules. Here you can add, update or remove policies as well as disabling them. Policies help control which rules you want to use in which manner and are the prefered method to change behaviour. Although you can still update separate rules in the rules tab, adding a lot of custom overwrites there is more sensitive to change and has the risk of slowing down the user-interface.

A policy entry contains 3 different sections. First some general information, such as the description and if the rule is enabled as well as a priority. Overlapping policies are taken care of in sequence, the first match with the lowest priority number is the one to use.

Secondly there are the matching criterias, these contain the rulesets a policy applies on as well as the action configured on a rule (disabled by default, alert or drop), finally there is the rules section containing the metadata collected from the installed rules, these contain options as affected product (Android, Adobe flash, …) and deployment (datacenter, perimeter).

The last option to select is the new action to use, either disable selected rules, only alert on them or drop traffic when matched.

Note

The options in the rules section depend on the vendor, when no metadata is provided in the source rule, none can be used at our end.
Installed rules

The rules tab offers an easy to use grid to find the installed rules and their purpose, using the selector on top one can filter rules using the same metadata properties available in the policies view.

Tip

After applying rule changes, the rule action and status (enabled/disabled) are set, to easily find the policy which was used on the rule, check the matched_policy option in the filter. Manual (single rule) changes are being marked as policy “__manual__”
User defined rules

Most of the rules being used on your IDPS system will be supplied by third party vendors like Proofpoint, but in some cases it can be convenient to build some (limited) rules yourself. The “User defined” tab offers this functionality.
Fingerprinting

OPNsense includes a very polished solution to block protected sites based on their SSL fingerprint. You can manually add rules in the “User defined” tab.
Bypassing the engine

The Bypass toggle offers the ability to skip traffic inspection, our How-tos section contains a good example to exclude local traffic passing your network and increase routing performance.
Alerts

In the “Alerts” tab you can view the alerts triggered by the IDS/IPS system. Use the info button here to collect details about the detected event or threat.
Advanced configuration

OPNsense supports custom Suricata configurations in suricata.yaml format. In order to add custom options, create a template file named custom.yaml in the /usr/local/opnsense/service/templates/OPNsense/IDS/ directory.

Since this file is parsed by our template system, you are able to use template tags using the Jinja2 language.
Available rulesets
Emerging Threats

Emerging Threats (ET) has a variety of IDS/IPS rulesets. There is a free, BSD-licensed version and a paid version available.

Tip

Proofpoint offers a community portal which provides access to documentation and updates about rules, you can visit it at https://community.emergingthreats.net/ . The Frequently asked questions might be a good place to start reading.
ET Open

The ETOpen Ruleset is not a full coverage ruleset and may not be sufficient for many regulated environments and thus should not be used as a standalone ruleset.

OPNsense has integrated support for ETOpen rules.
ETPro Telemetry

Proofpoint offers a free alternative for the well known ET Pro Telemetry edition ruleset.
ETPro (commercial)

When in possession of a Proofpoint ET Pro oink code, you can install the os-intrusion-detection-content-et-pro plugin via System ‣ Firmware ‣ Plugins.

As soon as the plugin is installed, you will find an option etpro.oinkcode under settings in Services ‣ Intrusion Detection ‣ Administration / Download where you can enter this code.
Abuse.ch

Abuse.ch offers several blacklists for protecting against fraudulent networks.
SSL Blacklist

SSL Blacklist (SSLBL) is a project maintained by abuse.ch. The goal is to provide a list of “bad” SSL certificates identified by abuse.ch to be associated with malware or botnet activities. SSLBL relies on SHA1 fingerprints of malicious SSL certificates and offers various blacklists.

See for details: https://sslbl.abuse.ch/
Feodo Tracker

Feodo (also known as Cridex or Bugat) is a Trojan used to commit ebanking fraud and steal sensitive information from the victim’s computer, such as credit card details or credentials. At the moment, Feodo Tracker is tracking four versions of Feodo, and they are labeled by Feodo Tracker as version A, version B, version C and version D:

    Version A Hosted on compromised webservers running an nginx proxy on port 8080 TCP forwarding all botnet traffic to a tier 2 proxy node. Botnet traffic usually directly hits these hosts on port 8080 TCP without using a domain name.

    Version B Hosted on servers rented and operated by cybercriminals for the exclusive purpose of hosting a Feodo botnet controller. Usually taking advantage of a domain name within ccTLD .ru. Botnet traffic usually hits these domain names using port 80 TCP.

    Version C Successor of Feodo, completely different code. Hosted on the same botnet infrastructure as Version A (compromised webservers, nginx on port 8080 TCP or port 7779 TCP, no domain names) but using a different URL structure. This Version is also known as Geodo and Emotet.

    Version D Successor of Cridex. This version is also known as Dridex

See for details: https://feodotracker.abuse.ch/
URLHaus List

OPNsense version 18.1.7 introduced the URLHaus List from abuse.ch which collects compromised sites distributing malware.

See for details: https://urlhaus.abuse.ch/
App detection rules

OPNsense 18.1.11 introduced the app detection ruleset. Since about 80 percent of traffic are web applications these rules are focused on blocking web services and the URLs behind them.

If you want to contribute to the ruleset see: https://github.com/opnsense/rules
How-tos

    IPS SSLBlacklists & Feodo Tracker
    IPS Block SSL certificates
    IPS Bypass local traffic from inspection


IPS SSLBlacklists & Feodo Tracker

This tutorial explains how to setup the IPS system to drop SSL certificates listed on the abuse.ch SSL Blacklists & Feodo Tracker.

Feodo (also known as Cridex or Bugat) is a Trojan used to commit e-banking fraud and steal sensitive information from the victim’s computer, such as credit card details or credentials. For more information see https://feodotracker.abuse.ch
Prerequisites

    Always upgrade to latest release first. See Initial Installation & Configuration and/or upgrade to latest release: System ‣ Firmware ‣ Fetch updates

../../_images/firmware.png

    Minimum Advisable Memory is 2 Gigabyte and sufficient free disk space for logging (>10 GB advisable).

    Disable all Hardware Offloading Under Interface-Settings

../../_images/disable_offloading.png

Warning

After applying you need to reboot OPNsense otherwise offloading may not completely be disabled and IPS mode will not function.

Note

Some features described on this page were added in version 16.1.1. Always keep your system up to date.
Setup Intrusion Detection & Prevention

To enable IDS/IPS just go to Services ‣ Intrusion Detection and select enabled & IPS mode. Make sure you have selected the right interface for the intrusion detection system too run on. For our example we will use the WAN interface, as that will most likely be you connection with the public Internet.
../../_images/idps.png
Apply configuration

First apply the configuration by pressing the Apply button at the bottom of the form.
../../_images/applybtn.png
Fetch Rule sets

For this example we will only fetch the abuse.ch SSL & Dodo Tracker rulesets. To do so: select Enabled after each one.
../../_images/rulesets_enable.png

To download the rule sets press Download & Update Rules.
../../_images/downloadbtn.png
Change default behavior

To block matches instead of alerting on them, go to the Service -> Intrusion Detection -> Policies page and add a new policy. You can easily select the associated rulesets here (all staring with abuse.ch) and select action “Alert” next go to the new action, which should be “Drop”.

Apply the settings at the bottom of the page when done.
Apply fraud drop actions

Now press Download & Update Rules again to change the behavior to drop.
../../_images/downloadbtn.png
Keep up to date

Now schedule a regular fetch to keep your server up to date.

Click on schedule, a popup window will appear:
../../_images/schedule.png

Select enabled and choose a time. For the example it is set to each day at 11:12. Select Save changes and wait until you have returned to the IDS screen.
DONE

Your system has now been fully setup to drop known fraudulent SSL certificates as well data phishing attempts by utilizing the Feodo tracking list.
Sample alert

Currently there is no test service available to check your block rules against, however here is a sample of an actual alert that has been blocked:
../../_images/alerts.jpg


IPS Block SSL certificates

This tutorial explains how to setup the IPS system to block ssl certificates based on their SHA1 fingerprint.
Prerequisites

    Always upgrade to latest release first. See Initial Installation & Configuration and/or upgrade to latest release: System ‣ Firmware ‣ Fetch updates.

../../_images/firmware.png

    Minimum Advisable Memory is 2 Gigabyte and sufficient free disk space for logging (>10 GB advisable).

    Disable all Hardware Offloading Under Interface-Settings

../../_images/disable_offloading.png

Warning

After applying you need to reboot OPNsense otherwise offloading may not completely be disabled and IPS mode will not function.

To start go to Services ‣ Intrusion Detection

ids_menu
User defined

Select the tab User defined.

ids_tabs_user
Create a new Rule

Select add to add a new rule.
Get fingerprint of website

It is relatively easy to find out the SSL fingerprint of a website. For demonstration we will block facebook and use Firefox to determine the fingerprint.

Open your browser and go to https://facebook.com when loaded click on the lock next to the address : lock.

Now you will see something similar to:
../../_images/facebook_click.png

Click on the arrow ( > ) and then Select More Information Now open the certificate details and you will see something that looks like this:
../../_images/certificate.png

Copy the SHA1 certificate fingerprint (A0:4E:AF:B3:48:C2:6B:15:A8:C1:AA:87:A3:33:CA:A3:CD:EE:C9:C9).

Paste this into the new rule:
../../_images/ips_rule_details.png

Select the Action (Alert or Drop):
../../_images/ips_action.png

Add a description:
../../_images/ips_description.png

And click Save changes save
Enable Intrusion Detection & Prevention

To enable IDS/IPS just go to Services ‣ Intrusion Detection and select enabled & IPS mode. Make sure you have selected the right interface for the intrusion detection system too run on. For our example we will use the WAN interface, as that will most likely be you connection with the public Internet.
../../_images/idps.png
Apply configuration

First apply the configuration by pressing the Apply button at the bottom of the form.
../../_images/applybtn.png
Clear Browser Cache and test

Since your browser has cached the ssl certificate you will need to clear your cache first. After that you can test and will see the following in Alerts:
../../_images/ips_facebook_alert.png

Note

If the browser has cached the certificate no SSL certificate exchange will be done and the website will not be blocked.


IPS Bypass local traffic from inspection

Note

This tutorial explains how to bypass traffic between local attached networks. Following this tutorial will result in traffic only being inspected between external (WAN) networks and internal (LAN) networks. With bypass enabled, routing performance is improved significantly between local networks while IPS is used.

Tip

If you only have 1 interface selected in Intrusion Detection, you don’t have to follow this tutorial. There won’t be any performance benefit.

Warning

Traffic between local networks won’t be inspected anymore, so use this with care!
Prerequisites

    Some features described on this page were added in the latest version. Always keep your system up to date.

    Intrusion Detection should be enabled and IPS mode selected.

    Only internal networks should be selected in Interfaces (LAN, OPT1 etc..), not the WAN interface.

Create new Rules

To start go to Services ‣ Intrusion Detection ‣ Administration and select the tab User defined.

Select + to add a new rule.

    Input the Source IP with CIDR-Suffix, e.g. 10.0.0.0/8

    Input the Destination IP with CIDR-Suffix, e.g. 10.0.0.0/8

    Select the Action as Pass

    Enable the Bypass checkbox

    Set the Description as “Bypass net 10.0.0.0 to 10.0.0.0”

Select + or clone to create additional new rules.

    Repeat the above steps to create rules between each of the RFC1918 Private IPv4 subnets, 192.168.0.0/16, 172.16.0.0/12, 10.0.0.0/8. Don’t forget to adjust the description.

Note

The finished ruleset for IPv4 should include the following rules:

Source IP
	

Destination IP
	

Action
	

Bypass
	

Description

10.0.0.0/8
	

10.0.0.0/8
	

Pass
	

X
	

Bypass net 10.0.0.0 to 10.0.0.0

10.0.0.0/8
	

172.16.0.0/12
	

Pass
	

X
	

Bypass net 10.0.0.0 to 172.16.0.0

10.0.0.0/8
	

192.168.0.0/16
	

Pass
	

X
	

Bypass net 10.0.0.0 to 192.168.0.0

172.16.0.0/12
	

10.0.0.0/8
	

Pass
	

X
	

Bypass net 172.16.0.0 to 10.0.0.0

172.16.0.0/12
	

172.16.0.0/12
	

Pass
	

X
	

Bypass net 172.16.0.0 to 172.16.0.0

172.16.0.0/12
	

192.168.0.0/16
	

Pass
	

X
	

Bypass net 172.16.0.0 to 192.168.0.0

192.168.0.0/16
	

10.0.0.0/8
	

Pass
	

X
	

Bypass net 192.168.0.0 to 10.0.0.0

192.168.0.0/16
	

172.16.0.0/12
	

Pass
	

X
	

Bypass net 192.168.0.0 to 172.16.0.0

192.168.0.0/16
	

192.168.0.0/16
	

Pass
	

X
	

Bypass net 192.168.0.0 to 192.168.0.0

Tip

    If you use IPv6 - e.g. with Track Interface or Static IPv6 - create an additional rule.

    You can find your IPv6 prefix in Interfaces ‣ Overview ‣ WAN - e.g 2001:db8:a:aa00::/56.

    You only have to create 1 rule, because all of the Track IPv6 Interface - IPv6 Prefix ID networks - e.g. 2001:db8:a:aa01::/64, 2001:db8:a:aa02::/64 - are already included in the /56 Prefix.

    Please note that this only works if your Prefix is static.

Apply configuration

Apply the configuration by pressing the Apply button at the bottom of the form.
External Resources

    https://docs.suricata.io/en/suricata-6.0.0/rules/bypass-keyword.html

    https://docs.suricata.io/en/suricata-6.0.0/performance/ignoring-traffic.html



Monit

OPNsense uses Monit for monitoring services. Monit has quite extensive monitoring capabilities, which is why the configuration options are extensive as well. This guide will do a quick walk through the setup, with the configuration options explained in more detail afterwards, along with some caveats.
Global setup

Navigate to Services ‣ Monit ‣ Settings. On the “General Settings” tab, turn on Monit and fill in the details of your SMTP server. Save the changes. Then, navigate to the “Alert settings” and add one for your e-mail address. If your mail server requires the “From” field to be properly set, enter From: sender@example.com in the “Mail format” field. Save the alert and apply the changes.
Adding an alert

First, you have to decide what you want to monitor and what constitutes a failure. It helps if you have some knowledge about how Monit alerts are set up. This is described in the Monit documentation.

If you have done that, you have to add the condition first. Navigate to the ‘Service Test Settings’ tab and look if the condition you want to add already exists. If it doesn’t, click the + button to add it.

Now navigate to the ‘Service Test’ tab and click the + icon. In the dialog, you can now add your service test. If you’re done, save it, then apply the changes.

The fields in the dialogs are described in more detail in the “Settings overview” section of this document.
Example 1

In this example, we’ll add a service to restart the FTP proxy (running on port 8021) if it has stopped. To avoid an eternal loop in case something is wrong, we’ll also add a provision to stop trying if the FTP proxy has had to be restarted five times in a row.

First, make sure you have followed the steps under “Global setup”. Then, navigate to the “Service Tests Settings” tab. Here, you need to add two tests:

Setting
	

Value

Name
	

FTPProxy8021

Condition
	

failed host 127.0.0.1 port 8021 type tcp

Action
	

Restart

Setting
	

Value

Name
	

RestartLimit5

Condition
	

5 restarts within 5 cycles

Action
	

Unmonitor

Now, navigate to the “Service Settings” tab. Here, add the following service:

Setting
	

Value

Name
	

FTPProxy8021

Type
	

Process

PID File
	

/var/run/osftpproxy.127_0_0_1_8021.pid

Start
	

/usr/local/sbin/configctl ftpproxy start 127_0_0_1_8021

Stop
	

/usr/local/sbin/configctl ftpproxy stop 127_0_0_1_8021

Tests
	

FTPProxy8021, RestartLimit5

Save and apply.
Example 2

In this example, we want to monitor a VPN tunnel and ping a remote system. If the ping does not respond anymore, IPsec should be restarted.

First, make sure you have followed the steps under “Global setup”. Then, navigate to the “Service Tests Settings” tab. Here, you need to add one test:

Setting
	

Value

Name
	

IPSEC_RESTART

Condition
	

failed ping4 count 5 address <local IP>

Action
	

Restart

Now, navigate to the “Service Settings” tab. Here, add the following service:

Setting
	

Value

Name
	

IPSEC_MONITOR

Type
	

Remote Host

Address
	

<remote IP>

Start
	

/usr/local/sbin/configctl ipsec start

Stop
	

/usr/local/sbin/configctl ipsec stop

Tests
	

IPSEC_RESTART

Save and apply.
Example 3

In this example, we want to monitor Suricata EVE Log for alerts and send an e-mail. This is really simple, be sure to keep false positives low to no get spammed by alerts.

First, make sure you have followed the steps under “Global setup”. Then, navigate to the “Service Tests Settings” tab. Here, you need to add one test:

Setting
	

Value

Name
	

SURICATA_EVE

Condition
	

content = “blocked”

Action
	

Alert

Now, navigate to the “Service Settings” tab. Here, add the following service:

Setting
	

Value

Name
	

SURICATA_ALERT

Type
	

File

Path
	

/var/log/suricata/eve.json

Tests
	

SURICATA_EVE

Save and apply. From now on you will receive with the alert message for every block action.
Settings overview

Navigate to Services ‣ Monit ‣ Settings. You will see four tabs, which we will describe in more detail below
General Settings

Click ‘advanced mode’ to see all the settings.

Setting
	

Description

Enable Monit
	

Turns Monit on or off.

Polling interval
	

How often Monit checks the status of the components it monitors.

Start delay
	

How long Monit waits before checking components when it starts.

Mail Server
	

A list of mail servers to send notifications to (also see below this table).

Mail Server Port
	

The mail server port to use. 25 and 465 are common examples.

Username
	

The username used to log into your SMTP server, if needed. Often, but not always, the same as your e-mail address.

Password
	

The password used to log into your SMTP server, if needed.

Secure Connection
	

Use TLS when connecting to the mail server.

SSL Version
	

The TLS version to use. AUTO will try to negotiate a working version.

Verify SSL Certificates
	

Checks the TLS certificate for validity. If you use a self-signed certificate, turn this option off.

Log File
	

The log file of the Monit process. This can be the keyword syslog or a path to a file.

State File
	

The state file of the Monit process.

Eventqueue Path
	

The path to the eventqueue directory.

Eventqueue Slots
	

The number of eventqueue slots.

Enable HTTPD
	

Turns on the Monit web interface. (Required to see options below.)

Monit HTTPD Port
	

The listen port of the Monit web interface service.

Monit HTTPD Access List
	

The username:password or host/network etc. for accessing the Monit web interface service.

M/Monit URL
	

The M/Monit URL, e.g. https://user:pass@192.168.1.10:8443/collector

M/Monit Timeout
	

When doing requests to M/Monit, time out after this amount of seconds.

M/Monit Register Credentials
	

Automatically register in M/Monit by sending Monit credentials (see Monit Access List above).

In the “Mail Server” settings, you can specify multiple servers. Monit will try the mail servers in order, starting with the first, advancing to the second if the first server does not work, etc. If no server works Monit will not attempt to send the e-mail again.

Two things to keep in mind: the authentication settings are shared between all the servers, and the ‘From:’ address is set in the “Alert Settings”.

Authentication options for the Monit web interface are described in https://mmonit.com/monit/documentation/monit.html#Authentication.

M/Monit is a commercial service to collect data from several Monit instances. To use it from OPNsense, fill in the appropriate fields and add corresponding firewall rules as well.
Alert Settings

This lists the e-mail addresses to report to. Click the Edit icon of a pre-existing entry or the Add icon (a plus sign in the lower right corner) to see the options listed below.

Setting
	

Description

Enable alert
	

Turns this alert on or off.

Recipient
	

The e-mail address to send this e-mail to.

Not on
	

When off, notifications will be sent for events specified below. When on, notifications will be sent for events not specified below.

Events
	

Events that trigger this notification (or that don’t, if “Not on” is selected).

Mail format
	

Can be used to control the mail formatting and from address. See below this table.

Reminder
	

Send a reminder if the problem still persists after this amount of checks.

Description
	

A description for this rule, in order to easily find it in the Alert Settings list.

“Mail format” is a newline-separated list of properties to control the mail formatting. It is also needed to correctly set the From address. For example:

From: sender@example.com
Reply-To: support@example.com
Subject: $SERVICE at $HOST failed

Service Settings

This lists the services that are set. There are some services precreated, but you add as many as you like. Click the Edit icon of a pre-existing entry or the Add icon (a plus sign in the lower right corner) to see the options listed below.

Setting
	

Description

Enable service checks
	

Turns this service on or off.

Name
	

A name for this service, consisting of only letters, digits and underscore. More descriptive names can be set in the Description field.

Type
	

The kind of object to check. ‘Custom’ allows you to use custom scripts.

Path
	

The path to the directory, file, or script, where applicable.

Program Timeout
	

How often to run this check.

Start
	

The start script of the service, if applicable.

Stop
	

The stop script of the service, if applicable.

Tests
	

The condition to test on to determine if an alert needs to get sent. These conditions are created on the Service Test Settings tab.

Description
	

A description for this service, in order to easily find it in the Service Settings list.
Service Test Settings

Setting
	

Description

Name
	

The name of the test.

Condition
	

A condition that adheres to the Monit syntax, see the Monit documentation

Action
	

What to do when the condition gets hit.

There are some precreated service tests. Most of these are typically used for one scenario, like the ‘Memory usage > 75%’ test. Some, however, are more generic and can be used to test output of your own scripts. These include:

Service Test
	

Description

NonZeroStatus
	

The returned status code is not 0. (Scripts typically exit with 0 if there were no problems, and with non-zero if there were.)

ChangedStatus
	

The returned status code has changed since the last it the script was run.
Status

The Monit status panel can be accessed via Services ‣ Monit ‣ Status. For every active service, it will show the status, along with extra information if the service provides it.
Advanced Configurations

Some installations require configuration settings that are not accessible in the UI. To support these, individual configuration files with a .conf extension can be put into the /usr/local/etc/monit.opnsense.d directory. These files will be automatically included by the UI generated configuration. Multiple configuration files can be placed there. But note that

    The wildcard include processing in Monit is based on glob(7). So the order in which the files are included is in ascending ASCII order.

    Monit supports up to 1024 include files. If this limit is exceeded, Monit will report an error.

    It makes sense to check if the configuration file is valid. You can do so by using the following command:

    # Run syntax check for the control file
    configctl monit check

This is a sample configuration file to customize the limits of the Monit daemon:

## Set limits for various tests. The following example shows the default values:
##
set limits {
     programOutput:     5120 B,      # check program's output truncate limit
#     sendExpectBuffer:  256 B,      # limit for send/expect protocol test
     fileContentBuffer: 5120 B,      # limit for file content test
#     httpContentBuffer: 1 MB,       # limit for HTTP content test
#     networkTimeout:    5 seconds   # timeout for network I/O
#     programTimeout:    300 seconds # timeout for check program
#     stopTimeout:       30 seconds  # timeout for service stop
#     startTimeout:      120 seconds  # timeout for service start
#     restartTimeout:    30 seconds  # timeout for service restart
}

Warning

It is the sole responsibility of the administrator which places a file in the extension directory to ensure that the configuration is valid.


Network Time

OPNsense ships with a standard NTPd server, which synchronizes time with upstream servers and provides time to connected clients.

A newly installed firewall comes with NTP enabled on all interfaces (firewall blocks all non LAN access in this case), forwarding queries to one of the X.opnsense.pool.ntp.org upstreams (X is any of 0,1,2,3).
General settings

In most cases the default setup is ready to use, below you will find some of the general options which can be configured.

Attention

NTPd syncs the local clock to remote NTP servers and listens for incoming client queries using the selected interfaces. The interface selection must therefore include a WAN type interface so that normal routing to the internet can take place. Only selecting a LAN type interface will likely work due to outbound NAT rules, however, if CARP is configured, it is possible that such NAT rules will translate to the address of the CARP VIP, causing asymmetric routing for secondary nodes.

Unless you are sure that you want to use a specific interface, it is recommended to keep the default of listening on all interfaces and use the firewall rules to constrain access to the NTP service. See Listen interfaces for more information.

Interface(s)
	

Interfaces to listen on. This interface selection is also used for outgoing queries. when no interfaces are selected it listens on all interfaces with a wildcard. Selecting all interfaces will explicitly listen on only the interfaces/IPs specified. Interfaces without an IP address will not be shown.

Time servers
	

Servers to use, comes with two toggles:

    Prefer

        Marks the server as preferred.

    Do not use

        Marks the server as unused, except for display purposes. The server is discarded by the selection algorithm.

Orphan mode
	

Orphan mode allows the system clock to be used when no other clocks are available. The number here specifies the stratum reported during orphan mode and should normally be set to a number high enough to insure that any other servers available to clients are preferred over this server.

NTP graphs
	

Enable RRD graphs of NTP statistics, which can be viewed in Reporting ‣ Health

Syslog logging
	

Extend logging with peer and/or system messages

Statistics logging
	

Enable statistical logging in /var/log/ntp, doesn’t come with a user interface

Access restrictions
	

Within the access restriction row, you can set various options which limit the use of ntpd and in some cases instruct ntpd how to handle rejected clients.

Leap seconds
	

You can manually supply ntpd with a leap seconds file, more detailed info on the contents of those files can be found here

Note

NTPs is disabled if no Time servers are configured. There is no separate enable/disable toggle.
GPS

If you own a gps receiver, which supports NMEA, you can use it as a reference clock and configure it in this section. For some brands settings are preconfigured, you can also use custom settings.
PPS

If your GPS receiver supports PPS (Pulse Per Second) output or you have a separate PPS signal available, you can configure the serial port to use along with some other settings here.
Status

The status page can be used to query the health of the upstream time sources, it shows the following characteristics.

Status
	

Human readable status of the upstream

Server
	

Upstream source

Ref ID
	

Source IP address or kiss code:

Stratum
	

NTP uses a hierarchical, semi-layered system of time sources (wikipedia) This field shows the stratum of the upstream source (lower usually means closer to the actual time source)

Type
	

Type of time source, one of:

    u: unicast or manycast client

    b: broadcast or multicast client

    p: pool source

    l: local (reference clock)

    s: symmetric (peer)

    A: manycast server

    B: broadcast server

    M: multicast server

When
	

time in seconds, minutes, hours, or days since the last packet was received, or ‘-‘ if a packet has never been received

Poll
	

poll interval in seconds

Reach
	

reach shift register (octal), when set to 377 all 8 bits are set and thus no responses have been lost. Convert to bits to inspect which tries failed. (e.g. 257 –> 10101111 means the last four responses where received and two where lost within the last 8 tries)

Delay
	

roundtrip delay in milliseconds

Offset
	

offset time in milliseconds of the server relative to this host

Jitter
	

indicates the difference, in milliseconds, between two samples


OpenDNS

OpenDNS is a company and service that extends the Domain Name System (DNS) by adding features such as phishing protection and optional content filtering in addition to DNS lookup, if its DNS servers are used.

When you are behind a static IP address, usually it should be enough to just enter the OpenDNS name servers in System ‣ Settings ‣ General.
Settings

A minimum amount of settings is needed in order to register with OpenDNS.

Enabled
	

If enabled, the firewall will signal OpenDNS about address changes

Username
	

Username registered with OpenDNS

Password
	

Associated password

Network
	

The network name configured on the Networks Dashboard of OpenDNS under ‘Manage your networks’. Used to update the node’s IP address whenever the WAN interface changes its IP address.

Note

When disabling the service, please check your name servers in System ‣ Settings ‣ General, since this feature removed the previous ones.


Unbound DNS

Unbound is a validating, recursive, caching DNS resolver. It is designed to be fast and lean and incorporates modern features based on open standards.

Since OPNsense 17.7 it has been our standard DNS service, which on a new install is enabled by default.
General settings

Below you will find the most relevant settings from the General menu section.

Enable
	

Enable our DNS resolver

Listen Port
	

Port to listen on, when blank, the default (53) is used.

Network Interfaces
	

Interface IP addresses used for responding to queries from clients. If an interface has both IPv4 and IPv6 IPs, both are used. Queries to other interface IPs not selected are discarded. The default behavior is to respond to queries on every available IPv4 and IPv6 address.

DNSSEC
	

Enable DNSSEC to use digital signatures to validate results from upstream servers and mitigate against cache poisoning.

DNS64
	

Enable DNS64 so IPv6-only clients can reach IPv4-only servers. If enabled, Unbound synthesizes AAAA records for domains which only have A records. DNS64 requires NAT64 to be useful, e. g. the Tayga plugin or a third-party NAT64 service. The DNS64 prefix must match the IPv6 prefix used be the NAT64.

AAAA-only mode
	

If this option is set, Unbound will remove all A records from the answer section of all responses.

Register ISC DHCP4 Leases
	

IPv4 only If this option is set, then machines that specify their hostname when requesting a DHCP lease will be registered in Unbound, so that their names can be resolved.

The source of this data is client-hostname in the dhcpd.leases file. This can also be inspected using the Leases page.

DHCP Domain Override
	

When the above registrations shouldn’t use the same domain name as configured on this firewall, you can specify a different one here.

Register ISC DHCP Static Mappings
	

Register static dhcpd entries so clients can resolve them. Supported on IPv4 and IPv6.

No IPv6 Link-local aaddresses
	

Do not register link local addresses for IPv6. This will prevent the return of unreachable addresses when more than one listen interface is configured.

System A/AAAA records
	

If this option is set, then no A/AAAA records for the configured listen interfaces will be generated. This also means that no PTR records will be created. If desired, you can manually add A/AAAA records in Overrides. Use this to control which interface IP addresses are mapped to the system host/domain name as well as to restrict the amount of information exposed in replies to queries for the system host/domain name.

TXT Comment Support
	

Register descriptions as comments for dhcp static host entries.

Local Zone Type
	

The local zone type used for the system domain. Type descriptions are available under “local-zone:” in the unbound.conf(5) manual page. The default is ‘transparent’.

Note

In order for the client to query unbound, there need to be an ACL assigned in Services ‣ Unbound DNS ‣ Access Lists. The configured interfaces should gain an ACL automatically. If the client address is not in any of the predefined networks, please add one manually.
Overrides

Within the overrides section you can create separate host definition entries and specify if queries for a specific domain should be forwarded to a predefined server.
Host override settings

Host overrides can be used to change DNS results from client queries or to add custom DNS records. PTR records are also generated under the hood to support reverse DNS lookups. These are generated in the following way:

    If System A/AAAA records in General settings is unchecked, a PTR record is created for the primary interface.

    Each host override entry that does not include a wildcard for a host, is assigned a PTR record.

    If a host override entry includes a wildcard for a host, the first defined alias is assigned a PTR record.

    Every other alias does not get a PTR record.

Host
	

Name of the host, without domain part. Use “*” to create a wildcard entry.

Domain
	

Domain of the host (such as example.com)

Type
	

Record type, A or AAA (IPv4 or IPv6 address), MX to define a mail exchange

IP
	

Address of the host

Description
	

User readable description, only for informational purposes

Aliases
	

Copies of the above data for different hosts

Aliases

You may create alternative names for a Host. E.g. when having a webserver with several virtual hosts you create a Host override entry with the IP and name for the webserver and an alias name for every virtual host on this webserver.

You have to select the host in the top list and it will the show you the assigned aliases in the bottom list.
Domain override settings

Domain overrides can be used to forward queries for specific domains (and subsequent subdomains) to local or remote DNS servers.

Important

Domain overrides has been superseded by Query Forwarding. Query forwarding also allows you to forward every single request.

Domain
	

Domain to override

IP address
	

IP address of the authoritative DNS server for this domain

Description
	

User readable description, only for informational purposes
Advanced

Although the default settings should be reasonable for most setups, some need more tuning or require specific options set. Some of these settings are enabled and given a default value by Unbound, refer to unbound.conf(5) for the defaults.

Hide Identity
	

If enabled, id.server and hostname.bind queries are refused.

Hide Version
	

If enabled version.server and version.bind queries are refused.

Prefetch Support
	

Message cache elements are prefetched before they expire to help keep the cache up to date. When enabled, this option can cause an increase of around 10% more DNS traffic and load on the server, but frequently requested items will not expire from the cache.

Prefetch DNS Key Support
	

DNSKEY’s are fetched earlier in the validation process when a Delegation signer is encountered. This helps lower the latency of requests but does utilize a little more CPU.

Harden DNSSEC data
	

DNSSEC data is required for trust-anchored zones. If such data is absent, the zone becomes bogus. If this is disabled and no DNSSEC data is received, then the zone is made insecure.

Serve expired responses
	

Serve expired responses from the cache with a TTL of 0 without waiting for the actual resolution to finish. When checked, multiple options to customize the behaviour regarding expired responses will appear.

Expired Record Reply TTL Value
	

TTL value to use when replying with expired data. If “Client Expired Response Timeout” is also used then it is recommended to use 30 as the default value as per RFC 8767. Only applicable when “Serve expired responses” is checked.

TTL for Expired Responses
	

Limits the serving of expired responses to the configured amount of seconds after expiration. A value of 0 disables the limit. A suggested value as per RFC 8767 is between 86400 (1 day) and 259200 (3 days). Only applicable when “Serve expired responses” is checked.

Reset Expired Record TTL
	

Set the TTL of expired records to the “TTL for Expired Responses” value after a failed attempt to retrieve the record from an upstream server. This makes sure that the expired records will be served as long as there are queries for it. Only applicable when “Serve expired responses” is checked.

Client Expired Response Timeout
	

Time in milliseconds before replying to the client with expired data. This essentially enables the serve- stable behavior as specified in RFC 8767 that first tries to resolve before immediately responding with expired data. A recommended value per RF 8767 is 1800. Setting this to 0 will disable this behavior. Only applicable when “Serve expired responses” is checked.

Strict QNAME Minimisation
	

Send minimum amount of information to upstream servers to enhance privacy. Do not fall-back to sending full QNAME to potentially broken nameservers. A lot of domains will not be resolvable when this option in enabled. Only use if you know what you are doing.

Extended Statistics
	

If enabled, extended statistics are printed to syslog.

Log Queries
	

If enabled, prints one line per query to the log, with the log timestamp and IP address, name, type and class. Note that it takes time to print these lines, which makes the server (significantly) slower. Odd (non-printable) characters in names are printed as ‘?’.

Log Replies
	

If enabled, prints one line per reply to the log, with the log timestamp and IP address, name, type, class, return code, time to resolve, whether the reply is from the cache and the response size. Note that it takes time to print these lines, which makes the server (significantly) slower. Odd (non-printable) characters in names are printed as ‘?’.

Tag Queries and Replies
	

If enabled, prints the word ‘query: ‘ and ‘reply: ‘ with logged queries and replies. This makes filtering logs easier.

Log level verbosity
	

Select the log verbosity. Level 0 means no verbosity, only errors. Level 1 gives operational information. Level 2 gives detailed operational information. Level 3 gives query level information, output per query. Level 4 gives algorithm level information. Level 5 logs client identification for cache misses. Default is level 1.

Private Domains
	

List of domains to mark as private. These domains and all its subdomains are allowed to contain private addresses.

Rebind Protection networks
	

These are addresses on your private network, and are not allowed to be returned for public internet names. Any occurrence of such addresses are removed from DNS answers. Additionally, the DNSSEC validator may mark the answers bogus. This protects against so-called DNS Rebinding. (Only applicable when DNS rebind check is enabled in Administration)

Insecure Domains
	

List of domains to mark as insecure. DNSSEC chain of trust is ignored towards the domain name.

Message Cache Size
	

Size of the message cache. The message cache stores DNS rcodes and validation statuses. The RRSet cache (which contains the actual RR data) will automatically be set to twice this amount. Valid input is plain bytes, optionally appended with ‘k’, ‘m’, or ‘g’ for kilobytes, megabytes or gigabytes respectively.

RRset Cache Size
	

Size of the RRset cache. Contains the actual RR data. Valid input is plain bytes, optionally appended with ‘k’, ‘m’, or ‘g’ for kilobytes, megabytes or gigabytes respectively. Automatically set to twice the amount of the Message Cache Size when empty, but can be manually modified.

Outgoing TCP Buffers
	

The number of outgoing TCP buffers to allocate per thread. If 0 is selected then no TCP queries to authoritative servers are done.

Incoming TCP Buffers
	

The number of incoming TCP buffers to allocate per thread. If 0 is selected then no TCP queries from clients are accepted.

Number of queries per thread
	

The number of queries that every thread will service simultaneously. If more queries arrive that need to be serviced, and no queries can be jostled out (see “Jostle Timeout”), then these queries are dropped. This forces the client to resend after a timeout, allowing the server time to work on the existing queries.

Outgoing Range
	

The number of ports to open. This number of file descriptors can be opened per thread. Larger numbers need extra resources from the operating system. For performance a very large value is best. For reference, usually double the amount of queries per thread is used.

Jostle Timeout
	

This timeout is used for when the server is very busy. Set to a value that usually results in one round-trip to the authority servers. If too many queries arrive, then 50% of the queries are allowed to run to completion, and the other 50% are replaced with the new incoming query if they have already spent more than their allowed time. This protects against denial of service by slow queries or high query rates.

Maximum TTL for RRsets and messages
	

Configure a maximum Time to live in seconds for RRsets and messages in the cache. When the internal TTL expires the cache item is expired. This can be configured to force the resolver to query for data more often and not trust (very large) TTL values.

Minimum TTL for RRsets and messages
	

Configure a minimum Time to live in seconds for RRsets and messages in the cache. If the minimum value kicks in, the data is cached for longer than the domain owner intended, and thus fewer queries are made to look up the data. The 0 value ensures the data in the cache is as the domain owner intended. High values can lead to trouble as the data in the cache might not match up with the actual data anymore.

TTL for Host cache entries
	

Time to live in seconds for entries in the host cache. The host cache contains round-trip timing, lameness and EDNS support information.

Keep probing down hosts
	

Keep probing hosts that are down in the infrastructure host cache. Hosts that are down are probed about every 120 seconds with an exponential backoff. If hosts do not respond within this time period, they are marked as down for the duration of the host cache TTL. This setting can be used in conjunction with “TTL for Host cache entries” to increase responsiveness if internet connectivity bounces happen frequently.

Number of Hosts to cache
	

Number of hosts for which information is cached.

Unwanted Reply Threshold
	

If enabled, a total number of unwanted replies is kept track of in every thread. When it reaches the threshold, a defensive action is taken and a warning is printed to the log file. This defensive action is to clear the RRSet and message caches, hopefully flushing away any poison.
Access Lists

Access lists define which clients may query our dns resolver. Records for the assigned interfaces will be automatically created and are shown in the overview. You can also define custom policies, which apply an action to predefined networks.

Note

The action can be as defined in the list below. The most specific netblock match is used, if none match deny is used. The order of the access-control statements therefore does not matter.
Actions

Deny
	

This action stops queries from hosts within the defined networks.

Refuse
	

This action also stops queries from hosts within the defined networks, but sends a DNS rcode REFUSED error message back to the client.

Allow
	

This action allows queries from hosts within the defined networks.

Allow Snoop
	

This action allows recursive and nonrecursive access from hosts within the defined networks. Used for cache snooping and ideally should only be configured for your administrative host.

Deny Non-local
	

Allow only authoritative local-data queries from hosts within the defined networks. Messages that are disallowed are dropped.

Refuse Non-local
	

Allow only authoritative local-data queries from hosts within the defined networks. Sends a DNS rcode REFUSED error message back to the client for messages that are disallowed.
Blocklists

Enable integrated dns blacklisting using one of the predefined sources or custom locations.

Enable
	

Enable blacklists

Enable SafeSearch
	

Force the usage of SafeSearch on Google, DuckDuckGo, Bing, Qwant, PixaBay and YouTube.

Type of DNSBL
	

Predefined external sources

URLs of Blacklists
	

Additional http[s] location to download blacklists from, only plain text files containing a list of fqdn’s (e.g. my.evil.domain.com) OR wildcard domains (e.g. *.my.evil.domain.com) are supported.

Whitelist Domains
	

When a blacklist item contains a pattern defined in this list it will be ommitted from the results. e.g. .*.nl would exclude all .nl domains. Blocked domains explicitly whitelisted using the Reporting: Unbound DNS page will show up in this list.

Blocklist Domains
	

List of domains to explicitly block. Regular expressions are not supported. Passed domains explicitly blocked using the Reporting: Unbound DNS page will show up in this list.

Wildcard Domains
	

List of wildcard domains to blocklist. All subdomains of the given domain will be blocked. Blocking first-level domains (e.g. ‘com’) is not supported.

Destination Address
	

Specify an IP address to return when DNS records are blocked. Can be used to redirect such domains to a separate webserver informing the user that the content has been blocked. The default is 0.0.0.0. Any value in this field is skipped if “Return NXDOMAIN” is checked.

Return NXDOMAIN
	

Instead of returning the “Destination Address”, return the DNS return code “NXDOMAIN”. This is useful in cases where devices cannot cope with the 0.0.0.0 destination address, such as certain Apple devices.

Note

Applying the blocklist settings will not restart Unbound, rather it will signal to Unbound to dynamically process the blocklists as soon as they’re downloaded. There may be up to a minute of delay before Unbound has loaded everything. During this time Unbound will still be just as responsive.

When any of the DNSBL types are used, the content will be fetched directly from its original source, to get a better understanding of the source of the lists we compiled the list below containing references to the list maintainers.
Predefined sources

Abuse.ch - ThreatFox IOC database
	

https://threatfox.abuse.ch/

AdAway List
	

https://adaway.org/hosts.txt

AdGuard List
	

https://v.firebog.net/hosts/AdguardDNS.txt

OISD - Domain Blocklist Ads*
	

https://small.oisd.nl/domainswild

OISD - Domain Blocklist Big*
	

https://big.oisd.nl/domainswild

OISD - Domain Blocklist NSFW*
	

https://nsfw.oisd.nl/domainswild

Blocklist.site
	

https://github.com/blocklistproject/Lists

EasyList
	

https://v.firebog.net/hosts/Easylist.txt

Easyprivacy
	

https://v.firebog.net/hosts/Easyprivacy.txt

NoCoin List
	

https://github.com/hoshsadiq/adblock-nocoin-list/

PornTop1M List
	

https://github.com/chadmayfield/my-pihole-blocklists

Simple Ad List
	

https://s3.amazonaws.com/lists.disconnect.me/simple_ad.txt

Simple Tracker List
	

https://s3.amazonaws.com/lists.disconnect.me/simple_tracking.txt

StevenBlack/hosts
	

https://raw.githubusercontent.com/StevenBlack/hosts/master/hosts

WindowsSpyBlocker
	

https://github.com/crazy-max/WindowsSpyBlocker

YoYo List
	

https://pgl.yoyo.org/adservers/

Note

The OISD lists are wildcard lists. Meaning that they will block all subdomains of the listed domains. For more information, refer to OISD. This keeps the list small and manageable, but are more effective than regular lists.

Note

In order to automatically update the lists on timed intervals you need to add a cron task, just go to System -> Settings ->Cron and a new task for a command called “Update Unbound DNSBLs”.

Usually once a day is a good enough interval for these type of tasks.
Query Forwarding

The Query Forwarding section allows for entering arbitrary nameservers to forward queries to. It is assumed that the nameservers entered here are capable of handling further recursion for any query. In this section you are able to specify nameservers to forward to for specific domains queried by clients, catch all domains and specify nondefault ports.

Use System Nameservers
	

The configured system nameservers will be used to forward queries to. This will override any entry made in the custom forwarding grid, except for entries targeting a specific domain. If there are no system nameservers, you will be prompted to add one in General. If you expected a DNS server from your WAN and it’s not listed, make sure you set “Allow DNS server list to be overridden by DHCP/PPP on WAN” there as well.

Warning

Do not use the system nameservers option if you have a multi-WAN setup and have Unbound running alongside multiple DNS servers configured in General with separate gateways assigned to them. Unbound will use the locally created routes to reach the system nameservers, which will not work when the gateway is down.

Note

Keep in mind that if the “Use System Nameservers” checkbox is checked, the system nameservers will be preferred over any catch-all entry in both Query Forwarding and DNS-over-TLS, this means that entries with a specific domain will still be forwarded to the specified nameserver.

Enabled
	

Enable query forwarding for this domain.

Domain
	

Domain of the host. All queries for this domain will be forwarded to the nameserver specified in “Server IP”. Leave empty to catch all queries and forward them to the nameserver.

Server IP
	

Address of the DNS server to be used for recursive resolution.

Port
	

Specify the port used by the DNS server. Default is port 53. Useful when configuring e.g. DNSCrypt-Proxy

Warning

Be careful enabling “DNS Query Forwarding” in combination with DNSSEC, no DNSSEC validation will be performed for forwards with a specific domain, as the upstream server might be a local controller. If forwarding everything and the upstream server doesn’t support DNSSEC, its answers will not reach the client as no DNSSEC validation could be performed.
DNS over TLS

DNS over TLS uses the same logic as Query Forwarding, except it uses TLS for transport.

Note

Please be aware of interactions between Query Forwarding and DNS over TLS. Since the same principle as Query Forwarding applies, a catch-all entry specified in both sections will be considered a duplicate zone. In our case DNS over TLS will be preferred.

Enabled
	

Enable DNS over TLS for this domain.

Domain
	

Domain of the host. All queries for this domain will be forwarded to the nameserver specified in “Server IP”. Leave empty to catch all queries and forward them to the nameserver.

Server IP
	

Address of the DNS server to be used for recursive resolution.

Port
	

Specify the port used by the DNS server. Always enter port 853 here unless there is a good reason not to, such as when using an SSH tunnel.

Verify CN
	

The name to use for certificate verification, e.g. “445b9e.dns.nextdns.io”. Used by Unbound to check the TLS authentication certificates. It is strongly discouraged to omit this field since man-in-the-middle attacks will still be possible.

Tip

To ensure a validated environment, it is a good idea to block all outbound DNS traffic on port 53 using a firewall rule when using DNS over TLS. Should clients query other nameservers directly themselves, a NAT redirect rule to 127.0.0.1:53 (the local Unbound service) can be used to force these requests over TLS.

Public Resolvers

Hosted by
	

Server IP
	

Server Port
	

Verify CN

Cloudflare
	

1.1.1.1
	

853
	

cloudflare-dns.com

1.0.0.1

2606:4700:4700::1111

2606:4700:4700::1001

Google
	

8.8.8.8
	

853
	

dns.google

8.8.4.4

2001:4860:4860::8888

2001:4860:4860::8844

Quad9
	

9.9.9.9
	

853
	

dns.quad9.net

149.112.112.112

2620:fe::fe

2620:fe::9
Statistics

The statistics page provides some insights into the running server, such as the number of queries executed, cache usage and uptime.
Advanced Configurations

Some installations require configuration settings that are not accessible in the UI. To support these, individual configuration files with a .conf extension can be put into the /usr/local/etc/unbound.opnsense.d directory. These files will be automatically included by the UI generated configuration. Multiple configuration files can be placed there. But note that

    As it cannot be predicted in which clause the configuration currently takes place, you must prefix the configuration with the required clause. For the concept of “clause” see the unbound.conf(5) documentation.

    The wildcard include processing in Unbound is based on glob(7). So the order in which the files are included is in ascending ASCII order.

    Name collisions with plugin code, which use this extension point e. g. dnsbl.conf, may occur. So be sure to use a unique filename.

    It is a good idea to check the complete configuration via:

    # check if the resulting configuration is valid
    configctl unbound check

    This will report errors that prevent Unbound from starting and also list warnings that may give hints as to why a particular configuration is not working or how it could be improved.

This is a sample configuration file to add an option in the server clause:

server:
  private-domain: xip.io

Note

As a more permanent solution the template system (“Using Templates”) can be used to automatically generate these files.

To get the same effect as placing the file in the sample above directly in /usr/local/etc/unbound.opnsense.d follow these steps:

    Create a +TARGETS file in /usr/local/opnsense/service/templates/sampleuser/Unbound:

    sampleuser_additional_options.conf:/usr/local/etc/unbound.opnsense.d/sampleuser_additional_options.conf

    Place the template file as sampleuser_additional_options.conf in the same directory:

    server:
      private-domain: xip.io

    Test the template generation by issuing the following command:

    # generate template
    configctl template reload sampleuser/Unbound

    Check the output in the target directory:

    # show generated file
    cat /usr/local/etc/unbound.opnsense.d/sampleuser_additional_options.conf
    # check if configuration is valid
    configctl unbound check

Warning

It is the sole responsibility of the administrator which places a file in the extension directory to ensure that the configuration is valid.

Note

This method replaces the Custom options settings in the General page of the Unbound configuration, which was removed in version 21.7.

Router Advertisements

radvd (the service responsible for this functionality) is the router advertisement daemon for IPv6. It listens to router solicitations and sends router advertisements as described in “Neighbor Discovery for IP Version 6 (IPv6)” (RFC 4861). With these advertisements hosts can automatically configure their addresses and some other parameters. It also defines “Neighbor Discovery Optimization for IPv6 over Low-Power Wireless Personal Area Networks (6LoWPANs)” (RFC6775). They also can choose a default router based on these advertisements.
Router Advertisements (Mode)

The mode selection contains some predefined settings for radvd, which influence a set of configuration options and are intended for specific implementation scenarios. They define the type of client deployment used in your network.

Router Only
	

Only advertise this router, clients are using static IPv6 addressses

Unmanaged
	

Clients will use Stateless Address Autoconfiguration (SLAAC), without other (non-address) information being provided.

Managed
	

Stateful configuration, address configuration provided by DHCPv6

Assisted
	

Stateful configuration, address configuration provided by DHCPv6, although advertised routes can also be used on Stateless Address Autoconfiguration setups (SLAAC).

Stateless
	

Clients will use Stateless Address Autoconfiguration (SLAAC)

A detailed overview of the radvd settings determined by the mode can be found below:

scope
	

Settings
	

Router Only
	

Unmanaged
	

Managed
	

Assisted
	

Stateless

Per interface
	

AdvManagedFlag
			

X
	

X
	

AdvOtherConfigFlag
			

X
	

X
	

X

Per prefix
	

AdvOnLink
		

X
	

X
	

X
	

X

AdvAutonomous
		

X
		

X
	

X

Note

Technical details about the options can be found in the man page of radvd
General

Priority
	

The preference associated with the default router, as either “low”, “medium” (default), or “high”.

RA Interface
	

Interface to use prefix from.

Advertise Default Gateway
	

uses AdvDefaultLifetime to disable advertising as default router when unset.

Advertise Routes
	

Advertise more specific specific routes to the clients.
DNS

For supported clients, DNS settings can also be propagated by radvd as detailed in RFC 8106

DNS servers
	

Define which dns servers to publish to the clients, either the ones defined here or (when Use the DNS settings of the DHCPv6 server is set) the ones defined in the DHCPv6 server for this interface. (RDNSS in radvd)

Domain search list
	

Domain search list to push to the clients, when not specified the local domain name from this firewall is used. (DNSSL in radvd)
Intervals

The time between unsolicited multicast router advertisement can be configured, using the following settings, usually these are left default.

Minimum Interval
	

The minimum time allowed between sending unsolicited multicast router advertisements from the interface, in seconds. Must be no less than 3 seconds and no greater than 0.75 * “Maximum Interval”.

Maximum Interval
	

The maximum time allowed between sending unsolicited multicast router advertisements from the interface, in seconds. Must be no less than 4 seconds and no greater than 1800 seconds.

Log Files

When troubleshooting problems with your firewall, it is very likely you have to check the logs available on your system. In the UI of OPNsense, the log files are generally grouped with the settings of the component they belong to. The log files can be found here:

Captive Portal
	

Services ‣ Captive Portal ‣ Log File
	

Events from Captive Portal go here

DHCPv4
	

Services ‣ DHCPv4 ‣ Log File
	

DHCP events get logged here

Dnsmasq DNS
	

Services ‣ Dnsmasq DNS ‣ Log File
	

The DNSmasq Forwarder logs

HAProxy
	

Services ‣ HAProxy ‣ Log File
	

The logs of the Reverse Proxy

Intrusion Detection
	

Services ‣ Intrusion Detection ‣ Log File
	

Suricata Logs are here

Network Time
	

Services ‣ Network Time ‣ Log File
	

NTP daemon logs

Unbound DNS
	

Services ‣ Unbound DNS ‣ Log File
	

Unbound resolver logs can be found here

Web Proxy
	

Services ‣ Web Proxy ‣ Log File
	

Squid access.log, store.log and cache.log


Setup a Guest Network

This how to will explain how to setup a guest network using the captive portal. Guest Networks are widely used to allow guests controlled internet access at hotels, RV Parks or businesses.
../../_images/opnsense_hotspot_controller.png

Note

For the example we expect the GUESTNET interface to be connected with your actual guest network switch or access point. This tutorial does not explain how to setup a wireless network.
Businesses

Businesses usually want to share internet access with their guest and show them a landing page with a welcome message and some usage guidelines (policy). At the same time it is important to make sure guests won’t be able to access the company’s local network and limit the maximum internet usage.
Hotels and RV Parks

Hotels and RV parks usually utilize a captive portal to allow guests (paid) access to internet for a limited duration. Guests need to login using a voucher they can either buy or obtain for free at the reception. OPNsense has built-in support for vouchers and can easily create them on the fly. With this example we will show you how to setup the Guest Network for this purpose and setup a reception account for creating new vouchers.
Advanced

The Captive portal can also be combined with the category based web filtering of the proxy. This tutorial will explain how to combine both features.
Prerequisites

We will start configuration with a fresh OPNsense install, updated to the latest patch level (16.1.5_1 in our example). You will need a system with a minimum of 3 ports (LAN/WAN/GUESTNET) for this tutorial.
Good to know

As the Hotel/RV Parks setup is almost identical to the business setup we will start with that and after finishing add/change the specifics to match the Hotel Guest setup.
Step 1 - Configure Interface

For the Guest Network we will add a new interface. Go to Interfaces ‣ Assignments And use the + to add a new interface. Press Save. The new interface will be called OPT1, click on [OPT1] in the left menu to change its settings.

Select Enable Interface and fill in the following data for our example:

Description
	

GUESTNET
	

A descriptive name for the interface

Block Private networks
	

unselected
	

Block bogon networks
	

unselected
	

IPv4 Configuration Type
	

Static IPv4
	

Set a static IPv4 address for the example

IPv6 configuration Type
	

None
	

MAC address
	

(Leave Blank)
	

MTU
	

(Leave Blank)
	

MSS
	

(Leave Blank)
	

Speed and duplex
	

Default
	

You may also select the speed when known

Static IPv4 address
	

192.168.200.1/24
	

We will use this segment for our guests

IPv4 Upstream Gateway
	

Default
	

Press Save and then Apply changes.
Step 2 - Configure DHCP Server

Go to Services ‣ DHCPv4 ‣ [GUESTNET].

Fill in the following to setup the DHCP server for our guest net (leave everything

    else on its default setting):

Enable
	

Checked
	

Enable the DCHP server on GUESTNET

Range
	

192.168.200.100 to 192.168.200.200
	

Serve IPs from this range

DNS servers
	

192.168.200.1
	

Supply a DNS with the lease

Gateway
	

192.168.200.1
	

Supply a gateway with the lease

Click Save.
Step 3 - Add Firewall Rules

Go to Firewall ‣ Rules to add a new rule.

Now add the following rules (in order of prevalence):
Allow DNS

Allow the guests access to the DNS forwarder. Rule content (leave all other options default):

Action
	

Pass
	

Allow this traffic

Interface
	

GUESTNET
	

The GuestNet Interface

Protocol
	

TCP/UDP
	

Source
	

GUESTNET net
	

Destination
	

GUESTNET address
	

Destination port range
	

DNS/DNS
	

from DNS to DNS

Category
	

GuestNet Basic Rules
	

Category used for grouping rules

Description
	

Allow DNS
	

Click Save.
Allow Captive Portal Login

Action
	

Pass
	

Allow this traffic

Interface
	

GUESTNET
	

The GuestNet Interface

Protocol
	

TCP
	

Source
	

GUESTNET net
	

Destination
	

GUESTNET address
	

Destination port range
	

8000/10000
	

(other) used for the cp zones

Category
	

GuestNet Basic Rules
	

Category used for grouping rules

Description
	

Allow Captive Portal Login
	

Click Save.
Block Local Networks

Action
	

Block
	

Block this traffic

Interface
	

GUESTNET
	

The GuestNet Interface

Protocol
	

any
	

Source
	

GUESTNET net
	

Destination
	

LAN net
	

Category
	

GuestNet Basic Rules
	

Category used for grouping rules

Description
	

Block Local Networks
	

Click Save.

Action
	

Block
	

Block this traffic

Interface
	

GUESTNET
	

The GuestNet Interface

Protocol
	

any
	

Source
	

GUESTNET net
	

Destination
	

GUESTNET address
	

Category
	

GuestNet Basic Rules
	

Category used for grouping rules

Description
	

Block Firewall Access
	

Click Save.

Note

These rules are used to block access to our local LAN network and firewall access from the Guests. If you have multiple local networks then you need to block each of them with multiple rules or use a bigger subnet to cover them all.
Allow Guest Networks

Action
	

Pass
	

Allow this traffic

Interface
	

GUESTNET
	

The GuestNet Interface

Protocol
	

any
	

Source
	

GUESTNET net
	

Destination
	

any
	

Destination port range
	

any
	

Category
	

GuestNet Basic Rules
	

Category used for grouping rules

Description
	

Allow Guest Network
	

Click Save and then Apply changes

Your rules should look similar to the screenshot below:
../../_images/guestnet_fwrules.png
Step 4 - Create Captive Portal

Go to Services ‣ Captive Portal ‣ Administration

To add a new Zone press the + in the lower right corner of the form.

Note

When using multiple interfaces with the captive portal then each interface can have its own zone or multiple interfaces can share a zone.

For the Business setup we will start with the following settings:

Enabled
	

Checked
	

Interfaces
	

GUESTNET
	

Remove the default and add GUESTNET

Authenticate using
	

(blank)
	

Remove any default setting

Idle timeout
	

0
	

Disable Idle Timeout

Hard timeout
	

0
	

No hard timeout

Concurrent user logins
	

Unchecked
	

A user may only login once

SSL certificate
	

none
	

Use plain http

Hostname
	

(leave blank)
	

Used for redirecting login page

Allowed addresses
	

(leave blank)
	

Custom template
	

none
	

Use default template

Description
	

Guest Network
	

Choose a description for the zone

Save and the Apply
Step 5 - Create Template

The template feature is one of the most powerful features of OPNsense’s Captive Portal solution and it’s very easy to work with.

Let’s create a custom landing page, to do so click on the tab Templates and click on the download icon in the lower right corner ( download ).
../../_images/template_download.png

Now download the default template, we will use this to create our own. Unpack the template zip file, you should have something similar to this:
../../_images/template_filelisting.png

Most files of the template can be modified, but some are default and may not be changes. Upon upload any changes to the files listed in exclude.list will be ignored. Currently these include the bootstrap JavaScript and some fonts.

With the captive portal enabled the default screen looks like:
../../_images/default_login_no_authenticator.png

Let’s change this default with a new logo and a welcome message, to this:
../../_images/mycompany_login.png

To do so use your favourite editor and open the index.html file to make the changes.

Let’s make the following changes to the template:

    Change the logo to company-logo.png

    Remove the navigation bar on the top

    Remove the height and width from the <img> tag

    Add a welcome text

    Make a link to the company website

Find the following part:

<header class="page-head">
<nav class="navbar navbar-default" >
    <div class="container-fluid">
        <div class="navbar-header">
            <a class="navbar-brand" href="#">
                <img class="brand-logo" src="images/default-logo.png" height="30" width="150">
            </a>
        </div>
    </div>
</nav>
</header>

And change to:

<header class="page-head">
    <div align="center">
      <a href="#">
          <img class="brand-logo" src="images/company-logo.png">
      </a>
      <h1>Welcome to My Company Guest Network.</h1>
      <h2>Feel free to use the guest network for profesional usage</h2>
      <h3>See our website for more details: <a href="https://www.opnsense.org">My Company</a></h3>
    </div>
</header>

Copy the company logo to the image directory. Now zip the template directory and upload the new template by pressing the + on the Template tab.

Download the example Template (full)

Enter a Template Name, for this example we use Company. Hit Upload ( upload )

To enable the captive portal on the GUESTNET interface just click on Apply.
Step 6 - Limit Guests Bandwidth

For our example we will reserve 10 Mbps down and 1 Mbps Up for the Guest Network’s Internet Access. This bandwidth will be shared evenly between connected clients.

Note

With sharing evenly we mean that if 10 users at the same time try to use as much bandwidth as possible then everyone gets 1/10th. So in our example that would be 1 Mbps down stream (download). It is also possible to limit the traffic per user see also Setup Traffic Shaping

Go to: Firewall ‣ Shaper ‣ Pipes.

Create a pipe for the Download by pressing the + in the lower right corner of the form and enter the following details:

Enabled
	

Checked

bandwidth
	

10

bandwidth Metric
	

Mbit/s

mask
	

Destination

Description
	

pipe_10Mbps_down

Click Save changes. And add another pipe for the upload traffic.

Enabled
	

Checked

bandwidth
	

1

bandwidth Metric
	

Mbit/s

mask
	

Destination

Description
	

pipe_1Mbps_up

Click on Save changes.

Create the traffic shaper rules. Click on the tab Rules and press the + to do so.

First toggle the advanced mode (upper left corner of the form) and then fill in the following details (leave everything not specified on defaults):

sequence
	

(leave on default)

interface
	

WAN

interface 2
	

GUESTNET

direction
	

in

target
	

pipe_10Mbps_down

description
	

Limit Guests download to 10 Mbps

Click Save changes.

sequence
	

(leave on default)

interface
	

WAN

interface 2
	

GUESTNET

direction
	

out

target
	

pipe_1Mbps_up

description
	

Limit Guests upload to 1 Mbps

Click Save changes.

Now click on Apply to apply the changes.
Step 7 - Test Business GuestNet

Connect your PC or laptop to the Guest Network and start your favourite browser. Enter an address to browse to and you will be presented with the Login form we created with the template in the previous step. Click on login and start browsing.

To test your traffic shaper go to a speed test site such as http://www.speedtest.net/ After testing your result should be similar to this (if your internet connection has sufficient bandwidth).

    ../../_images/cp-traffic-shaping.png 

Note

Keep in mind we have only one connected client in this test, so all reserved bandwidth will be available for our client.
Royal Hotel Example

From this point we will implement the Hotel/RV Park solution. You need to follow step 1-7 first and choose the template you like to use for your guests.

This example will be for our “Royal Hotel”.
Step 8 - Add Voucher Server

To add a Voucher Server go to: System ‣ Access ‣ Servers and click on Add server in the top right corner of the screen.

Fill in:

Descriptive name
	

Vouchers
	

The name for your voucher server

Type
	

Voucher
	

Click on Save.
Step 9 - Create Vouchers

Go back to the Captive portal and select Vouchers (Services ‣ Captive Portal ‣ Vouchers). Click on Create Vouchers in the lower right corner of the form.

Let’s create 1-day vouchers for our guests:
../../_images/create_vouchers.png

Enter the Validity (1 day), the number of Vouchers and a Groupname (Wi-Fi day pass, for example). For the example we create 10 vouchers. Click on Generate.

A file will be generated called Wi-Fi day pass.csv. The content of this file looks like this:

username,password,vouchergroup,validity
"IgJw@Pqf","MLi+Sb7Ak#","Wi-Fi day pass","86400"
"++?f[@i[","!m*)e(@;F,","Wi-Fi day pass","86400"
"bbtK9mBk","f/jCDL3:)b","Wi-Fi day pass","86400"
"iD%L[jLJ","I#FoZ#g!AY","Wi-Fi day pass","86400"
"+4bA\E[I","CNavt@0ck+","Wi-Fi day pass","86400"
"+,fg/\Sv","#22iIL-iQA","Wi-Fi day pass","86400"
":;Pc\N#s","Y\HuG9vAN$","Wi-Fi day pass","86400"
"00nLb=0Q","0*C_\_Nb_x","Wi-Fi day pass","86400"
"PA$J0YHF","kp!q%9;m)g","Wi-Fi day pass","86400"
"a,mCxbya","LcnCb#g/di","Wi-Fi day pass","86400"

The content are:

username
	

Username the guest needs to login with

password
	

Password the guest needs to login with

vouchergroup
	

The name of the group you created

validity
	

The time the voucher will be valid in seconds

Warning

For security reasons the plain text passwords for the vouchers are NOT stored on the firewall.

This file can be used for creating nice guest vouchers (on paper) by just merging the CSV data with Microsoft Word, LibreOffice or any other DTP/text editor.

Create something like this:
../../_images/cp_royalhotel_voucher.png

You can select a database to and remove it entirely. This way you can create a voucher database for the arrival date of guest per guest group (week, midweek, weekend, etc.) and delete the full database when the guests have left.

Note

When a voucher is activated the time will be used regardless of the user being logged in or out. For a “used time” solution use a Radius server look at Setup FreeRADIUS for accounting
Step 10 - Voucher Authentication

Enable the voucher authentication by changing the zone settings. Go to the tab Zones and select the Guest Network by clicking on the pencil icon right next to it.

Change Authenticate using from an empty field to Vouchers.

When done click Save changes and the Apply to apply the new settings.

Now users will see the login form as part of your template:
../../_images/cp_voucher_login.png
Check Sessions

To check the active sessions go to Services ‣ Captive Portal ‣ Sessions Our current session looks like this:
../../_images/cp_active_sessions.png

You can drop an active session by clicking on the trashcan.

Note

Notice the selection box at the upper right corner, with this you can select the right zone when you have configured more than one.
Check Voucher Status

You can check the validity and active status of a voucher by going to the voucher page of the captive portal (Services ‣ Captive Portal ‣ Vouchers) and select the correct database (Wi-Fi day pass in our example).
../../_images/cp_active_vouchers.png

Note

The state valid means it is activated but still valid.
Advanced - Session popup

Let’s create a Session Popup so users can see some details about their session and Logout. For this feature we will use OPNsense’s built-in API calls.

In particular we will use the following API call (for zone id 0):

/api/captiveportal/access/status/0/

The response on this API call looks like this (for an active session):

{"userName":"IgJw@Pqf",
"macAddress":"10:dd:b1:bc:75:46",
"acc_session_timeout":14095,
"authenticated_via":"Vouchers",
"packets_out":2834,
"bytes_in":512869,
"last_accessed":1457527526,
"zoneid":0,
"sessionId":"npd5bd6SIVQeMfIbWBdong==","
startTime":1457526930.1719,
"bytes_out":1322351,
"ipAddress":"192.168.200.100",
"packets_in":3181,
"clientState":"AUTHORIZED"}

It would go a bit to far to explain standard HTML and JavaScript used for our simple popup, but a full demo template can be downloaded:

Download the example Template (with popup)

The demo includes a new file called session_popup.html with all the logic to show the time left on the voucher and a logout button. As well as a simple update to our index.html page to call the popup on a successful login. The latter looks like this (shown with a bit of context):

// redirect on successful login
if (data['clientState'] == 'AUTHORIZED') {
    window.open("session_popup.html","Session Status & Logout","width=400, height=400");

../../_images/captiveportal_popup.png
Advanced - CLI Session Status

OPNsense has a very powerful CLI that is particularly useful for debugging purposes. For this example we will use the cli to list the status off all active sessions.

Type the following on the cli prompt to do so (for zone id 0):

configctl captiveportal list_clients 0

The output will be something similar to this:
../../_images/cli_list_captiveportalsessions.png


Community Plugins
_images/manual_guy.png

Plugins help extending your security product with additional functionality, some plugins are maintained and supported by the OPNsense team, a lot are supported by the community.

This section houses the documentation available for some of these plugins, not all come with documentation, some might not even need it given the complexity of the functionality.
DNS

    Dynamic DNS
    BIND Plugin
    DNSCrypt-Proxy
    Multicast DNS Proxy

VPN & Connectivity

    OpenConnect Setup
    Stunnel
    Zerotier Configuration
    Dynamic Routing (FRR)
        Dynamic Routing: How To
        Dynamic Routing: Configuration: OSPFv2
        Dynamic Routing: Configuration: RIP
    Tor Configuration
    Tayga NAT64 how-to

Web

    Reverse Proxy and Webserver
    Anti Virus Engine
    c-icap
    ClamAV
    nginx: Basic Load Balancing
    nginx: Header Hardening
    nginx: Local Website Hosting
    nginx: Basic Authentication & Authorization
    nginx: IP Based Access Control Lists
    nginx: TLS Fingerprints
    nginx: TLS Authentication & Authorization
    nginx: Web Application Firewall
    nginx: TCP And UDP Streams
    Caddy: Reverse Proxy
    Caddy: HTTP Handlers
    Caddy: Layer4 Routes
    Caddy: Troubleshooting

Other

    CPU Microcode updates [AMD/Intel]
    Caching Proxy
        Advanced Proxy access management
        Setup Caching Proxy
        Setup a Guest Network
        Setup WPAD / PAC
        Setup Anti Virus Protection
        Setup Anti Virus Protection using OPNsense Plugins
        Setup Transparent Proxy
        Setup Web Filtering
    FreeRADIUS
    Setup FreeRADIUS for accounting
    How To: Setting Up A Mail Gateway
    Traceability of configuration changes using Git
    Relayd
    Wazuh Agent

Reporting

    ntopng


Dynamic DNS

In order to update dns registations when the local IP address changes, a Dynamic DNS service provider can be used. Our os-ddclient plugin offers support for various services using the ddclient software.
Prerequisites

Before installing and using this plugin, make sure to register an account with one of the supported services.
Installation

Installation of this plugin is rather easy, go to System ‣ Firmware ‣ Plugins and search for os-ddclient, use the [+] button to install it.

Next go to Services ‣ Dynamic DNS ‣ Settings to configure one or more Dynamic DNS services.
General settings

The general settings tab offers access to general options used by all configured dynamic dns services on this firewall. By default the service is enabled after installation,

Option
	

Description

Enable
	

Enable the client

Interval
	

The number of seconds address changes will be queried

Backend
	

Select the backend to use, either “ddclient” or “native”

Note

With ddlient developments sunsetting [*] we decided to offer an alternative written in Python. Selecting the native backend replaces the employed implementation. If your service is supported, we do advice to try out the new native backend which also offers support for custom HTTP requests.
Accounts

In the primary tab you can register one or more dynamic dns providers which will be used to update dns registrations using an api call over http(s) to the selected service.

Note

The local IP address used for this firewall will be obtained by querying one of the selected providers. Since ddclient currently doesn’t support dual stack (IPv4+IPv6) opertion, make sure to either select an IPv4 or IPV6 address provider in the settings tab.

Option
	

Description

Enable
	

Enable this rule (allows turning entries off without removing them).

Service
	

The provider of your Dynamic DNS Service.

resourceId
	

A pointer to the service to be updated, currently only relevant for Azure

Username
	

Login or user name to use, could be empty for token based authentication

Password
	

Password or security token to use

Hostname
	

Enter the fully qualified domain names to update via the selected service. For example: myhost.dyndns.org

Check ip method
	

Service to query the current IP address

Check ip timeout
	

How long to wait before the checkip process times out

Force SSL
	

Choose to use HTTP or HTTPS, but only for selected services. Most services only support HTTPS nowadays.

Interface to monitor
	

Interface to collect an address from when choosing “Interface” as check ip method, or source interface used to connect to the check ip service

Description
	

A description to easily identify this rule in the overview.
Provider-specific configuration
Cloudflare

For accounts with Cloudflare as provider, there is an additional option Zone, which should be set as the name of the zone containing the host to be updated, not its zone ID.

Cloudflare accepts authorization with the global token with the options

Option
	

Value

Username
	

The email of the Cloudflare account.

Password
	

Global API Key.

Using an API token is recommended for security reasons, with Permissions Zone ‣ DNS ‣ Edit and Zone Resources Include ‣ Specific zone ‣ zone with the host, and the account options

Option
	

Value

Username
	

token

Password
	

API token.
Netcup DNS

Netcup is a German hosting provider who offers an API for DNS manipulation:

    Wiki: https://www.netcup-wiki.de/wiki/DNS_API

    Technical documentation: https://ccp.netcup.net/run/webservice/servers/endpoint.php

Option
	

Value

Username
	

customer number

Password
	

APIPassword|APIKey, both fields need to be concatenated using a pipe (|) symbol as separator.


BIND Plugin
History

The history of the Bind plugin was a user request on OPNsense subreddit to create a plugin with a full-featured DNS server, also able to manage zonefiles with the most popular resource records. In the beginning the plugin was built with only general features so the community can contribute and adding wished features with a friendly review of the OPNsense team.

At the time of writing the plugin is able to be used as a local resolver and as a nice replacement for pfBlockerNG or PiHole, since it is offering a DNSBL feature via BIND Reverse Policy Zones.
Installation

First of all, go to System ‣ Firmware ‣ Plugins and install os-bind. You will finde the plugin at Services ‣ BIND.
General Settings

Enable BIND Daemon

    Enable the BIND service.
Listen IPs

    Set the IP addresses the daemon should listen on.
Listen IPv6

    Set the IPv6 addresses the daemon should listen on.
Listen Port

    Set the port the daemon should listen on. Per default the port is 53530 to not interfere with existing Unbound/Dnsmasq setups. If you want to switch to BIND only, make sure to stop Unbound/Dnsmasq and switch to port 53 with both 0.0.0.0 and :: as listening addresses set up.
DNS Forwarders

    A list of IP addresses BIND will forward unknown DNS request to. If empty BIND tries to resolve directly via the root servers.
Logsize in MB

    The amount for each logfile it can grow.
Maximum Cache Size

    This is the amount of RAM (in percent) the daemon can use for caching.
Recursion

    You have to set a list of networks via ACL tab to allow them using recursion against BIND.
DNSSec Validation

    Whether to enable or disable DNSSec validation.

DNSBL

Enable DNSBL

    Enable the DNSBL service. BIND will be configured for Reverse Policy Zones to blacklist domains. Choose below the lists to use for blacklist categories.
Type of DNSBL

    Here you can select the lists to use. Do not just select all and save. There are websites not loading content when nested ads are not loaded.
Whitelist Domains

    When a website is blocked due to a false positiv you can enter the domain name here so it is whitelisted before the blacklists come into play.

The Blacklists are downloaded and updated with every Save within BIND configuration. For production use you can go to System ‣ Settings ‣ Cron and add a cronjob. On the dropdown list you’ll find the corret task under Command. Set the refresh interval as you wish and save. This will trigger an update of the selected lists and reload BIND.
ACLs

On tab ACLs you can create ACLs used for configuration options like Recursion. Add a new ACL via +, give it a Name and add as many networks as you wish in Network List.


DNSCrypt-Proxy
Installation

First of all, you have to install the dnscrypt-proxy plugin (os-dnscrypt-proxy) from the plugins view reachable via System ‣ Firmware ‣ Plugins.

After a page reload you will get a new menu entry under Services for DNSCrypt-Proxy.

When you start the daemon, it looks for a list of public DNS server from here: https://dnscrypt.info/public-servers

Depending on all settings below the list can be shortened to your choice, like only IPv4, or logging disabled. The fastest two servers will be used for DNS queries.
General Settings

Enable DNSCrypt-Proxy

    Enable and start DNSCrypt-Proxy.
Listen Address

    Here you set the addresses and ports to listen on. Default is localhost and port 5353. If you want it to listen to port 53 you must enable Allow Privileged Ports, especially when the system itself should treat it as a resolver. required when using this service as a standalone core DNS server.
Allow Privileged Ports

    This allows the service to listen on ports below 1024, like 53.
Max Client Connections

    How many clients are allowed to contact the daemon.
Use IPv4 Servers

    Use IPv4 enabled servers.
Use IPv6 Servers

    Only use IPv6 enabled servers.
Use DNSCrypt Servers

    Include resolvers supporting DNSCrypt protocol in the decision process.
Use DNS-over-HTTPS Servers

    Include resolvers supporting DNS-over-HTTPS in the decision process.
Require DNSSEC

    Only use resolvers supporting DNSSEC protocol.
Require NoLog

    Only use resolvers with disabled loggong.
Require NoFilter

    Only use resolvers without filtering. Otherwise requests would also filtered for adult content or ad’s.
Force TCP

    Always use TCP to connect to upstream servers. This can be useful if you need to route everything through Tor, otherwise keep it disabled.
Proxy

    Use this to route all TCP connections to a local Tor node, format has to be like 127.0.0.1:9050
Timeout

    How long a DNS query will wait for a response in milliseconds.
Keepalive

    Keepalive for HTTP (HTTPS, HTTP/2) queries in seconds.
Cert Refresh Delay

    Delay in minutes after which certificates are reloaded.
Ephemeral Keys

    Create a new, unique key for every single DNS query. This may improve privacy but can also have a significant impact on CPU usage.
TLS Disable Session Tickets

    Disable TLS session tickets - increases privacy but also latency.
Fallback Resolver

    This is a normal, non-encrypted DNS resolver, that will be only used for one-shot queries when retrieving the initial resolvers list, and only if the system DNS configuration does not work.
Block IPv6

    Immediately respond to IPv6-related queries with an empty response. This makes things faster when there is no IPv6 WAN connectivity.
Cache

    Enable a DNS cache to reduce latency and outgoing traffic.
Cache Size

    Set the cache size.
Cache Min TTL

    Minimum TTL for cached entries.
Cache Max TTL

    Maximum TTL for cached entries.
Cache Negative Min TTL

    Minimum TTL for negatively cached entries.
Cache Negative Max TTL

    Maximum TTL for negatively cached entries.

Example: Standalone DNS

You can use the DNSCrypt-Proxy as a full-featured standalone DNS instead of Unbound or Dnsmasq. This setup has the advantage that you do not need a forwarder solution for encrypting DNS requests or the usage of DNSBL.

To do so go to Services->Unbound DNS->General and uncheck Enable. If you are using Dnsmasq go to Services->Dnsmasq DNS->Settings and uncheck Enable. Now change to Services->DNSCrypt-Proxy->Configuration and add the Listen Address 0.0.0.0:53 for the service to be considered as standalone by the core system.

Now you can go on with your configuration task, like choosing which servers to use, privacy policy or caching. Also cloaking (overrides) or DNSBL can be used without any workarounds.

Multicast DNS Proxy

If you want to connect multicast DNS of multiple networks, you will need to proxy between them.
Installation

First of all, you have to install the mdns-repeater plugin (os-mdns-repeater) from the plugins view.
../../_images/menu_plugins.png

After a page reload you will get a new menu entry under services for MDNS Repeater. Select it and you will get to the following screen:
../../_images/plugin_mdns_repeater.png
Configuration

Warning

mdns-repeater requires at least 2 interfaces, and no more than 5 interfaces to work.

The configuration is fairly simple. Just enable the service and add the interfaces. For example:

Property
	

Value

Enabled
	

checked

Interfaces
	

LAN, OPT1, OPT2


Dynamic Routing (FRR)

Dynamic Routing (using routing protocols) is supported via an external plugin. Routing protocols support your network equipment in finding the best available path for your packets. We use Free Range Routing (FRR) to implement the various available protocols for dynamic routing.

These routing protocols are used to:

    Improve fault tolerance (if a connection breaks, a new route will be found if possible)

    Simplify administration (you have to add fewer routes manually)

It is not adviseable to use dynamic routing in the following scenario’s:

    When your network is small (so it would be better to use static routes)

    If you are working in a highly isolated environment, where you have to be in control of everything happening in your network

Routing Protocols supported by the plugin include:

    RIPv1 and RIPv2

    OSPFv2 and v3

    BGPv4

Warning

Not all routing protocols will work in any setup because they may have to be direct neighbors. Consider the limitations of a routing protocol before using it.

Warning

It’s strongly advised to increase the kern.ipc.maxsockbuf value via Tunables. Go to System ‣ Settings ‣ Tunables and check if there is already a tunable for maxsockbuf and set it to 16777216 if it’s lower. Otherwise add a new one with name above and the specified value.

Warning

Disabling a running routing daemon can be dangerous as it can lead to an inaccessible machine. If you want to disable a running routing daemon, make sure, you don’t lose routes which are required by your connection to this machine (for example when using SSH).
Installation

First of all, select Plugins in the menu:
../_images/menu_plugins.png

On this page, you can install the FRR plugin by clicking the + icon:
../_images/plugins_frr.png
General setup

In order to use one or more of the protocols included, one has to enable the plugin in Routing ‣ General. Without any other service enabled this makes sure the zebra service is being configured, which is the coordinating master service which handles generic features such as logging and acccess to kernel routing.

Tip

By default logging should be enabled, which sends messages to the local logging and offers remote logging over syslog. Always make sure to choose a sensible log level (default is Notifications) and check the log in Routing ‣ Diagnostics -> Log

Note

Since OPNsense doesn’t support a form of configuration reloading at the moment, there might be a temporary loss of service when saving settings. Normally this is only a small glitch, but in high traffic areas it might something to take under consideration when performing maintenance.
Dynamic routing and high availability

In enterprise networks there’s often a need to make sure services are protected for all sorts of failures, dynamic routing helps a lot in this case to provide a proper path for packets to travel, but these nodes themselved might need to be configured more resilient to prevent single points of failures on the edges of your network.

In OPNsense high availability and failover is organised around carp, which makes it a logical choice to combine both technologies here as well.

A couple of different strategies are supported to combine both technologies, ranging from disable the daemon when in carp mode to more fine grained control of how routes are propogated when a machine is in backup mode.
CARP failover mode

The most simple mode available, when a mode reaches backup state, it will shutdown the services, when it’s going to master it will start them all.

Note

Due to the nature of this option, it can’t be combined with other carp options available.
OSPF[6]: CARP demote

This option registers a status monitor on top of the FRR logging feed to detect changes in link status, when OSPF can’t find its neighbors it will make this machine less attractive by increasing the demotion factor.

The feature is inspired by OpenBSD’s handling of carp demotion in ospfd (https://man.openbsd.org/ospfd.conf.5) and can be enabled using the CARP demote checkbox in Routing: OSPF[v3].

Note

Since the relevant neighbor negotiation messages are only being logged when the log level (in Routing ‣ General) is configured to debug, the log will be more loud when using this feature. When using a lower log level the status monitor is not expected to catch any relevant events.
OSPF[6]: Influence interface cost based on CARP status

FRR natively does not support interaction with carp status as the variant in openbsd does (carp note in “depend on” keyword https://man.openbsd.org/ospfd.conf.5), this is where our next option comes into play.

Using the interface settings of an OSPF interface you can choose to adjust costs for that interface based on the carp status of the selected virtual address. Go to Routing ‣ OSPF[v3] -> Interface and choose an interface, here you will find the following options that influence behaviour:

    Depend on (carp)

        Select a virtual address that this interface relies on. When this target is not in MASTER mode, the selected interface is considered demoted

    Cost (when demoted)

        Adjust the cost to this value when going to demoted state, usually one would use a high value here to prefer other routes first

    Cost

        The standard cost, when provided will be used when in normal conditions. If it’s left blank FRR defaults will be used, which it will also rollback to when going back to master mode.

How To

    Dynamic Routing: How To
    Dynamic Routing: Configuration: OSPFv2
    Dynamic Routing: Configuration: RIP


Dynamic Routing: How To

Note

To keep this tutorial short, a configuration is only added a single time. For example, the configuration of Site A and Site B are identical beside one octet in the IP addresses. Also both routers have the same configuration except the Network address of the uplink and the client network.
Situation
../../_images/dynamic_routes_howto.png

We have two sites (Site A and Site B) which are connected via a layer 2 VPN. Each site has two additional routers, which are connected to the edge router and with each oder. On those routers, the clients are attached.
Configuration

In this setup, OSPF is used. All routers belong to the area 0.0.0.0 and no prefix lists are used.
Core Router of Site A

General Settings:

Setting
	

Value

Enable
	

Checked

Advertise Default Gateway
	

Checked

Passive Interfaces
	

Empty

Route Redistribution
	

Empty

Networks:

Network
	

Network Mask

192.168.0.0
	

30

192.168.1.0
	

30

192.168.1.4
	

30
Left Floor Router of Site A

General Settings:

Setting
	

Value

Enable
	

Checked

Advertise Default Gateway
	

Unchecked

Passive Interfaces
	

Interface name of 10.1.1.0

Route Redistribution
	

Empty

Networks:

Network
	

Network Mask

10.1.1.0
	

24

192.168.1.4
	

30

192.168.1.8
	

30


Dynamic Routing: Configuration: OSPFv2
General

Warning

Saving the settings will apply them and reload the daemon. This means you may lose the connection to your firewall for some seconds.
../../_images/dynamic_routes_ospf_general.png
Enable

Enables the OSPF routing daemon. If this does not work, please check the settings of General. Check this checkbox if you want to use OSPFv2 in your network.
Passive Interfaces

Passive Interfaces are interfaces, which exist in OSPFv2 but where no routing updates should be sent to. These are usually the Interfaces, where your clients are connected to and no router should exist. You don‘t need to add interfaces here, where no network is specified.
Route Redistribution

Route Redistribution is used, if you want to send information this router has learned via another protocol or routes from kernel (OPNsense static routes).
Advertise Default Gateway

Advertise Default Gateway should be checked, if this machine has a default gateway to the internet. Always Advertise means, that this route should be also broadcasted, if it is not available. Be careful with this option in HA setups.
Networks
../../_images/dynamic_routes_ospf_networks.png

Networks gives you a brief overview of the configured networks. The dialog looks like this:
../../_images/dynamic_routes_ospf_network_dialog.png
Enabled

Enabled means that this Network is going to be used. You should only disable networks if you plan to do some changes in your topology or some routes get broken.
Network Address

The Network Address of a local interface on which OSPFv2 should be enabled.
Network Mask

A CIDR Mask for the Network Address. For example, if your LAN IP is 192.168.0.1/24, the network address is 192.168.0.0 and Network Mask is 24.
Area

The area describes which routers belong to the same group (autonomous system). This value is a 32 bit integer, which is entered in dotted decimal notation (like an IPv4 address is usually written).
Prefix-List in and Out

Only used for advanced route filtering using access lists.
Interfaces

This tab shows an overview of the configured interfaces:
../../_images/dynamic_routes_ospf_interfaces.png

Note

Changes in this view do NOT apply the settings.

If you add or edit an entry, you will get this dialog:
../../_images/dynamic_routes_ospf_interface_dialog.png
Interface

Choose a single interface, where this interface settings apply to.
Authentication Type and Authentication Key

This values can be set, but they are not used as there is no area configuration which would make use of them. You may want to set the password here if you add a custom area setting via vtysh.
Cost

A numeric value to set the cost on an interface. The cost is used to calculate the route to the target. A bigger value here means, the route is less likely used.
Hello and Dead Interval

Hello interval is the interval in which hello packets (detection of other OSPF routers) are sent out. A bigger value means sower detection but less load on the interface. Dead Interval is the time window, in which the router has to receive a hello packet from another router. If it does not, it is removed.
Priority

This field specifies the router priority which means a router with a good priority is more probably the designated router. Network type usually does not need to be set.


Dynamic Routing: Configuration: RIP

Note

RIP should not be used in larger networks due to the limited hop count. Cosider using OSPF in such cases.

Warning

Saving the settings will apply them and reload the daemon. This means you may lose the connection to your firewall for some seconds.

RIP is a well known distance vector protocol. It may be preferred to be used in smaller networks, where the topology is not too complex and the possibillity of loops is small.
../../_images/dynamic_routes_rip.png
Enable

enables the routing protocol if the support of routing protocols is enabled in general. If you check this box, RIP will be enabled.
Version

Enter 1 or 2 here. 1 is “classful” which means, that this routing protocol does not support variable length routing. If you choose version 2, variable length subnet masks are supported. In most cases, you want to choose version 2 here.
Passive Interfaces

Interfaces, which are known by the routing daemon, but no updates are sent. You should add interfaces with networks here, which do not have any other routers.
Route Redistribution

Also send routes from other sources to neighbors (if desired).
Networks

Add the networks here which should be known by the router and which are subject to be sent to the neighbors. Passive interfaces will not be used to look for another router.


Tor Configuration

Note

Saving changes in modal dialogs does not apply the settings. To apply them, you have to click the “Reload Service” button.
Installation

First of all, install the tor plugin (os-tor) from the plugins view.
../../_images/menu_plugins.png

After a page reload you will get a new menu entry under services for Tor. Open the menu and choose “Configuration” to configure the plugin.
General Settings

This section controls how Tor behaves in general as well as forward proxying.
Global Settings
../../_images/tor_general.png
Tor Service Settings

Enable

    Controls if the service should be running. If it is enabled, it will also be enabled at boot time.
Control Port

    The control port is used for control communication with the Tor daemon. This Port requires a password, which will not be disclosed to the GUI but can be queried via the API. This setting is available for you to handle Port conflicts, so you can change this port.
Create a logfile, Send log messges to syslog

    Enable this checkbox if you want some logging. Please note that a detailed log may lead to privacy issues.
Logfile, Syslog level

    If the corresponding checkbox is enabled, this will be the minimum severity for sending or writing log messges.
Fascist Mode

    If internet access is filtered, you can try this option. Please note that this is not compatible with other features like “Hidden Services”.
Fascist Firewall Ports

    These are the unfiltered ports of the firewall. The defaults of 80 and 443 are choosen, because they are commonly open.

Forward Proxy

Note

The SOCKS proxy is only useable from localhost (127.0.0.1 and ::1) unless an ACL is added in the “SOCKS Proxy ACL” section.

Listen Interfaces

    Add one or multiple interfaces, on which Tor should listen additionally to the loopback interface. This is required if you want to use Tor from other computers than the appliance itself. Tor will bind on the statically configured IP address from your interface configuration. If the interface has no static IP configured, it will be ignored.
SOCKS Port Number

    The port which should be used for the SOCKS server.

Transparent Forward Proxy

Transparent Port

    This port is the target for your NAT rule. Please create a rule for this port in the “Port Forward” section of the firewall.
Transparent DNS Port

    If you are using Tor transparently, you can resolve .onion addresses to IPs of the given pool for example. This also allows to keep DNS secret.
Transparent IP Pool

    This is used to provide an IP pool to Tor, which can be used for host mapping. This needs to be a /16 network at minimum.
Map Host To IP Pool

    This option will assign IP addresses to resolved .onion domains by the Tor DNS service. Checking this box is recommend but a transparent IP pool is required

SOCKS ACL

Warning

If untrusted devices have access to the SOCKS proxy, private information may be leaked. Please be careful with the networks you allow here.
../../_images/tor_socks_acl.png

In this example, you can see that all Hosts of the 192.168.0.0/16 network have access to the Tor Proxy. By default, connections are forbidden.

Creating a new entry is quite easy. Just click the + and fill out the form:
../../_images/tor_socks_acl_edit.png

Enable

    The entry will be added to the configuration file. If this checkbox is unckecked, the entry is ignored.
Protocol

    Select the protocol in use for this ACL. You can choose between IPv4 and IPv6. By default, IPv6 is selected.
Network

    In this field, you have to add the network, on which this ACL should be applied in CIDR notation.
Action

    Select if the traffic should be accepted or rejected.

Hidden Services

A hidden service is an open TCP port, which is hosted in the Tor network and therefore the origin of the service is hard to trace. For example, you can host a website in Tor by running a webserver in your network and forwarding a hidden service port to this webserver.

Warning

This does not work with every protocol as there are protocols which open arbitrary ports. An example for that is FTP. You may work around this issue by limiting the usable ports of such services (for example 10 ports) and forward those to the server.

If you want to host a hidden service, you need to open the hidden service tab and click the + button.
../../_images/tor_hidden_services.png

The following dialog will open and you can enter a name.
../../_images/tor_hidden_services_edit.png

You are allowed to add any alphanumeric name here. For example, you can call your service sampleservice.

Click “Save changes” and your service is saved to the configuration file but not saved to the Tor configuration file.

Switch to the “Hidden Service Routing” tab:
../../_images/tor_hidden_services_routing.png

For any port you want to forward, you have to click + and fill out the form:
../../_images/tor_hidden_services_route_edit.png

Hidden Service

    The service on which the port forward applies. The entries in this list are the services created in the previous step.
Port

    The virtual Port in the Tor network.
Target Host

    The host, on which the real service is running.
Target Port

    The real port of the service. Please note that this does not need to match the Port field but some services may act strange on mismatch.

The sample in the screenshot would forward traffic from the virtual host in the Tor network it gets on port 80 to 127.0.0.1:8080

Warning

When using local connections like 127.0.0.1 or ::1, your application may think this connection is trusted (localhost is not from the internet). Be careful when forwarding traffic to localhost.

In addition to regular onion services, the services can be protected even more by requireing the client to know a secret cookie.

This setting needs to be configured on both ends. On the server hosting the onion service, you need to configure it on the configuration tab for the onion service.

For example, if you want to have a stealth service (undetectable without knowing the key), you can configure it like the following:
../../_images/tor_hidden_services_edit_very_hidden.png

Authorization Type

    Can be Stealth or Basic. Basic means that multiple clients can use the entry point and it is still visible but unauthorized hosts can not connect.
Authorized Clients

    You can choose some names for your clients. Each client gets a authorization cookie assigned so they can connect to it. If you set this value, this onion service will not be available to the public anymore.

Now as this service will need to be configured to the client side as well, you will need to add the secret to the configuration page. To configure a authorization cookie for a service, you can open the Onion Service Authentication tab and fill out the form like on the screenshot:
../../_images/tor_hidden_servicesvery_hidden_credentials.png

You need to configure the hostname and the authorization cookie you will get.

Host Name

    Enter the .onion address of the onion service.
Authentication Cookie

    This is the authentication code you will get from the maintainer of the onion service. Enter it into this field.

When you are done, save the settings and reload the service. After that, you should be able to reach the service.
Relays

A Tor relay is a host which forwards traffic for other Tor nodes. A relay that allows traffic to pass outside of the Tor network is called an “Exit Node”. If the relay is configured only for you (not for public access), it is called a bridge. Bridges are used to circumvent filtering of public entry nodes based on IP/Port basis as the existence of bridges is usually unknown.
Relays And Bridges
../../_images/tor_relay.png

Note

To be a relay, your host must have a public available port. With relaying, you will increase the anonymity of Tor and it is less risky than an exit node.

Enable

    Enable this checkbox if you want to relay traffic (forward foreign traffic).
Host

    This is the host to bind the relay port to. This can be the public IP address. This setting is optional and may be omitted.
Port

    This is the public port used. Do not forget to add a firewall rule to pass traffic to this port. Otherwise it will not work.
Address

    You can enter the FQDN or the WAN IP of this Firewall.
Nickname

    A nickname can be used to identify your network but it must only consist of alphanumeric characters.
Bandwith Rate

    You can limit the bandwith Tor will use. By default, Tor will use the maximum amount of bandwith available. The value must be at least 72 kilobits per second.
Bandwith Burst

    See Bandwith Rate.
Directory Port

    If you have a lot of bandwith, you can also configure a directory port. You should not enable this port if your bandwith is small.
Reject Private IPs

    IMPORTANT DO NOT DISABLE UNLESS YOU KNOW WHAT YOU ARE DOING. This option blocks access to RFC1918 addresses regardless of the configured policy. If you disable this option, somebody can invade your network.
Bridge

    Enable this setting, if you want to be a bridge.
Publish Server Descriptor

    If this is disabled, Tor will not publish descriptors. If you don’t want to be in a directory (for example for testing reasons), uncheck this option.

Exit Nodes

Warning

Providing an exit node can lead to legal issues. It may be a good idea to consult a lawyer before setting up one as you might be made responsible for traffic, which originates from a malicious Tor user.

If you have relaying enabled, you can also become an exit node. To allow outgoing connections, you have to open to the “Exit Node ACL” tab.
../../_images/tor_exit.png

Click on + to add a new ACL.
../../_images/tor_exit_acl_entry.png

Enable

    If it is checked, the ACL will be used by Tor, otherwise the line is ignored.
Protocol

    Select the protocol, on which this ACL applies. You can select IPv4 and IPv6 here. IPv6 is the default.
Network

    You can enter a target network in CIDR notation or an IP address here. If no IP is given, any IP will match.
Start Port, End Port

    This match is the target port of a connection. You can provide only a start port if you want to match a single port. If you provide both, a port range will be used.
Action

    If you select “Reject”, no exit node traffic will be sent to this host and it will not be forwarded. If you choose “Accept”, your host may be choosen as an exit node in a circuit.


Tayga NAT64 how-to
Introduction

IPv6-only networks are less complex to plan, configure, maintain and troubleshoot than dual-stack networks. But many services on the Internet are still IPv4-only. NAT64 preserves access to these services by performing IPv6-to-IPv4 translation. The NAT64 implementation currently available for OPNsense is the Tayga plugin.

Note

This how-to focuses on providing IPv6-only LANs with access to IPv4-only services. However, this is not the only use case for NAT64.
Prerequisites

OPNsense should be configured with working dual-stack Internet access and at least one IPv6-only LAN.
Installing and configuring Tayga

Go to System ‣ Firmware ‣ Plugins and install the os-tayga plugin. Then go to Services ‣ Tayga.

Tick Enable and configure all prefixes and addresses:

IPv6 Prefix

    The IPv6 prefix which Tayga uses to translate IPv4 addresses. You can use the default well-known prefix 64:ff9b::/96 or an unused /96 from your site’s GUA prefix.

    Warning

    When using the well-known prefix 64:ff9b::/96, Tayga will prohibit IPv6 hosts from contacting IPv4 hosts that have private (RFC1918) addresses. This is not relevant when using NAT64 for accessing IPv4 services on the Internet. However, if access to local services with private IPv4 addresses is required, a GUA /96 prefix must be used.

    Note

    While technically possible, using a ULA prefix for NAT64 is not recommended. This can cause issues with certain hosts, especially those which support 464XLAT.
IPv4 Pool

    The virtual IPv4 addresses which Tayga maps to LAN IPv6 addresses. Can be left to its default value unless this overlaps with existing subnets in your network. Must be sufficiently large to fit all devices in your IPv6-only LAN(s).

Tayga is a hop in the path, so it needs its own IP addresses for ICMP:

IPv4 Address

    Will show up in traceroutes from the IPv4 side to the IPv6 side. Can be left to its default value unless you changed the IPv4 Pool. Should be located in the IPv4 Pool subnet.
IPv6 Address

    Will show up in traceroutes from the IPv6 side to the IPv4 side. Can be left empty if the IPv6 Prefix is a GUA or the IPv4 Address is a non-RFC1918 address. Tayga will then auto-generate its IPv6 address by mapping the IPv4 Address into the IPv6 Prefix. For example, if the IPv6 Prefix 2001:db8:64:64::/96 and IPv4 Address 192.168.255.1 are being used, Tayga’s IPv6 address will be 2001:db8:64:64::192.168.255.1 (2001:db8:64:64::c0a8:ff01).

    Warning

    Tayga can’t auto-generate its IPv6 Address if the default well-known IPv6 Prefix 64:ff9b::/96 and a private (RFC1918) IPv4 Address are being used. In this case, you have to manually specify an unused address from your site’s GUA or ULA prefix.

Tayga behaves like an external device connected to OPNsense via a point-to-point interface. This interface requires IP addresses for ICMP:

IPv4 NAT64 Interface Address

    Can be left to its default value unless this conflicts with your network. Must not be located in the IPv4 Pool subnet and must not be used by another interface or VIP.
IPv6 NAT64 Interface Address

    Must not be located in the IPv6 Prefix subnet and must not be used by another interface or VIP.

    Warning

    The default value must not be used since 2001:db8::/32 is a documentation-only prefix.

Save. Tayga should now be running.
Adding firewall rules

Tayga uses a tunnel interface for packet exchange with the system. Rules are required to prevent the firewall from blocking these packets. Additionally, an outbound NAT rule is required for IPv4 Internet access.

Go to Firewall ‣ Rules ‣ Tayga, add a new rule, set the TCP/IP Version to IPv4+IPv6, leave all other settings to their default values and save.

Note

If you just enabled Tayga and can’t find Firewall ‣ Rules ‣ Tayga, go to Interfaces ‣ Assignments, click Save and reload the page.

Go to Firewall ‣ Settings ‣ Normalization, add a new rule, set the Interface to Tayga, leave all other settings to their default values and save.

Note

This rule is required for proper handling of fragmented packets.

Go to Firewall ‣ NAT ‣ Outbound, add a new rule, set Source address to Single host or network, enter your Tayga IPv4 Pool, leave all other settings to their default values and save.

Apply the firewall changes. NAT64 should now be fully operational.
Configuring DNS64

In most scenarios, NAT64 also requires DNS64. If you use OPNsense’s Unbound DNS DNS resolver, DNS64 can be enabled by going to Services ‣ Unbound DNS ‣ General and ticking Enable DNS64 Support. If you don’t use the default 64:ff9b::/96 prefix, you also have to enter your /96 prefix there.

Note

You may also use any other DNS64 capable DNS server. If you use the default 64:ff9b::/96 prefix, using a service like Google’s Public DNS64 <https://developers.google.com/speed/public-dns/docs/dns64> is possible, too.
Testing

You can use a service like https://internet.nl/connection/ to verify that devices in your IPv6-only LAN have IPv6 and IP4 Internet access.


Reverse Proxy and Webserver

Note

All reverse proxies are plugins and need to be installed first.
Why should a reverse proxy be used?

The packet filter itself cannot decide what should be done in application protocols. For such an inspection you can use deep packet inspection or a reverse proxy.

In addition, a reverse proxy can implement protocol specific access control lists as well as other checks to protect the application behind. Such checks are malware, spam, web attack detection and so on.

Warning

Reverse proxies could prevent common attacks to your web application by bots but would never provide a 100% success rate when detecting bad traffic. Especially a targeted attack would very likely not be detected, because a lot of effort has been taken to prevent detection. Do not use a reverse proxy as a replacement / excuse for not fixing the main problems like known vulnerabilities in libraries, outdated software, or vulnerabilities in your own code.
Supported Reverse Proxies in OPNsense

ftp-proxy
	

Makes FTP work

nginx
	

HTTP, TCP- and UDP streams

HAProxy
	

HTTP and TCP streams

Caddy
	

HTTP, TCP- and UDP streams

postfix
	

SMTP (e-mail)

relayd
	

TCP streams
Terms

Forward Proxy

A Proxy which is used by a client to connect to the internet. It is usually used in companies to scan traffic for malware. See the more specific pages (Caching Proxy) for more background information.

Reverse Proxy and Webserver

A reverse proxy is software which takes a request or a connection from a client and sends it to an upstream server. It may change some data if needed (for example inject HTTP header or perform access control). A reverse proxy can be generic for any protocol, but is commonly used for HTTP(S).

A reverse proxy does not need to by fully aware of data it is transferring, it only needs to decide which upstream is responsible to process it and some metadata to know what it should do (like for caching a Cache-Control header and for authorizing an Authentication header in HTTP).

A webserver - in contrast to a reverse proxy - processes the request (the webserver contains the business logic in the web application) and sends a response depending on the request, which may be modified or cached by a reverse proxy (for example Varnish, nginx) or forward proxy (see Setup Anti Virus Protection, Setup Caching Proxy). For example, a webserver serves a file called index.html from the local file system or processes an API endpoint and returns the result. A web server usually has an API for calling external interpreters:

API
	

Typical Use Case
	

Implemented at (examples)

FastCGI
	

PHP, Rails
	

PHP-FPM, nginx, Apache HTTPd

AJP
	

Java application servers
	

Tomcat, JBoss, WildFly, Apache HTTPd (mod_jk)

(U)WSGI
	

Python
	

Django via UWSGI

Others include the interpreter directly into the webserver, are written in this language or in a C/C++ extension:

Technology
	

Used for

Passenger
	

Application Server for differnet Languages

nginx Unit
	

Application Server for differnet Languages

Undertow (Raw, JBoss, WildFly)
	

Java application server

Apache Tomcat
	

Java application server

unit, puma, unicorn
	

Many Rack based frameworks (RoR, Sinatrarb, …)

gunicorn
	

Python application server

Apache HTTPd (with modules like mod_php)
	

Webserver with interpreter modules

Upstream, Backend

A single or multiple servers which can be used for load balancing the client requests. All servers used in an upstream must act equally (same protocol etc.) but do not need to run on the same port.

Upstream Server, Backend Server

This is your listening application like nginx on port 80 for HTTP or your LDAP server on TCP/389.

Frontends (HAProxy) and HTTP(S)/Stream Servers (nginx)

These are the the configurations for the ports used for incoming connections. For example, if you bind a port to TCP/80 (standard port of HTTP), you can decide, what is going to be done with this request. The same is true for connections.

TLS and SSL

TLS replaced SSL and it is used to protect the application protocol against a broad range of attacks like snooping or data manipulation (for example ad injection, redirects, manipulation of downloaded files like executables).

Modern clients and servers should support TLS 1.2 and TLS 1.3. All others should be disabled.
TLS - Different ways to use it
1. Breaking up the connection on the firewall (down- and upstream are using TLS)

In this setup we do have two TLS protected connections. One from the client to the firewall, and one from the firewall to the backend.

The advantage of this setup is that you can use it to route based on paths or other properties and you can present another certificate to the client. For example, you can use an internal certificate on the server and the reverse proxy will present a probably trusted certificate like one of Let’s Encrypt to the client. This simplifies certificate handling because the upstream client may be invalid (for example outdated). Please note that it is not recommended to disable certificate checks in the upstream but it may be required in some setups.
2. Decrypt an encrypted upstream (downstream plain, upstream TLS protected)

This setup may not make much sense in most cases. It may have the advantage if you have trouble with some software which does not allow a not encrypted port but a special internal client does not support it. For example a machine needs to talk to a server but cannot use TLS because the hardware does not support it. If you need that, do not make it available via the internet because there is probably a reason that the upstream server is TLS only.
3. TLS Offloading (downstream is TLS protected, upstream is plain)

This setup should be preferred when it is supported. It has the advantage that it fully supports TLS for the client while it does not need a lot of power to do a TLS handshake inside your own computer centre.

Warning

You should not use this for upstream servers reachable via untrusted networks. Use (1) or (4) in such cases.
4. TLS Passthough

In this mode, the proxy will just pass though the connection and has no access to the encrypted payload. You cannot match on anything of the protocol itself. You may use some extension headers like SNI to decide, which upstream is used. This setup is recommended if you only want some improved routing decisions better than plain NAT.

Note

A reverse proxy can still get access to the encrypted content if it has the private Key of the server and a cipher without PFS is used. In other cases the connection can only be decrypted if one of the peers escrows the key. Firefox supports this via the environment SSLKEYLOGFILE. This is not supported by OPNsense plugins.
Tutorials

    nginx: Basic Load Balancing

    Caddy: Reverse Proxy


Anti Virus Engine
../_images/eye_on_virus_new.jpg

OPNsense offers the industry standard ICAP to protect HTTP and HTTPS connections against ransomware, trojans, viruses and other malware .

OPNsense offers a ClamAV plugin, which can be used with the C-ICAP plugin or relies on third party engines from well known vendors, such as Symantec’s Protection Engine.
Setup ICAP Anti Virus Engine

    Setup Anti Virus Protection

    Setup Anti Virus Protection using OPNsense Plugins


c-icap
Installation

First of all, you have to install the c-icap plugin (os-cicap) from the plugins view.
../../_images/menu_plugins.png

After a page reload you will get a new menu entry under services for C-ICAP. Select it and you will get to the following screen:
../../_images/c-icap_settings.png
General Settings

Enable c-icap service

    Enable the C-ICAP service to handle ICAP requests.
Timeout

    The time after which the socket will be closed.
Max keepalive timeout

    The time after which the socket will be closed if it stays inactive.
Start servers

    The count of the server processes which will be spawned.
Max servers

    Limit the count of processes
Listen address

    The address in which the server should be bound. This address is usually the loopback address (::1 for IPv6 or 127.0.0.1 for IPv4). The default value is ::1.
Server admin

    This field should be set to an email address which acts as a contact for users, who are having issues with the server. A good idea would be an address, which converts the mails to your internal ticket system.
Servername

    If you want to override the server name (displayed on error pages), you can enter it here.

Antivirus
../../_images/c-icap_av.png

Enable ClamAV

    Enables the virus -scan plugin of c-icap-modules using ClamAV
Scan for filetypes

    The type of files which should be analyzed. You should scan as many file types as possible but keep in mind that scanning requires resources which have to be available.
Send percentage data

    Amount of Data of the original file which should be included in the preview. More Data will have better scanning results and is better for security while a lower value improves performance.
Allow 204 response

    A 204 response has the advantage, that the data don’t have to be sent over the wire again. In case of a preview, no more data will be sent to the ICAP server and the data will be forwarded to the client. In case of all data has been received by the ICAP server, the data does not need to be sent back. Please note, that the ICAP client has to support 204 responses.
Pass on error

    In case the scan fails, the file can be passed through. This is less secure but keeps the business running in case of failure. Keep in mind that this may put your network at risk.


ClamAV

The ClamAV plugin can be used with other plugins, like c-icap and rspamd, to scan for viruses.

Warning

Your machine needs at least 1.5 GB RAM. Otherwise the machine will run out of memory and crash because of out of memory kills. Using a machine with at least 2 GB RAM is recommended.

Warning

There are some techniques to avoid detection and scanning using AV software and not every malware is known by AV products. Signature based AV software can decrease the risk of getting hit by a known malware but it does never guarantee that your computers don’t get infected. It is important to teach the users how to handle files from the internet and untrusted devices safely. Also plan a regular Backup of important files, make sure, that ACLs are used correctly and apply patches asap to keep the attack surface and damage as small as possible.

Note

To make ClamAV working, you need to download signatures. Please note that those files need to be fetched after a reboot again if they are stored on a ram disk.
Installation

First of all, you have to install the ClamAV plugin (os-clamav) from the plugins view.
../../_images/menu_plugins.png

After a page reload you will get a new menu entry under services for ClamAV. Select it and you will get to the following screen:
../../_images/clamav_settings.png
Configuration Options

Enable clamd service

    Selecting this checkbox enables clamd so you can use it to scan files.
Enable freshclam service

    Freshclam is a service to update your malware signatures. If you use ClamAV, it is recommended to update the signatures on a regular basis.
Enable TCP Port

    This checkbox needs to be checked, if you want to use clamd over the network or for local services, which use a TCP connection.
Maximum number of threads running

    Thread limit is used to avoid a denial of service of the daemon and your machine. Usually a number next or equal to the number of cores would be good.
Maximum number of queued items

    This is the maximum of files which can be in the queued for scanning. The reason is the same as for the threads.
Idle Timeout

    The connection will be dropped if it is inactive for this amount of time. If the other socket endpoint is a machine, this value can be low but if you plan to use it for develpoment reasons, you may set it to a higher value.
Max directory recursion

    Limit the depth of the directory tree. In the worst case there is a loop which causes the scanner to run endlessly and this setting should prevent it.
Follow directory symlinks

    If this is checked, clamav will follow directory symlinks which may lead to a loop. If you want to check this, make sure the recursion limit is set to a useful value.
Follow regular file symlinks

    If this is checked, clamav will follow symlinks to regular files. This may expose information about the filesystem, the user should not have access to.
Disable cache

    If you check this, the results are not cached. This is only useful in develpoment environments as it slows down the response time.
Scan portable executable

    Check this box, if you want to scan PE files. If you are using PE-files (*.exe, *.dll etc.) files in your network, checking this box is recommended.
Scan executeable and linking format

    Check this box, if you want to scan ELF-files. ELF is for example used on Linux based operating systems and on *BSD.
Detect broken executables

    This setting will mark an executable as broken if it does not match the spec. A executable may be broken because of a download issue or manipulation. In any case, there should not be any legit case to pass a broken executable.
Scan OLE2

    If this is checked, OLE2 files (for example Microsoft Office files) will be analyzed. Such files should be analyzed as they may contain macros which have been used to download and install malware (usually ransomware).
OLE2 block macros

    Check this box, if documents containing macros should be blocked. If you don’t use macros and you don’t expect them from your business partners or friends, this setting is recommended.
Scan PDF files

    If this checkbox is checked, PDF files will be scanned. PDF files can carry other files or multimedia as well as javascript and fonts. Scanning PDF files is recommended.
Scan SWF

    If you check this box, Flash files will be scanned. Flash is used to provide video players or interactive content. Nowadays it should have been replaced by HTML5.
Scan XMLDOCS

    Scan XML Documents
Scan HWP3

    HWP seems to be a korean document format. If you don’t use them, it is better to block them in the proxy than scanning them. If you have them in use, you should scan them.
Decode mail files

    If you select this option, the sections of emails will be read and therefore it will be possible to scan email attachments. Mail attachments are important to scan as an attached file may contain malware. For example, some malware campaigns used a JScript file which has been packed in a ZIP file which was attached to an email.
Scan HTML

    Scans HTML files which may have dangerous embedded JavaScript.
Scan archives

    Scan files inside archives. This is very important as archives can contain malware. Please note that archive nesting is used to bypass scans, so scanners detect such archives as dangerous at a specific recursion level. Also keep in mind that zip bombs may be possible to DoS a scanner.
Block encrypted archive

    Encrypted archives are usually used to transfer files encrypted which don’t support encryption on their own or the sender is not aware how to encrypt those files. A tool like 7z can derive a key from a password given by the creator of the file, which will be used to encrypt the compressed data. The ClamAV cannot scan this data as it is missing the key/password. Some malware authors used encrypted archives to avoid scanning and told the victim in the email text how to unpack it.


nginx: Basic Load Balancing
1) Create Upstream Servers
../../_images/nginx_upstream_servers.png ../../_images/nginx_edit_upstream_dialog.png

Create a server with a description and IP of the server. The priority is not important if you have a single server. It is used as a weight for round robin. Servers with a higher weight will receive more traffic.
2) Create An Upstream
../../_images/nginx_edit_upstream_with_verify.png

Group upstream servers to an upstream. An upstream is a group of servers to load balance between. Give it a useful name and choose the previously created server.

Warning

Upstream verification is enabled by default (TLS: Verify Certificate checkbox). Server names in the upstream certificate are compared with the name in the TLS: Servername override field. For successful verification, it is necessary that OPNsense trusts the certificate of the certification authority that issued the upstreams certificate. You can further restrict the list of trusted CA’s in the TLS: Trusted Certificate field.
3) Create A Location
../../_images/nginx_edit_location_dialog2.png

Locations are are used to map URLs to upstreams, directories, settings and so on. In our case we want to proxy the request to the previously created upstream. If we want to match everything, we use “/” without a special matcher. Now save the location.
4) Create A HTTP Server
../../_images/nginx_edit_http_server_dialog.png

In the last step, we have to create a port. This happens in a “http” block, which contains some basic configuration and the location blocks.

Enter the domain name into the “Server Name” field and select the previously created location. If you want to use support TLS, you have to add a certificate.
5) Restart nginx
../../_images/nginx_reload.png

Click the reload button and you are done. You may need to open some ports in the firewall if you have not done that yet. Since you are directly on the firewall, There is no need to use NAT similar workaround.


nginx: Header Hardening

Note

Except for some specific configuration directives, this is NOT specific to the nginx plugin. Please note that you can also debug your frontend code this way.
Background Information

HTTP headers can control what a web application is allowed to do and what it is not. This can be used to harden the web application against some client side risks.
Testing Web Applications Using A Local Proxy
Configuration of Firefox

For this tests, you should install and configure FoxyProxy.

After it is installed, click on the proxy settings and add a new one:
../../_images/zap_foxyproxy.png

As a proxy, enter localhost (or 127.0.0.1 in case localhost does not work) and the port 8080. Save the settings.
Downloading A Proxy Software For Testing

Well known Test tools are:

    OWASP ZAP (https://github.com/zaproxy/zaproxy)

    Burp (https://portswigger.net/burp)

    mitmproxy (https://mitmproxy.org/)

When it is downloaded, you usually have to unpack it into a fitting directory.`` When it is unpacked, you need to run it. In case of ZAP, doubleclick the zap.sh or zap.bat depending on your operating system.

Next regenerate and export the certificate under Tools ‣ Options ‣ Dynamic SSL certificates and import it into the Firefox key store (Preferences ‣ Data Protection & Security ‣ Show Certificates) with full trust.
Start Testing

Click on the FoxyProxy icon and select the localhost proxy defined first. Next just use the application as usual. If you click the red button, can stop the request in ZAP and it allows you to edit it:
../../_images/zap_request.png

When you are done, just click one of the play buttons to disable halting or wait for the next request / response to edit that as well. For example the response could look like this one:
../../_images/zap_response.png

You can see a lot of important information here like the used protocol (HTTP/1.1), the status code 200 (which means it was successful) and a lot of headers. Some of those headers impact security and ZAP will try to make a recommendation, which may not be always correct but it may help you to find some (forgotten) issues:
../../_images/zap_warnings.png

The colors of the flags show how high the risk is rated so the redder it is, the more impact it has on security. The left view contains a list of the findings, the right view contains a detailed description of them. Based on this information, you have to decide your further actions.
Testing Web Applications Using Developer Tools

When you right click on the web site, you can inspect the element but the opening tools also have a tab for networking.
../../_images/firefox_devtools_network.png

The network tab works like the main view of the proxy. You can see which headers are sent and which ones are received. The advantage here is that you get some errors on the console tab (for example if the CSP has an error). The disadvantage of the console is, that is is not so easy to intercept and modify data.
Inject Missing Headers Via The nginx Plugin

Security headers in the nginx plugin can be injected by creating a new security header configuration:
../../_images/nginx_security_headers.png

If you set a setting here, it will override what the webserver sets. You can inject this security setting into a location or HTTP server.

You can read about the headers in the Mozilla Wiki or in the RFCs.

Warning

Not all headers are supported by all browsers.

In short, the headers are:

Referrer
	

Control what a page sees when you link on it

XSS Protection
	

Enable or disable the detection for (reflected) XSS

Don’t Sniff Content Type
	

Disable content type detection when the original is incorrect

Strict Transport Security
	

TLS only and enforce valid certificate

HPKP
	

Pin the public key, not widely used and dangerous 1 if misconfigured

Content Security Policy
	

Controls resources and JS functions

1

    If you switch the certificate without announcing its public key first via this header in a rollover time span, you will lock this clients out because they expect being targetted by a MITM attack and refuse the connection and it is hard to reset this pin in the browser.


nginx: Local Website Hosting

Warning

Even if you can host websites directly from OPNsense, it is not recommended for security reasons - especially when sending requests to a local PHP interpreter. Do NOT consider using the feature to serve PHP content locally in enterprise networks. It is intended for home users who want to save money by saving power and know what they are doing. If you do not know how to handle a web server properly, do not enable this feature.
Prepare

First of all, a directory has to be created. For example /srv/web_application1. Please note that this directory must be accessable by nginx and PHP (both running as www).

For example, you can chmod it (+rx for directories, +r for files for this user) or chown it.

# create a directory
mkdir -p /srv/web_application1
cd /srv
stat web_application1
# Example Result:
# 86 18009 drwxr-xr-x 2 root wheel 14050 512 "Aug 31 18:28:19 2018"
#  "Aug 31 18:28:19 2018" "Aug 31 18:28:19 2018" "Aug 31 18:28:19 2018"
#  32768 8 0 web_application1
#
# as you can see, everyone can read (r) and switch into the directory (x))
#
# do this if the directory is not readable or excutable:
chmod +rx web_application1

Warning

Never use chmod 777 and be careful with write permissions. the most secure way is to change the owner to www (chown www filename) and give write permission only to the web server user (chmod o+w filename). The same is valid for directories. It would be a good idea not to execute anything in those directories (for example via a special location block in nginx). If you write your own applications, it is recommended to store such data outside of your web root.

When the directory exists, you can create a file in this directory. Let’s say, it should be called test.php and should show some information about PHP:

cat > /srv/web_application1/test.php
<?php phpinfo();

Press control + d to end the input.

Note

you can also use vim if you install vim-lite via pkg.

# If needed, change the permission to make it readable:
chmod +r test.php

Note

In a real world scenario, you would probably copy an archive (.tar.gz, .tar.xz, .tar.bz or .zip) via SFTP or SCP on the firewall and execute a command to extract it. Read the man pages for tar, the compression tool or unzip for more detailed instructions.
Configure Locations
../../_images/nginx_edit_location_dialog.png

For a location, the following directives are important:

Directive
	

Description

Match Type and URL Pattern
	

How to match the location and the pattern

File System Root
	

Directory of web applicaton

Upstream Servers
	

Send it to a remote interpreter instead of using the local one

Pass Request To PHP Interpreter
	

Check if you want to enable PHP (runs locally as user www) or remotely

Router Script
	

Sends all request to a specific script (entry point of application)

Directive
	

Value

Match Type and URL Pattern
	

~* .*.php or simmilar

File System Root
	

/srv/web_application1

Upstream Servers
	

empty

Pass Request To PHP Interpreter
	

checked

Router Script
	

empty
Configure HTTP Server
../../_images/nginx_edit_http_server_dialog.png

Configuring the HTTP server is simple. You need a hostname (for example website.test), a port (8080/TCP is the HTTP alternative port, so it is good for testing. For production sites you should stick with the defaults). Please select the prevously created location to serve web content. Please also configure a root here, because all requests, which do not match, will be handled by the server default. The default server will just serve the static file.
Testing

To test if you web server is running, you can paste call it by its IP and port.

Note

Please note that IPv6 addresses must be enclosed within square brackets like http://[::1]/ or http://[::1]:8080/.

curl "http://192.168.0.1:8080/test.php"

Security Considerations

    This is nginx and not httpd. It will not care about your .htaccess files. Do not put secret data in unprotected directories. You can protect those directories by yourself, but make sure you don’t forget them. Some application depend on this file.

    Do not overlap nor use OPNsense directories as root

    Do not upload badly maintained software. If your firewall gets compromised, it will become easy to compromise your hosts too.

    All your applications run under the same user (www)

    Watch out for advisories

    Install updates ASAP

    Check your logs regularly.

    Consider hardening your directory and file access permission (like making directories and files read only for nginx and PHP)


nginx: Basic Authentication & Authorization

Warning

Passwords in password files cannot be stored securely. Your passwords are stored in plain text in the configuration and as md5 in the nginx password files. Secure password hashes like bcrypt, scrypt or Argon 2 are currently not supported by nginx.

Please also note that basic authentication transfers the credentials in plain text to the server. It is recommended that you only use it via HTTPS because otherwise every attacker with a network sniffer such as Wireshark (and mabe some additional man in the middle tools like ettercap or fake_router6) will be able to intercept your connection to the server and read your password.
Background Information

Basic authentication encodes the username and the password in Base64 in a HTTP header. Because it is really simple to implement, almost every HTTP client supports it. For this reason, people use it to protect REST interfaces and so on. Also authentication for the OPNsense API supports this kind of authentication.
Configuration
Create Users

Navigate to the “Credential” tab.
../../_images/nginx_user.png

Enter a username and a password and press ok
Create An User List

Navigate to the tab “User List”.
../../_images/nginx_users.png

Select all users, that should have access to a specific resource and give this group a name.
Assign it to a Location

In the last step, the user list must be added to the location.
../../_images/nginx_auth_location.png

As soon as you restart the server, you will need to log in to access the contents of this directory. To do so, you can enter any string in the basic authentication field, which will be sent as an realm. The user list is the list previously created.

Reload the server.
Testing

You can use curl to check if it works. In a browser like Firefox, a dialog asking for credentials should open.

curl -v -u user:password  "http://example.com/restricted/image.png"

Advanced Authentication

The entry advanced authentication is used to call an external authentication provider. In the case of OPNsense, this is currently a special script, which authenticates agains the local database. If you want to use it, do not enter a realm nor select a user list. Please note that this feature may change in the future.


nginx: IP Based Access Control Lists

Warning

Source IPs of UDP may be spoofed because the protocol is connectionless. If there is an attacker who can manipulte your WAN, the attacker can also use any WAN IP which has been whitelisted. It is safer, not to use this as the only protection for your webservices.
Background Information

IP based ACLs can be externally used to allow access (whitelist strategy) to a specific web service only by customers so you can easily get rid of most of the malicious traffic to the application server. This also has some downsides: For example, the site will probably not be visible to search engines and will therefore not be indexed. On the other hand you can also blacklist (blacklist strategy) some bot IPs and some bulletproof hosting ranges.
Configuration
Create Users

Navigate to the Access ‣ IP ACL tab.
../../_images/nginx_ip_acl_01_list_view.png

Click the + button to create a new ACL.
../../_images/nginx_ip_acl_02_create_acl_view.png

Next enter a reasonable title, for example here “Allow Private IPs” was used. Now the different IP addresses or IP ranges can be entered. In this case some common private IP ranges were allowed and the default rule was set to block. A new line can be added by clicking the + icon while the trash can icon deletes the row. This means that this service should be only visible internally.

Warning

Keep in mind that carrier grade NAT (CGN) may cause some trouble with these ACLs too. Please check how your traffic is handled first.
Assign it to a Location, HTTP or Stream-Server

In the last step, the user list must be added to the object, that supports it. At the moment this are the HTTP Server, the Stream Server and the HTTP locations. For example to add the ACL to a location, open it and select the ACL in the dropdown:
../../_images/nginx_ip_acl_03_location.png

After saving the location and restarting nginx, you are done.


nginx: TLS Fingerprints

Warning

This manual page is for advanced users only as the feature is not designed to be used by beginners. Maybe the curves are not provided by the TLS implementation and you get an empty string. If this is the case, it is normal but you should expect trouble if you use them as a later version of the software may implement them and then all your connections will be flagged as intercepted.
Requirements

    To use this feature, you must have an HTTPS server running which writes some logs.

    Different browsers from different operating systems as clients

Analysis Page

The analysis page is grouped into some sections:
../../_images/nginx_fingerprint_list_colors.png

Color
	

Description

Orange
	

User-Agent string (HTTP-Header) - technical description of the client

Red
	

Total count of hits in the log of the UA with this ciphers and curves

Blue
	

Supported Ciphers and Curves in order of the Client hello - our fingerprint

Green
	

If you click this button, you can take the fingerprint over to the configuration

Gray
	

Pie chart of the fingerprints count and the User-Agent (visualized)

The pie chart is important to know if a fingerprint is intercepted because many intercepting software changes the client hello. Let’s take a look at this one:
../../_images/nginx_fingerprint_list.png

There is one small one, which we probably can ignore, so lets look at the other two fingerprints: One contains ciphers, hashes etc., browsers should not support anymore (for example NULL, MD5, …) so this is probably intercepted (it actually is OWASP ZAP 2.7.0) in this screenshot, which is intercepting a connection from Firefox 63. In this case there is onle one big segment left, which is very likely the real browser fingerprint (or another proxy).

In the following example, take a look at the pie chart (especially the segment with the cursor on it):
../../_images/nginx_fingerprint_good_sample.png

The segment has a huge share of the requests with this User-Agent. In such a case it can be either always the same client requesting a resource and probably only few users are using it or, which is more likely if it is a browser, it that it is probably the right fingerprint.

Warning

Some proxies are mirroring the client hello, so they won’t be detected. Also be careful because for example if you have a big customer generating a lot of traffic, a big segment of the pie chart (even the biggest one), may be intercepted.

For security reasons you should also take the absolute count into account when you are working on a real world sample and that software may be compiled width different which may also replace the crypto library which also means that it will have a different fingerprint.

If you click on the store button, a dialog will open and you can create a new entry in your configuration, which will be visible on the configuration page.

For example, our fingerprint could be imported into the configuration like shown in the following screenshot:
../../_images/nginx_fingerprint_export.png
Configuration Page

Now in the configuration page under HTTP ‣ TLS Fingerprints there will be an entry for the created fingerprint, so it can be edited:
../../_images/nginx_fingerprint_settings.png
Trusted Fingerprints

A trusted fingerprint is a fingerprint, which will be used to detect man in the middle attacks by comparing the client hello of the fingerprint with the data sent by the client. If there are additional ciphers or curves, you will get this information via an HTTP header into your application. Please note that you can have only one fingerprint per User-Agent.


nginx: TLS Authentication & Authorization

Warning

Even if this is probably the most secure way to authenticate, a lot of clients do not support it. In addition, configuring client certificates can also be hard to do for users.

This authentication mechanism is recommended for machine to machine communication and experienced users.
Background Information

TLS authentication happens when the HTTPS connection is set up and for this reason you can not configure it per directory (this information has not been received yet). If you want to use this authentication type in a custom application, the nginx plugin configures nginx to send you the required information like the CN).
Configuration

First of all, you need a CA, a client and a server certificate.

Please create it like described in Setup SSL VPN Road Warrior. If you want, that your VPN users can log into your application using the same certificate, you may use the same CA.
../../_images/nginx_auth_tls.png

Next, choose the CA, the certificate and choose on as for client validation. This will reject any connection by a client, who has no valid certificate.
Testing

curl https://192.168.1.1:444/file.txt --cacert ../MyOPNsenseCA.crt
<html>
<head><title>400 No required SSL certificate was sent</title></head>
<body bgcolor="white">
<center><h1>400 Bad Request</h1></center>
<center>No required SSL certificate was sent</center>
<hr><center>nginx</center>
</body>
</html>

curl https://192.168.1.1:444/file.txt --cert ../nginx_client_test_cert.crt --key ../nginx_client_test_cert.key --cacert ../MyOPNsenseCA.crt
Hello World


nginx: Web Application Firewall

Warning

This page is for advanced users only. A misconfiguration here may block requests to your API endpoints or website.

A web application firewall is no replacement for properly implemented security in front- and backend.
Background Information

The OPNsense WAF uses NAXSI, which is a loadable module for the nginx web server. NAXSI has two rule types:

    Main Rules: This rules are globally valid. Usual use case: Blocking code fragments that may be used to gain access to the server without permission (for example SQL-/XPATH-injection for data access) or to gain control over a foreign client (for example XSS).

    Basic Rules: This rules are usually used in the locations to whitelist main rules by id inside a location or for additional rules.

Note

A good place to start are the OWASP Cheat Sheets.

In addition to the self defined rules, NAXSI contains libinjection which is available directly in the location configuration. The NAXSI project itself has a high quality documentation for the module online. A good ruleset to start can be found at GitHub on the project page. It cannot be provided by the plugin because of license issues (GPL cannot be used in BSD 2 Clause code), but you may enter it manually by yourself.
OPNsense specific Information

    OPNsense blocks User Agents used by Bots automatically - this cannot be configured

    The error pages are stored under /usr/local/etc/nginx/views

Configuration
WAF Rules
../../_images/nginx_waf_rule.png

WAF rules are used to trigger an action if a condition evaluates to true or false (negated). The usual use case is increasing a score which can be checked afterwards, but a rule can for example also block instantly (the plugin only supports a score). WAF rules are grouped to a WAF policy, which then can evaluate the aggregated score.

The description will be shown in the GUI and the Message will appear in the log. Negate will switch the condition form “if” to “unless”. The ID must be unique. You should use a scheme like 1000 to 2000 are SQL injection or similar because that improves log evaluation if needed (for example you could create pie charts because you can group by the id range).

The next section describes the rule type and the match. You can scan the match value like truncate (an SQL keyword to delete the content of the table) in different places in the HTTP request. Mostly all of them can be checked or as an alternative, you can use a name so it will only match a specific header for example. Please note that not all of them are compatible with each other so please consult the NAXSI docs.
WAF Policy
../../_images/nginx_waf_policy.png

The name is used in the location select box, rules are a collection of the previously created rules.

Warning

Reuse of main rules will not work, clone them if needed. The reason is that they would conflict in id + score variable

Name
	

a good name like “block sql injection”

Rules
	

select the rules to group

Value
	

a compare value

Operator
	

choose a compare Operator to compare score operator value

Action
	

usually block

As an (incomplete) example:

Name
	

block SQLi

Rules
	

contains select, contains from, contains union, contains delete

Value
	

16

Operator
	

bigger or equal

Action
	

block
Location

In the last step, the rules must be applied to the location.
../../_images/nginx_waf_location.png

To enable the WAF in a location you have to check the “Enable Security Rules” checkbox. At the beginning, it would make sense, if the “Learning Mode” is enabled (nothing is blocked but logged, so you can add whitelists until you don’t get any false positives anymore).

The next two boxes are the score for libinjection. Both will add a score of 8 if they trigger. So values up to 8 will block.

In the next dropdown, you can select your custom policies, which will be applied now.
Testing

If you trigger the WAF by creating a request looking evil to the WAF, you should get a message in the server error log as well as an OPNsense branded error page (Request Denied For Security Reasons).

You may use curl to trigger it (if you block the following SQL keywords):

curl "http://example.com/index.php?a=select&b=union&c=from"

Note

You can use “NAXSI” as a filter in the filter box of the log viewer when viewing the error log.

nginx: TCP And UDP Streams
Background Information

Beside HTTP, nginx is also able to handle TCP- and UDP-traffic as well and it can also inspect the so called Client Hello of TLS using the preread module, to route based on SNI (Server Name Indication) which is an extension in TLS.
OPNsense specific Information

OPNsense offers two modes of operation:

    Pass through and route based on SNI

    Read and forward the data which can also terminate TLS

Configuration

Note

For Upstreams, please visit the nginx: Basic Load Balancing page. This expects that the upstreams are correctly set up.
SNI Upstream Maps

SNI Upstream Maps are a powerful feature if you have multiple servers behind your reverse proxy and every server maintains their own certificate and you do not want to or cannot use your own certificate. In such cases, you can use it to forward the traffic based on the Server Name Indication extension in the TLS protocol (given that TLS is used).

Warning

This will not work anymore with ESNI which may be published with TLS 1.3. If it causes trouble, do not enable encrypted SNI and stay with plain SNI. Also keep in mind that when SNI Upstream Maps are used, the connection will not be decrypted on OPNsense, so you cannot load balance a TLS connection to unencrypted servers.
../../_images/nginx_streams_snimap_edit.png

Short description
	

short description to show in dropdowns

Hostname Upstream Map
	

Enter a hostname and choose the upstream to forward the connection to for each combination
Upstream Servers

The upstream servers are the TCP and UDP load balancing feature of nginx. You may use it to proxy DNS, some proprietary protocols etc.

Warning

This will not work with protocols which need some special handling like FTP or SIP
../../_images/nginx_streams_server_edit.png

The listen port is the port used to expose the service to the clients. You should use the standard port defined by IANA to maintain best compatibility with most clients.

In case you are proxying UDP datagrams, you must enable the “UDP Port” checkbox.

Select a certificate if you want to terminate the TLS connection. If you route directly with upstream property, the upstream TLS settings are used, to choose if the backend connection should be TLS encrypted (again).

If you want to use an SNI Upstream Map, switch the entry in “Route With” and choose a mapping in the coresponding entry.

Note

In the advanced settings, you can also force TLS based authentication for upstream backends (not supported in SNI Upstream Mapping).
Test

You can test your setup using the following command:

curl https://HOSTNAME:PORT -vkI --resolve HOSTNAME:PORT:IP

HOSTNAME
	

The hostname you want to connect (example.com)

PORT
	

The port you run the proxy on

IP
	

IP of your OPNsense device (to override DNS)


Caddy: Reverse Proxy

Index

    Caddy: Reverse Proxy

        Features

        Installation

        Prepare OPNsense for Caddy After Installation

        FAQ

    Caddy: HTTP Handlers

        Standard Configuration

            Creating a Simple Reverse Proxy

            Restrict Access to Internal IPs

            Restrict Access with Basic Auth

            Dynamic DNS

                Dynamic DNS with Reverse Proxy

                Dynamic DNS in Client Mode

            Wildcard Domain with Subdomains

            Reverse Proxy the OPNsense WebGUI

            Redirect ACME HTTP-01 Challenge

            Filter by Domain

        Advanced Configuration

            Multiple Handlers for a Domain

            Reverse Proxy to a Webserver with Vhosts

            CrowdSec Integration

            High Availability Setups

            Forward Auth

            Run Caddy Process Unprivileged

            Bind Caddy to Interfaces

            Custom Configuration Files

    Caddy: Layer4 Routes

        Enable Layer4

        Matchers

            SSH, RDP, and other protocols

            HTTP (Host Header)

            TLS (SNI)

            TLS (inverted SNI)

    Caddy: Troubleshooting

        Help, Nothing Works!

        Get Help from the Caddy Community

Features

Reverse Proxy HTTP, HTTPS, FastCGI, WebSockets, gRPC, FastCGI (usually PHP), and more!

WWW: https://caddyserver.com/

Main features of this plugin:

    Easy to configure and reliable! Reverse Proxy any HTTP/HTTPS or WebSocket application in minutes.

    Automatic Let’s Encrypt and ZeroSSL certificates with HTTP-01 and TLS-ALPN-01 challenge

    DNS-01 challenge and Dynamic DNS with supported DNS Providers built right in

    Use custom certificates from OPNsense certificate store

    Wildcard Domain and Subdomain support

    Access Lists to restrict access based on static networks

    Basic Auth to restrict access by username and password

    Forward Auth with Authelia

    Syslog-ng integration and HTTP Access Log

    NTLM Transport

    Header manipulation

    Simple load balancing with passive health check

    Widgets for OPNsense Dashboard (24.7 and later)

    Layer4 SNI based routing of TCP/UDP

All available options and helptexts can be found on Github
Installation

    Install “os-caddy” from the OPNsense Plugins.

Prepare OPNsense for Caddy After Installation

Attention

Caddy uses port 80 and 443. So the OPNsense WebGUI or other plugins can’t bind to these ports.

Go to System ‣ Settings ‣ Administration

    Change the TCP Port to 8443 (example), do not forget to adjust the firewall rules to allow access to the WebGUI. On LAN there is a hidden anti-lockout rule that takes care of this automatically. On other interfaces, make sure to add explicit rules.

    Enable the checkbox for HTTP Redirect - Disable web GUI redirect rule.

Go to Firewall ‣ Rules ‣ WAN

    Create Firewall rules that allow HTTP and HTTPS to destination This Firewall on WAN

Option
	

Values

Interface
	

WAN

TCP/IP Version
	

IPv4+IPv6

Protocol
	

TCP

Source
	

Any

Destination
	

This Firewall

Destination port range
	

from: HTTP to: HTTP

Description
	

Caddy Reverse Proxy HTTP

Option
	

Values

Interface
	

WAN

TCP/IP Version
	

IPv4+IPv6

Protocol
	

TCP/UDP

Source
	

Any

Destination
	

This Firewall

Destination port range
	

from: HTTPS to: HTTPS

Description
	

Caddy Reverse Proxy HTTPS

Go to Firewall ‣ Rules ‣ LAN and create the same rules for the LAN interface. Now external and internal clients can connect to Caddy, and Let’s Encrypt or ZeroSSL certificates will be issued automatically.
FAQ

    A DNS Provider is not required to get automatic certificates.
    Port Forwards, NAT Reflection, Split Horizon DNS or DNS Overrides in Unbound are not required. Only create Firewall rules that allow traffic to the default ports of Caddy.
    Even though internal clients will use the external IP address to access the reverse proxied services, the traffic will not pass over the internet. It will stay inside the OPNsense. Only in rare cases where there is multi WAN, the traffic can be routed from one WAN interface to the other over the internet, due to reply-to settings.
    Firewall rules to allow Caddy to reach internal services are not required. OPNsense has a default rule that allows all traffic originating from itself to be allowed.
    ACME clients on reverse proxied upstream destinations will not be able to issue certificates. Caddy intercepts /.well-known/acme-challenge. This can be solved by using the HTTP-01 Challenge Redirection option in the advanced mode of domains. Please check the tutorial section for an example.
    When using Caddy with IPv6, the best choice is to have a GUA (Global Unicast Address) on the WAN interface, since otherwise the TLS-ALPN-01 challenge might fail.
    Let’s Encrypt or ZeroSSL can not be explicitely chosen. Caddy automatically issues one of these options, determined by speed and availability. These certificates can be found in /var/db/caddy/data/caddy/certificates.
    When an Upstream Destination only supports TLS connections, yet does not offer a valid certificate, enable TLS Insecure Skip Verify in a Handler to mitigate connection problems.
    Caddy upgrades all connections automatically from HTTP to HTTPS. When cookies do not have have the secure flag set by the application serving them, they can still be transmitted unencrypted before the connection is upgraded. If these cookies contain very sensitive information, it might be a good choice to close port 80.
    There is optional Layer4 TCP/UDP routing support. In the scope of this plugin, only traffic that looks like TLS and has SNI can be routed. The HTTP App and Layer4 App can work together at the same time.
    There is no WAF (Web Application Firewall) support in this plugin. For a business grade Reverse Proxy with WAF functionality, use os-OPNWAF. As an alternative to a WAF, it is simple to integrate Caddy with CrowdSec. Check the tutorial section for guidance.

* | There is no WAF (Web Application Firewall) support in this plugin. For a business grade Reverse Proxy with WAF functionality, use os-OPNWAF. As an alternative to a WAF, it is simple to integrate Caddy with CrowdSec. Check the tutorial section for guidance.
Caddy: HTTP Handlers
Standard Configuration

Attention

The tutorial section implies that Prepare OPNsense for Caddy after installation has been followed.
Creating a Simple Reverse Proxy

The domain has to be externally resolvable. Create an A-Record with an external DNS Provider that points to the external IP Address of the OPNsense.

Go to Services ‣ Caddy Web Server ‣ General Settings

    Check Enabled to enable Caddy
    Input a valid email address into the Acme Email field. This is mandatory to receive automatic Let’s Encrypt and ZeroSSL certificates.
    Press Save

Go to Services ‣ Caddy Web Server ‣ Reverse Proxy ‣ Domains

    Press Step 1: Add Domain. This will be the frontend that receives the traffic for the chosen domain name.

Options
	

Values

Domain:
	

foo.example.com

Port:
	

Leave empty

    Press Save
    Go to Services ‣ Caddy Web Server ‣ Reverse Proxy ‣ HTTP Handlers
    Press Step 2: Add HTTP Handler. This will create a HTTP Handler that routes the traffic from the frontend domain to the an internal service.

Options
	

Values

Domain:
	

foo.example.com

Upstream Domain:
	

192.168.10.1

Upstream Port:
	

Leave empty, or use a custom port

TLS Insecure Skip Verify
	

Enable if internal service requires HTTPS connection

    Press Save and Apply

The automatic certificate will be installed, check the Logfile if there are errors. Now the frontend domain foo.example.com:80/443 receives all requests, and reverse proxies them to the upstream destination 192.168.10.1:80 (or custom port).

And that’s it, a working reliable reverse proxy in less than a minute. There are a lot of additional options, but this is essentially all that is needed for simple setups.

Tip

Since OPNsense 24.7, there is a Caddy Certificate Dashboard widget that shows all issued automatic certificates.

Note

TLS Insecure Skip Verify can be used in private networks. If the upstream destination is in an insecure network, like the internet or a dmz, consider using proper certificate handling.
Restrict Access to Internal IPs

Since the reverse proxy will accept all connections, restricting access with a firewall rule would impact all domains. Access Lists can restrict access per domain. In this example, they are used to restrict access to only internal IPv4 networks, refusing connections from the internet.

Go to Services ‣ Caddy Web Server ‣ Reverse Proxy ‣ HTTP Access ‣ Access Lists

    Press + to create a new Access List

Options
	

Values

Access List Name:
	

private_ipv4

Client IP Addresses:
	

192.168.0.0/16 172.16.0.0/12 10.0.0.0/8

Description:
	

Allow access from private IPv4 ranges

    Press Save

Go to Services ‣ Caddy Web Server ‣ Reverse Proxy ‣ Domains

    Edit an existing Domain or Subdomain and expand the Access Tab.

Options
	

Values

Access List:
	

private_ipv4

    Press Save and Apply

Now, all connections without a private IPv4 address will be served an empty page. To outright refuse the connection, the option Abort Connections in Services ‣ Caddy Web Server ‣ General Settings should be additionally enabled. Some applications might demand a HTTP Error code instead of having their connection aborted, an example could be monitoring systems. For these a custom HTTP Response Code can be enabled.

Note

Access Lists will match before Basic Auth, so both options can synergize.
Restrict Access with Basic Auth

Since the reverse proxy will accept all connections, restricting access with a firewall rule would impact all domains. Basic Auth will restrict access to one or multiple users.

Go to Services ‣ Caddy Web Server ‣ Reverse Proxy ‣ HTTP Access ‣ Basic Auth

    Press + to create a new User

Options
	

Values

User:
	

John

Password:
	

RandomPassword

    Press Save and create additional Users if needed, e.g. Sarah.

Go to Services ‣ Caddy Web Server ‣ Reverse Proxy ‣ Domains

    Edit an existing Domain or Subdomain and expand the Access Tab.

Options
	

Values

Basic Auth:
	

John, Sarah

    Press Save and Apply

Now, all anonymous connections have to authenticate with Basic Auth before accessing the reverse proxied service.

Note

Using Crowdsec is recommended. It will log authentication errors, and will ban these IP addresses. This prevents password bruteforcing.
Dynamic DNS

Supported Dynamic DNS Providers and requests for additions can be found here.

Note

Read the full help text for guidance. It could also be necessary to check the selected provider module at Caddy DNS for further instructions. These modules are community maintained. When a module introduces issues that are not fixed it will be removed from this plugin.
Dynamic DNS with Reverse Proxy

Go to Services ‣ Caddy Web Server ‣ General Settings ‣ DNS Provider

    Select one of the supported DNS Providers from the list

    Input the DNS API Key, and any number of the additional required fields in Additional Fields.

Go to Services ‣ Caddy Web Server ‣ General Settings ‣ Dynamic DNS

    Choose if DynDns IP Version should include IPv4 and/or IPv6.

    Press Save

Go to Services ‣ Caddy Web Server ‣ Reverse Proxy ‣ Domains

    Press + to create a new Domain. mydomain.duckdns.org is an example if duckdns is used as DNS Provider.

Options
	

Values

Domain:
	

mydomain.duckdns.org

Dynamic DNS:
	

X

Go to Services - Caddy Web Server - Reverse Proxy – HTTP Handlers

    Press + to create a new HTTP Handler

Options
	

Values

Domain:
	

mydomain.duckdns.org

Upstream Domain:
	

192.168.1.1

    Press Save and Apply

Check the Logfile for the DynDNS updates. Set it to Informational and search for the chosen domain.
Dynamic DNS in Client Mode

Sometimes, only the Dynamic DNS functionality is needed. There can be cases where a DNS Provider is fully supported in os-caddy, yet not in other DynDNS plugins of the OPNsense. With the right configuration, this plugin can be used as DynDNS Client without using port 80 and 443, which stay free to use for other services.

Go to Services ‣ Caddy Web Server ‣ General Settings

    Check enabled to enable Caddy

    Set AutoHTTPS to off - This will ensure port 80 will not be used by Caddy.

    Enable the advanced options and set the HTTPS Port to a random upper TCP port, e.g. 20000.

Go to Services ‣ Caddy Web Server ‣ General Settings ‣ DNS Provider

    Select one of the supported DNS Providers from the list.

    Input the DNS API Key, and any number of the additional required fields in Additional Fields.

Go to Services ‣ Caddy Web Server ‣ General Settings ‣ Dynamic DNS

    Choose if DynDns IP Version should include IPv4 and/or IPv6.

    Extend Additional Checks and for DynDns Check Interface select the WAN interface.
    Press Save

Go to Services ‣ Caddy Web Server ‣ Reverse Proxy ‣ Domains

    Press + to create a new Domain. mydomain.duckdns.org is an example if duckdns is used as DNS Provider.

Options
	

Values

Domain:
	

mydomain.duckdns.org

Dynamic DNS:
	

X

    Create any additional domains for DynDNS updates just like that.
    Press Save and Apply

Wildcard Domain with Subdomains

Attention

If in doubt, do not use subdomains. If there should be foo.example.com, bar.example.com and example.com, just create them as three base domains. This way, there is the most flexibility, and the most features are supported.

Go to Services ‣ Caddy Web Server ‣ General Settings ‣ DNS Provider

    Select one of the supported DNS Providers from the list

    Input the DNS API Key, and any number of the additional required fields in Additional Fields. Read the full help for details.

Go to Services ‣ Caddy Web Server ‣ Reverse Proxy ‣ Domains

    Create *.example.com as domain and activate the DNS-01 challenge checkbox. Alternatively, use a certificate imported or generated in System ‣ Trust ‣ Certificates. It has to be a wildcard certificate.
    Press Apply to enable Services ‣ Caddy Web Server ‣ Reverse Proxy ‣ Subdomains. This tab only shows when a wildcard domain has been configured.
    Create all subdomains in relation to the *.example.com domain, for example foo.example.com and bar.example.com.

Go to Services ‣ Caddy Web Server ‣ Reverse Proxy ‣ HTTP Handlers

    Create a HTTP Handler with *.example.com as domain and foo.example.com as subdomain. Most of the same configuration as with base domains are possible.

Note

The certificate of a wildcard domain will only contain *.example.com, not a SAN for example.com. If there is a service that should match example.com exactly, create an additional domain for example.com with an additional HTTP Handler for its upstream destination. Subdomains do not support setting ports, they will always track the ports of their assigned parent wildcard domain.
Reverse Proxy the OPNsense WebGUI

Tip

The same approach can be used for any upstream destination using TLS and a self-signed certificate.

Attention
The OPNsense WebGUI is only bound to 127.0.0.1 when no specific interface is selected: System ‣ Settings ‣ Administration - Listen Interfaces - All (recommended). Otherwise, use the IP address of the specific interface as “Upstream Domain”.
When setting Enable syncookies to always in Firewall ‣ Settings ‣ Advanced, reverse proxying the WebGUI is currently not possible. Set it to an adaptive setting, or never (default).

    Open the OPNsense WebGUI in a browser (e.g. Chrome or Firefox). Inspect the certificate by clicking on the 🔒 in the address bar. Copy the SAN for later use. It can be a hostname, for example OPNsense.localdomain.
    Save the certificate as .pem file. Open it up with a text editor, and copy the contents into a new entry in System ‣ Trust ‣ Authorities. Name the certificate opnsense-selfsigned.
    Add a new Domain, for example opn.example.com.
    Add a new HTTP Handler with the following options:

Options
	

Values

Domain:
	

opn.example.com

Upstream Domain:
	

127.0.0.1

Upstream Port:
	

8443 (WebGUI Port)

TLS:
	

X

TLS Trust Pool:
	

opnsense-selfsigned

TLS Server Name:
	

OPNsense.localdomain

    Press Save and Apply

Go to System ‣ Settings ‣ Administration

    Input opn.example.com in Alternate Hostnames to prevent the error The HTTP_REFERER "https://opn.example.com/" does not match the predefined settings

    Press Save

Open https://opn.example.com and it should serve the reverse proxied OPNsense WebGUI. Check the log file for errors if it does not work, most of the time the TLS Server Name doesn’t match the SAN of the TLS Trust Pool. Caddy does not support certificates with only a CN Common Name.

Attention

Create an Access List to restrict access to the WebGUI.
Redirect ACME HTTP-01 Challenge

Sometimes an application behind Caddy uses its own ACME Client to get certificates, most likely with the HTTP-01 challenge. This plugin has a built in mechanism to redirect this challenge type easily to a destination behind it.

Make sure the chosen domain is externally resolvable. Create an A-Record with an external DNS Provider that points to the external IP Address of the OPNsense. In case of IPv6 availability, it is mandatory to create an AAAA-Record too, otherwise the TLS-ALPN-01 challenge might fail.

It is mandatory that the domain in Caddy uses an empty port or 443 in the GUI, otherwise it can not use the TLS-ALPN-01 challenge for itself. The upstream destination has to listen on Port 80 and serve /.well-known/acme-challenge/, for the same domain that is configured in Caddy.

Go to Services ‣ Caddy Web Server ‣ Reverse Proxy ‣ Domains

    Press + to create a new Domain

Options
	

Values

Domain:
	

foo.example.com

HTTP-01 Challenge Redirection:
	

192.168.10.1

    Press Save and Apply

The HTTP-01 Challenge Redirection is active and the internal resource located at 192.168.10.1 will be able to issue the certificate for the domain foo.example.com. If the internal ressource should also be reverse proxied, add a handler to the domain.

Go to Services ‣ Caddy Web Server ‣ Reverse Proxy ‣ HTTP Handler

    Press + to create a new HTTP Handler

Options
	

Values

Domain:
	

foo.example.com

Upstream Domain:
	

192.168.10.1

Upstream Port:
	

443

TLS:
	

X

TLS Server Name:
	

foo.example.com

    Press Save and Apply

With this configuration, Caddy will choose the TLS-ALPN-01 challenge to get its own certificate for foo.example.com, and reverse proxy the HTTP-01 challenge to 192.168.10.1, where the upstream destination can listen on port 80 for foo.example.com. With TLS enabled in the Handler, an encrypted connection is automatically possible. The automatic HTTP to HTTPS redirection is also taken care of.
Filter by Domain

Having a large configuration can become a bit cumbersome to navigate. To help, a new filter functionality has been added to the top right corner of the Domains, Subdomains and HTTP Handlers tab, called Filter by Domain.

In Filter by Domain, one or multiple Domains can be selected, and as filter result, only their corresponding configuration will be displayed in Domains, Subdomains and Handlers. This makes keeping track of large configurations a breeze.
Advanced Configuration
Multiple Handlers for a Domain

Handlers are not limited to one per domain/subdomain. If there are multiple different URIs to handle (e.g. /foo/* and /bar/*), create a handler for each of them. Just make sure each of these URIs are on the same level, creating /foo/* and /foo/bar/* will make /foo/* match everything.

Doing this can route traffic to different upstreams based on URIs. It could also be used to send certain URIs into a blackhole by setting an upstream that does not exist (e.g. to block /ecp/*).

Additionally, when creating an empty handler for a domain/subdomain, the templating logic will always automatically place it last in the Caddyfile site block. This means, specific URIs will always match before an empty URI. An example would be to block specific URIs, route others specifically, and then set a catch all empty handle last to handle all unspecific traffic.

When using a mix of wildcard domains and subdomains, a handler set only on the wildcard domain will match after all subdomains. That way, all unmatched subdomains can be sent to a custom upstream.

Different handling logics can be selected, e.g. handle path to strip the URI or handle to preserve the URI.

An example Caddyfile would look like this:

# Reverse Proxy Domain: "531e7877-0b58-4f93-a9f0-54beee58bdea"
autodiscover.example.com {
        handle /ecp/* {
                reverse_proxy blackhole {
                }
        }

        handle /autodiscover/* {
                reverse_proxy 172.16.99.10 {
                }
        }

        handle {
                reverse_proxy 192.168.1.33 {
                }
        }
}
# Reverse Proxy Domain: "58760ae1-2409-4a6b-a6c4-d58b15706b55"
mail.example.com {
        handle {
                reverse_proxy 192.168.1.33 {
                }
        }
}

Reverse Proxy to a Webserver with Vhosts

Sometimes it is necessary to alter the host header in order to reverse proxy to another webserver with vhosts.

Since Caddy passes the original host header by default (e.g. app.external.example.com), if the upstream destination listens on a different hostname (e.g. app.internal.example.com), it would not be able to serve this request.

Go to Services ‣ Caddy Web Server ‣ Reverse Proxy ‣ Domains

    Press + to create a new Domain

Options
	

Values

Domain:
	

app.external.example.com

    Press Save

Go to Services ‣ Caddy Web Server ‣ Reverse Proxy ‣ HTTP Headers

    Press + to create a new HTTP Header

Options
	

Values

Header:
	

header_up

Header Type:
	

Host

Header Value:
	

{upstream_hostport}

    Press Save

Go to Services ‣ Caddy Web Server ‣ Reverse Proxy ‣ HTTP Handler

    Press + to create a new HTTP Handler

Options
	

Values

Domain:
	

app.external.example.com

Upstream Domain:
	

app.internal.example.com

Header Manipulation:
	

header_up Host {upstream_hostport}

    Press Save and Apply

CrowdSec Integration

CrowdSec is a powerful alternative to a WAF. It uses logs to dynamically ban IP addresses of known bad actors. The Caddy plugin is prepared to emit the json logs for this integration.

Go to Services ‣ Caddy Web Server ‣ General Settings ‣ Log Settings

    Enable Log HTTP Access in JSON Format

    Press Save

Go to Services ‣ Caddy Web Server ‣ Reverse Proxy –-> Domains

    Open each Domain that should be monitored by CrowdSec and open Access

    Enable HTTP Access Log

Now the HTTP access logs will appear in /var/log/caddy/access in json format, one file for each domain.

Next, connect to the OPNsense via SSH or console, go into the shell with Option 8.

Attention

This step requires the os-crowdsec plugin.

    Once in the shell, install the caddy collection from CrowdSec Hub. cscli collections install crowdsecurity/caddy

    Create the configuration file as /usr/local/etc/crowdsec/acquis.d/caddy.yaml with the following content:

filenames:
  - /var/log/caddy/access/*.log

force_inotify: true
poll_without_inotify: true

labels:
  type: caddy

    Go into the OPNsense WebGUI and restart CrowdSec.

High Availability Setups

There are a few possible configurations to run Caddy successfully in a High Availability Setup with two OPNsense firewalls.

The main issue to think about is the certificate handling. If a CARP VIP is used on the WAN interface, and the A and AAAA Records of all domains point to this CARP VIP, the backup Caddy will not be able to issue ACME certificates without some additional configuration.

There are three methods that support XMLRPC sync:

Note

These methods can be mixed, just make sure to use a coherent configuration. It is best to decide for one method. Only Domains need configuration, Subdomains do not need any configuration for HA.

    Using custom certificates from the OPNsense Trust store for all Domains.

    Using the DNS-01 Challenge in the settings of Domains.

    Using the HTTP-01 Challenge Redirection option in the advanced settings of Domains.

Since the HTTP-01 Challenge Redirection needs some additional steps to work, it should be set up as followed:

    Configure Caddy on the master OPNsense until the whole initial configuration is completed.
    On the master OPNsense, select each Domain, and set the IP Address in HTTP-01 Challenge Redirection to the same value as in Synchronize Config to IP found in System ‣ High Availability ‣ Settings.
    Create a new Firewall rule on the master OPNsense that allows Port 80 and 443 to This Firewall on the interface that has the prior selected IP Address (most likely a LAN or VLAN interface).
    Sync this configuration with XMLRPC sync.

Now both Caddy instances will be able to issue ACME certificates at the same time. Caddy on the master OPNsense uses the TLS-ALPN-01 challenge for itself and reverse proxies the HTTP-01 challenge to the Caddy of the backup OPNsense. Please make sure, that the master and backup OPNsense are both listening on their WAN and LAN (or VLAN) interfaces on port 80 and 443, since both ports are required for these challenges to work.

Tip

Check the Logfile on both Caddy instances for successful challenges. Look for certificate obtained successfully informational messages.
Forward Auth

Delegating authentication to Authelia, before serving an app via reverse proxy, is a very advanced usecase. The Forward Auth Documentation should be used for inspiration.

To attach the Forward Auth directive to a handler, the Auth Provider has to be filled out in the General Settings. Afterwards, the Forward Auth checkbox in a Handler can be selected. This will prepend the forward_auth directive in front of the reverse_proxy directive in the scope of that Handler. Headers are set automatically.

Using Access Lists and Basic Auth in the Domain this Handler matches on is not recommended.

An example Caddyfile would look like this:

app1.example.com {
    handle {
        forward_auth authelia:9091 {
            uri /api/verify?rd=https://auth.example.com
            copy_headers Remote-User Remote-Groups Remote-Name Remote-Email
        }
        reverse_proxy 192.168.1.10:8080 {
        }
    }
}

Requests from clients to app1.example.com will be sent to Authelia via the forward_auth directive. Then, after the authentication has been completed, the reverse_proxy directive sends the traffic to the Upstream.
Run Caddy Process Unprivileged

In this plugin, Caddy runs as root. This is required when well-known ports are used. Since the default ports are 80 and 443, Caddy will be started as superuser.

For higher security demands, there is the option to run Caddy as www user and group. This comes with the restriction of only being able to use upper ports.

Make sure all of the domains have empty ports, or ports above the well-known port range before continuing. There is a validation that will prevent configuring well-known ports when Disable Superuser is active.

Go to Services ‣ Caddy Web Server ‣ General Settings ‣ General

    Enable the advanced mode
    Add custom upper HTTP Port, e.g. 8080
    Add custom upper HTTPS Port, e.g. 8443
    Enable the checkbox Disable Superuser
    Disable the checkbox Enabled and press Apply
    Enable the checkbox Enabled and press Apply

From now on, Caddy will run as www user and group. This can be verified by checking the user of the Caddy process.

Note

With this configuration, Port Forward (DNAT with PAT - Destination Network Address Translation with Port Address Translation) should be used to forward port 80 and 443 to the new alternative HTTP and HTTPS Ports. For IPv6 additional steps could be required.
Bind Caddy to Interfaces

Warning

Binding a service to a specific interface via IP address can cause lots of issues. If the IP address is dynamic, the service can crash or refuse to start. During boot, the service can refuse to start if the interface IP addresses are assigned too late. Configuration changes on the interfaces can cause the service to crash. Only use this with static IP addresses! There is no OPNsense community support for this configuration.

This configuration is only useful if there are two or more WAN interfaces, and Caddy should only respond on one of them. It can also solve port conflicts, for example if one interface should DNAT or host a different service with the default webserver ports. In all other cases, it is always better not to do this.

    Create the following files with the following content in the OPNsense filesystem:

    /usr/local/etc/caddy/caddy.d/defaultbind.global

default_bind 203.0.113.1 192.168.1.1

    /usr/local/etc/caddy/caddy.d/defaultbind.conf

http:// {
bind 203.0.113.1 192.168.1.1
}

Now Caddy will only bind to 203.0.113.1 and 192.168.1.1. It can still be configured in the GUI without restrictions.

Read more about the default_bind directive: Default Bind
Custom Configuration Files

    The Caddyfile has an additional import from the path /usr/local/etc/caddy/caddy.d/. Place custom configuration files inside that adhere to the Caddyfile syntax.
    *.global files will be imported into the global block.
    *.conf files will be imported into the site block.
    *.layer4 files will be imported into the layer4 directive.
    Don’t forget to test the custom configuration with caddy validate --config /usr/local/etc/caddy/Caddyfile.

With these imports, the full potential of Caddy can be unlocked. The GUI options will remain focused on the reverse proxy. There is no OPNsense community support for configurations that have not been created with the offered GUI. For customized configurations, the Caddy community is the right place to ask.
Caddy: Layer4 Routes

Attention

Requires os-caddy-1.6.2 or later. This is a new feature of Caddy and in active developement. Consider this a feature preview. Even though it works as expected, do not use this in production. The scope of Layer4 features inside this plugin are very contained - so when something changes upstream, it can be hopefully downstreamed without rewriting the whole logic.
Enable Layer4

    Go to Services ‣ Caddy Web Server ‣ General Settings and enable the advanced mode
    Enable the checkbox (Feature Preview) Enable Layer4
    Press Apply, then go to Services ‣ Caddy Web Server ‣ Reverse Proxy ‣ Layer4 Routes

Note

Layer4 Routing can be disabled completely at any time by disabling the (Feature Preview) Enable Layer4 checkbox.

Tip

Layer4 Routing Precedence (automatic, order of listed items in bootgrid does not matter)

    SSH (and other protocols that can only match all traffic)

    HTTP (Host Header)

    TLS (SNI)

    TLS (inverted SNI)

    HTTP Handlers (hidden default route)

Matchers

A matcher checks the first bytes of a TCP/UDP paket and decides which protocol it could be. Right now, SNI and Host matchers are supported. They either check the contents of the Client Hello at the start of a TLS handshake, or the Host Header in case of HTTP traffic. Since most traffic is TLS and HTTP, there is a lot of flexibility without making configuration too complicated. There are also protocol matchers like SSH that can match and route raw traffic without making decisions based on SNI or Host, since the SSH protocol does not send that information.

Layer4 Routes match before domains in the Domains Tab. That is why already existing domains can not be selected in a matcher. They have to be manually filled in. Multiple domains and even wildcards can be matched in the same Layer4 Route.
SSH, RDP, and other protocols

This is a raw protocol matcher. It will match all traffic that looks like the chosen protocol on the default ports of Caddy, and proxy it to the selected upstream. Only one of these routes per protocol will match. Host Headers or SNI can not be evaluated.

    Go to Services ‣ Caddy Web Server ‣ Reverse Proxy ‣ Layer4 Routes

    Press + to create a new Layer4 Route

Options
	

Values

Domain:
	

*

Matcher:
	

SSH

Upstream Domain:
	

192.168.1.1

Upstream Port:
	

22

    Press Save and Apply

Now an SSH client can open up a proxied connection like ssh app1.example.com -p 443 and the SSH traffic will go over the same port as other HTTP/HTTPS traffic. Caddy becomes a protocol multiplexer.

Tip

If another route is added, e.g. with the RDP matcher, then SSH and RDP will be on the same port but will be proxied to different upstreams.
HTTP (Host Header)

Same logic as the SNI matcher, but can be used to route HTTP traffic, since the Host Header is evaluated.

Note

Host and SNI matchers can be used at the same time for the same domains, to route HTTP and TLS traffic to different sockets.

Attention

When Browsers find an available HTTPS socket for the same domain name, they might force a redirect to the secure channel. Verify with curl that the HTTP route indeed works as intended.
TLS (SNI)

As example, there is an application with the hostname app1.example.com which should not be handled by the default HTTP Handlers. The TLS TCP/UDP traffic of this application should be routed directly to the upstream destination without TLS termination. At the same time, all other traffic should be routed to the default HTTP Handlers.

    Go to Services ‣ Caddy Web Server ‣ Reverse Proxy ‣ Layer4 Routes

    Press + to create a new Layer4 Route

Options
	

Values

Domain:
	

app1.example.com

Matcher:
	

SNI

Upstream Domain:
	

192.168.1.1

Upstream Port:
	

8443

    Press Save and Apply

Caddy listens on the default HTTP and HTTPS ports. All traffic it receives on these or any other listening ports, gets passed to the listener_wrapper. Inside this wrapper, the traffic can be inspected on Layer4, and routing decisions can be made.

With the matcher TLS (SNI), the Client Hello of the TLS traffic is analyzed. When the Client Hello includes app1.example.com, the traffic will be matched by the new Layer4 Route. The raw TCP/UDP traffic will be streamed to the chosen socket - which consists of Upstream Domain and Upstream Port.

Any other traffic that is not matched by any Layer4 Route will be routed to the HTTP Handlers, where the configured Domains and Subdomains can receive and reverse proxy it.

Note

When Auto HTTPS is enabled, all clients will be permanently redirected to HTTPS automatically. If that should not happen, set it to Disable Redirects.
TLS (inverted SNI)

This matcher is very powerful. It can route all unmatched domains, for example to a hosting panel where the domains are not under administrative control and can change at any time. Any matched domains will be routed to the HTTP Handlers.

    Go to Services ‣ Caddy Web Server ‣ Reverse Proxy ‣ Layer4 Routes

    Press + to create a new Layer4 Route

Options
	

Values

Domain:
	

*.example.com *.opnsense.com

Matcher:
	

not SNI

Upstream Domain:
	

192.168.1.1 192.168.1.2

Upstream Port:
	

443

Fail Duration:
	

10

    Press Save and Apply

With the Matcher TLS (inverted SNI), the Client Hello of the TLS traffic is analyzed. When the Client Hello includes either of *.example.com or *.opnsense.com, the traffic will be sent to the default HTTP Handlers, where the configured Domains and Subdomains can receive and reverse proxy it.

All other TCP/UDP traffic will be streamed to the chosen socket of Upstream Domain and Upstream Port. Since we chose multiple upstreams and a health check, two servers can load balance all requests. The load balancing is just an example, and not necessary for this matcher to work.

Tip

If there are domains inside *.example.com that should be routed to a different upstream, just create an additional TLS (SNI) matcher for them. It will automatically match before the TLS (inverted SNI) - compare to the Layer4 Routing Precedence.

Tip

Caddy supports the HA Proxy Protocol. If the Protocol Header should be added to the upstream, set the Proxy Protocol version to v1 or v2.
Caddy: Troubleshooting
Help, Nothing Works!

Note

Even though Caddy itself is quite easy to configure in the plugin, setting the infrastructure up for it to work correctly imposes the real challenge. If you feel stumped, the best approach is getting knowledge about what should happen. This section tries to explain that, and give examples how to resolve issues.

Tip

Most errors happen because the infrastructure is not set up correctly, or wrong options for the HTTP Handler have been set.

Attention

Do not use the Layer4 module without knowing the implications of it. It is for very advanced usecases. Better deactivate it if things do not work as expected.

This is what should happen if Caddy works correctly:

    A Web Browser is opened and an URL is put into the address bar: https://example.com
    The underlying Operating System of the Web Browser sends a request to its default DNS Server, and asks where to find example.com. The DNS Server will try to find the requested A- and/or AAAA-Record for that domain, and will answer with e.g. 203.0.113.1.
    The Web Browser now sends a HTTPS request to 203.0.113.1. This request contains a Client Hello in the TLS handshake, that contains example.com.
    This HTTPS request hits port 443 of the OPNsense’s WAN or LAN interface, determined by the location of the Web Browser (LAN or WAN).
    There is a Firewall rule that allows destination port 443 to access This Firewall. The request will then be received by Caddy, because it listens on This Firewall on port 443.
    In Caddy, there is a domain for example.com set up. It has a valid Let’s Encrypt or ZeroSSL certificate. Since the Client Hello contains example.com, Caddy will match it with the domain, and the Web Browser shows a certificate next to https://example.com in the address bar.
    Caddy takes the HTTPS request and terminates the TLS connection. That means, it will convert the HTTPS into HTTP, so it can be processed by the HTTP Handler.
    Caddy checks if there is a matching HTTP Handler set up. It will be used to reverse proxy the HTTP request to an internal service.
    Inside the HTTP Handler, the domain example.com and an Upstream Domain e.g. 192.168.1.10 and Upstream Port e.g. 8080 point the request to the internal service. Caddy then sends the HTTP request directly to the internal service.
    The HTTP response from the internal service is received by Caddy, wrapped back into TLS, and sent back to the Web Browser as HTTPS response.
    The website of the internal service shows up in the Web Browser, secured by HTTPS.

Attention

If that does not work, it means that one or multiple steps in that chain of events fail. Please check the following steps for initial troubleshooting.

1. Check the Infrastructure:

    Do A- and/or AAAA-Record for all Domains and Subdomains exist?

    In case of activated Dynamic DNS, check that the correct A- and/or AAAA-Records have been set automatically with the DNS Provider.

    Do they point to one of the external IPv4 or IPv6 addresses of the OPNsense Firewall? Check that with commands like nslookup example.com.

    Do the OPNsense Firewall Rules allow connections from any source to destination ports 80 and 443 to the destination This Firewall?

    Is the Caddy service running?

2. Check if the Domain is set up correctly:

    Disable Abort in General Settings to test if the Domain works correctly.

    Open the Domain in a Web Browser. Inspect the certificate by clicking on the 🔒 in the address bar. It should be a Let’s Encrypt, ZeroSSL or custom certificate (if chosen).

    Activate the HTTP Access Log in a Domain, and check the Log File. Are there any log entries that show connections?

    If nothing shows up, go back to Step 1 and check the infrastructure.

3. Check the functionality of the internal service (e.g. a Nextcloud):

    Does the service accept HTTP or HTTPS connections? It is recommended to connect via HTTP, since it removes complexity.

    Open the internal service via IP address and port in a Web Browser, e.g. http://192.168.10:8080. Validate that it shows the website on either HTTP or HTTPS ports.

    Does the internal service actually use the HTTP or HTTPS protocol? Other protocols will not work, e.g. SSH.

    If the Web Browser can not connect, it might be a good idea to get the internal service working properly before continuing.

4. Check the setup of the HTTP Handler:

    Is the correct Domain chosen?

    Are Upstream Domain and Upstream Port correct? Do they point to the internal service, e.g 192.168.10:8080?

    If the internal service only accepts HTTPS connections, is either TLS insecure skip verify checked, or is trust established by a TLS Trust Pool?

Attention

If the configuration is still not working, it is time to continue with logs and Caddyfile syntax checks.
Get Help from the Caddy Community

Sometimes, things do not work as expected. Caddy provides a few powerful debugging tools to analyze issues.

This section explains how to obtain the required files to get help from the Caddy Community.

    Change the global Log Level to DEBUG. This will log everything the reverse_proxy directive handles.

Go to Services ‣ Caddy Web Server ‣ General Settings ‣ Log Settings

    Set the Log Level to DEBUG

    Press Apply

Go to Services ‣ Caddy Web Server ‣ Log File

    Change the dropdown from INFORMATIONAL to DEBUG

Now the reverse_proxy debug logs will be visible and can be downloaded.

    Validate and download the Caddyfile.

Go to Services ‣ Caddy Web Server ‣ Diagnostics ‣ Caddyfile

    Press the Validate Caddyfile button to make sure the current Caddyfile is valid.
    Press the Download button to get this current Caddyfile.
    If there are custom imports in /usr/local/etc/caddy/caddy.d/, download the JSON configuration.

Attention

Rarely, a performance profile might be requested. For this, a special admin endpoint can be activated. This admin endpoint is deactivated by default. To enable it and access it on the OPNsense, follow these additional steps. Do not forget to deactivate it after use. Anybody with network access to the admin endpoint can use REST API to change the running configuration of Caddy, without authentication.

    SSH into the OPNsense shell
    Stop Caddy with configctl caddy stop
    Go to /usr/local/etc/caddy/caddy.d/
    Create a new file called admin.global and put the following content into it: admin :2019
    After saving the file, go to /usr/local/etc/caddy and run caddy validate to ensure the configuration is valid.
    Start Caddy with configctl caddy start
    Use sockstat to see if the admin endpoint has been created. sockstat -l | grep -i caddy - it should show the endpoint *:2019.
    Create a firewall rule on LAN that allows TCP to destination This Firewall and destination port 2019.
    Open the admin endpoint: http://YOUR_LAN_IP:2019/debug/pprof/
    Follow the instructions on Profiling Caddy.


CPU Microcode updates [AMD/Intel]
Introduction

Processor manufactures like AMD and Intel often release microcode updates to increase stabilty and security of their products. Microcode updates can close the gap in between BIOS/EFI updates, which are generally less frequently available, to fix issues found after product release.

This document describes the two plugins available in OPNsense and how to verify the microcode version being used on the system at hand.

Note

Microcode patches are shipped in our package repository. If there is a new patch level available, it will automatically be applied on a system update while the plugin is installed.
Installation

Installation of this plugin is rather easy, go to System ‣ Firmware ‣ Plugins and search for os-cpu-microcode-amd or os-cpu-microcode-intel, then use the [+] button to install it.

Reboot the machine to apply the new microcode.
[Expert] Check microcode version

After installing the machine, the microcode update is applied. You can validate the microcode version via the console by using the following command:

x86info -a | grep -i micro

Which should output something like:

Microcode patch level: 0x800126f

Usually manufactures publish a list of patch levels, for example AMD’s patches can be found in the linux source tree.


Caching Proxy
../_images/forward_proxy.png

Note

Make sure to install os-squid via System ‣ Firmware ‣ Plugins in order to use the web proxy. As of OPNsense 24.1, the proxy is no longer included in the default installation.

OPNsense is equipped with a fully featured forward caching (transparent) proxy. A caching proxy reduces bandwidth and improves response times by caching and reusing frequently-requested web pages. The Access Control Lists can be utilized for user authentication and or as (category based) web filter.

Features include:

    Multi Interface Support

    Transparent Mode (including SSL/HTTPS)

    ICAP Support for Anti Virus/Malware Engine

    HTTP Proxy

    FTP Proxy

    User Authentication

    Access Control Lists (valid for both http(s) and ftp)

    (Compressed) Blacklist

    Category Based Web Filtering

    Can be combined with traffic shaper

Authenticators

User authentication can be done using OPNsense standard and built-in authenticators. Currently these include:

    LDAP (incl. Microsoft Active Directory)

    Radius

    Local user manager

    No authentication

These options can be found in the Web Proxy -> Administration -> Forward Proxy -> Authentication Settings section.
Access Control

OPNsense supports fine grained access control, which can be configured in Web Proxy -> Administration -> Forward Proxy -> Access Control List containing the following (Advanced) options:

    Subnets

    Ports

    MIME types

    Banned IP’s

    Whitelists

    Blacklists

    Browser/User Agents

Traffic Management

The proxy can be combined with the traffic shaper and take full advantage of its shaping features. Additionally it includes its own options:

    Maximum download size

    Maximum upload size

    Overall bandwidth throttling

    Per host bandwidth throttling

These options can be found in the Web Proxy -> Administration -> General Proxy Settings -> Traffic Management Settings section.
Category Based Web Filter

No need for additional plugins, such as squidGuard - as OPNsense has built-in category based web filter support. Main features include:

    Fetch from a remote URL

    Supports flat file list and category based compressed lists

    Automatically convert category based blacklists to squid ACLs

    Keep up to date with the built-in scheduler

    Compatible with most popular blacklist

Transparent Mode

The transparent mode means all requests will be diverted to the proxy without any configuration on your client. Transparent mode works very well with unsecured http requests, however with secured (SSL) HTTPS connection the proxy will become a man-in-the-middle as the client will “talk” to the proxy and the proxy will encrypt the traffic with its master key that the client is required to trust.

Warning

Using a transparent HTTPS proxy can be a dangerous practice and may not be allowed by the services you use, for instance e-banking.
WPAD And PAC

If a transparent proxy cannot be used, OPNsense still supports automatic proxy configuration via WPAD / PAC.

Warning

WPAD via DNS requires the web interface to run on the default HTTP port (TCP/80) which is also a security risk (MITM attacks). In such cases you should proxy the connection or avoid configuring the applicance from an untrusted network.
Custom error pages

Error pages can be customized for your own needs. In order to do so, go to Web Proxy -> Administration -> General Proxy Settings and select “Custom” in “User error pages”, after which an additional tab will be visible named “Error Pages”.
Go to this tab and use the top download icon to receive a zip file containing all available error pages and associated cascading style sheets.

After altering the files, zip them again and upload using the file selector option on the same tab followed by the upload button .

The reset button can be used to remove your custom template from the configuration, after which the download option would return the standard OPNsense template.

There are some rules to take into account when creating custom themed error pages:

    extend the errorpage.css file to theme your pages

    make sure error pages don’t require anything else than css, images should be converted to base64 and provided inline. Not only is this faster to handle than separate image files it also prevents rendering issues in case images can’t be accessed.

    only existing error pages will be processed, if filenames won’t match, the files won’t be written to disk. you can use the download button to inspect what’s being deployed (it will return a combined set of custom and standard files)

    it’s best not to include files that are not altered, this saves room in the configurartion and prevents defauls from being overwritten.

Tip

If you only want to change the background image, it’s usually enough to upload the css file in a directory and leave out all the html files.

Tip

To convert images to inline base64 tags, there are quite some online tools available, which can easily be found using google. As an example, our logo can be found in the the css file looking like background: url('data:image/svg+xml;base64,PD9...) no-repeat left;
Configuration / How-tos

More information on how to utilize OPNsense’s proxy service can be found in:

    Advanced Proxy access management
    Setup Caching Proxy
    Setup a Guest Network
    Setup WPAD / PAC
    Setup Anti Virus Protection
    Setup Anti Virus Protection using OPNsense Plugins
    Setup Transparent Proxy
    Setup Web Filtering


Advanced Proxy access management

As part of the OPNsense Business Edition, Deciso offers a plugin to add fine grained access control to your existing web proxy setup.

One of the features often requested is to easily (dis)allow (groups of) users access to certain domain or url parts, the OPNProxy plugin addition offers this functionality at ease.
Prerequisites

Before installing and using this plugin, make sure your web proxy is configured and enabled including some sort of authentication (unless network only authentication should be used).

Note

To enable authentication, goto Services->Web Proxy->Administration then collapse “Forward Proxy” and choose “Authentication Settings”. Choose a method and apply settings.

Note

In order for authentication scheme’s to work, users do need to exist in the firewall. You can either import them (when using ldap) or make sure the same username exists locally to map groups too.

Warning

Do not install other plugins or configuration files hooking into the proxy as these might interfere with the working of the system.
Installation

Installation of this plugin is rather easy, go to System ‣ Firmware ‣ Plugins and search for os-OPNProxy, use the [+] button to install it.

Next go to Services ‣ Web Proxy ‣ Access control to start configuring polcies.

Note

Redis is required for this plugin to operate, when accessing the access control settings page for the first time you will be pointed to the correct setting to enable it directly. (just enable and apply should be enough)
General

In order to utilise user/group based policies, the proxy needs to be able to inspect the traffic and know the identity of the user.

Since most of the internet is being encrypted nowadays, you would need to enable some sort of ssl inspection in between. When setting “Enable SSL inspection” in Services -> Webproxy -> Administration -> Forward Proxy you are able to use a “man-in-the-middle” approach (where the proxy intercepts traffic and is able to filter it). A disadvantage of this option is that your clients would need to trust the firewalls certificate (CA selected in “CA to use”). When enabled full paths can be filtered.

A bit lighter option would be to use SSL inspection with “Log SNI information only” enabled, in which case the firewall would know which domain you are trying to visit, but can not inspect the content of the request (or response for that matter).

Note

When enabling “Log SNI information only”, only domain based policies will be usable for SSL/TLS based requests.

The standard authentication options available in OPNsense apply, which can be configured in Services -> Webproxy -> Administration -> Forward Proxy -> Authentication settings. Please make sure to import/add the users in OPNsense in order to user their authorisation settings (existence and group membership).

Note

Standard (global) policies take precedence over the ones defined in the access control plugin, this includes “SSL no bump sites” when full TLS/SSL inspection is used. (it’s not possible to block no bump sites in full inspection mode)
Transparant proxies

It is possible to use the proxy in transparant mode, but there are some constraints and ceveats to take into account when doing so. This paragraph tries to explain them one by one.

    Using “Log SNI information only” is not supported in a useful way. As the browser is not aware of the proxy, it will request access to an ip address in stead of a hostname. With full intercept mode, this is not really an issue as the next request will be the actual question and does contain the hostname, but without interception, you can only filter on ip address which is often not very useful.

    The client has to trust the CA which the proxy uses to automatically create certificates, which means all TLS requests will be signed by the firewall instead of the actual trustee.

    User based authentication is not possible, as the client doesn’t know it’s being intercepted, it’s also not possible to request a username and password. OPNproxy only supports basic authentication.

Note

When changing the “Log SNI information only” option, you have to restart the proxy as well. As the apply button will not reload the proxy in full.
Authentication options

Every policy defined in this plugin can contain users/groups and/or networks, if one option is omitted from the input its being ignored, when both are specified, both should apply.
../_images/OPNproxy_policy_auth_selection.png

Example usage scenarios:

    User X from network Y is not allowed to visit gambling websites

    All users from group Z are not allowed to visit gambling websites

    All users in network Y are allowed to visit the OPNsense website.

    All users in network Y are not allowed to visit gaming websites. (two policies)

Note

When not using user based authentication (network only), the default policy is deny so you would need to add at least one policy accepting traffic in these cases.
Policy types

Part of OPNproxy is a standard list of categorized locations, which can be easily added to a policy, these type of policies are the default ones. You will find categories here like adult, advertisements, malware and many others.

In some cases however our defaults are not enough, for this reason we also offer the posibility to push your own list of domains and locations into a custom policy.

Every policy contains what to match (either a standard category or a list of domains and paths), what to do (allow or deny) and an audience (the users and/or groups the policy applies to).

Since both users and groups can be selected within the same policy, we choose to prefix users with a *.

Prioritisation within our access control is quite easy and should cover all possible scenarios, below the order in which decisions are made:

    No policy, default allow. When authentication is properly setup, this means that access depends on supplying valid credentials.

    Explicit allow, the closest matching policy (see text below) returns accept, access will be granted (also when another policy returns deny)

    Explicit deny, the closest matching policy returns deny, access will be denied

Closest matching explained

One of the key features of our access control system is a method to find the best suitable policy for the requested domain or url.

This means that if someone defines two ACL’s one denying access to all google.nl subdomains (.google.nl) and one allowing access to the favicon on the page www.google.nl/favicon.ico, only access to favicon.ico is allowed on the google.nl website.

If one of our default policies contains a website you still want to allow, you can easily add the domain (with or without path) to another policy to still grant access. This is one of the main reasons we prioritise allow over deny in these policies.
Custom policies

Custom policies are defined as lists of domains with optional paths using one line per item. When domain policies should include subdomains, they should be prefixed with a point (.), e.g. .nl matches all dutch top level domains.

Some companies use very strict policies, in which case one should only be allowed to access specific domains. For this case we added a special wildcard (*). When set in a policy it will mark the absolute top level domain.

Tip

If one should only be allowed to access pkg.opnsense.org you would create two policies, one containing a deny policy on * and one containing an allow policy on pkg.opnsense.org.
Using the policy tester

When doubting if a specific location would be accessible by a user, one can always use the included ACL tester. Although mainly used for debugging purposes, it will easily inform you about the decision the webproxy will take when using our acl’s.

The policy tester contains two fields and a test button, just enter a username followed by a url (e.g. https://www.google.nl/) and hit the test button. Depending on settings it will return a response like:

{
  "message": "ERR message=\"reason:c1380754-e14b-4dc7-bcf9-96307450c025 policy_type:custom\" user=\"root\"\n",
  "user": {
    "uid": "root",
    "id": "0",
    "applies_on": [
      "u:root",
      "g:admins"
    ]
  },
  "policy": {
    "action": "deny",
    "id": "c1380754-e14b-4dc7-bcf9-96307450c025",
    "applies_on": [
      "g:admins"
    ],
    "policy_type": "custom",
    "description": "test_custom2",
    "path": "/",
    "wildcard": true,
    "domain": "google.nl"
  }
}

Which informs you about all settings relevant for the lookup, the message returned (to squid), the user found and the policy matched using the rules described earlier.
Auto update supplied policies

In order to update the default type policies automatically, you can install a cron job in System ‣ Settings ‣ Cron. Search for OPNProxy apply policies and schedule once a day.

Warning

Do not execute this job more than once a day as this will add load to your machine without changing anything. Our dataset is updated every day.


Setup Caching Proxy
../../_images/proxy_basics.png
Enable / Disable

The proxy is delivered with sane default settings for easy setup. To enable the proxy just go to Services ‣ Web Proxy ‣ Administration and check Enable proxy then click on Apply. The default will enable the proxy with User Authentication based on the local user database and runs on port 3128 of the lan interface.
Change Proxy Interfaces

If you want to change the interfaces (subnets) the proxy will bind to then click on the tab Forward Proxy. Now add/remove the interfaces in the Proxy interfaces field.
Change Proxy Listening Port

By default the proxy will listen at port 3128, you can change this by clicking on the tab Forward Proxy and fill in the port in the Proxy port field. Don’t forget to Apply your changes.
Enable Cache

To enable caching click on the arrow next to the General Proxy Settings to see the dropdown menu and click on Local Cache Settings.
../../_images/proxy_cache.png

Check the Enable local cache and click Apply.

Important

As the cache is not created by default you will need to stop and start the service under System ‣ Diagnostics ‣ Services, this will ensure correct creation of the cache.
Advanced

Under the advanced settings (see mode switch on left top of the form) you can change the cache size, directory structure and max object size to keep in cache. Again defaults are fine for normal browsing and creates a 100 MB cache with max 4 MB object size.
Change Authentication Method

Click on the arrow next to the Forward Proxy tab to show the drop down menu. Now select Authentication Settings and select the desired Authenticator(s) in the field Authentication method. Click on Clear All if you do not want to use any authentication.

Depending on the Authentication Servers you have setup under System ‣ Access ‣ Servers You can select one or more of the following:

    No Authentication (leave field blank)

    Local User Database

    LDAP

    Radius

FTP Proxy

To enable the FTP Proxy click on the arrow next to the Forward Proxy tab to show the drop down menu. Now select FTP Proxy Settings and select one or more interfaces in the FTP proxy interfaces field and Apply.

Note

The FTP proxy will only function if the Proxy Server itself is enabled. And the proxy only works for non encrypted ftp traffic.
Access Control List

You can setup ACLs by clicking on the arrow next to Forward Proxy and select Access Control List. Here you can:

    Setup Allowed Subnets (By default the proxy interfaces will be allowed)

    Add Unrestricted IP addresses (Unrestricted means just that, no authentication and no blacklisting for those IPs)

    Add Banned hosts IP address (A ban will stop this client from being able to use the proxy)

    Whitelist (Click on the (i) to see examples, whitelist prevail above blacklists)

    Blacklist (If not allowed by a whitelist, this will block traffic based upon a regular expression)

Warning

Don’t forget to press Enter or a comma after filling in a tag field as otherwise the value will not be applied. It should look similar to:
../../_images/proxy_tag.png
Remote Black List / Ad Blocking

Use simple flat files to block ads. For this sample we will use the ad list found here:

http://pgl.yoyo.org/adservers/serverlist.php?hostformat=nohtml

This list is a simple flat list that looks like this:

101com.com
101order.com
123found.com
180hits.de
180searchassistant.com
1x1rank.com
207.net
247media.com

Go to Services ‣ Web Proxy ‣ Administration and click on the tab Remote Access Control Lists

Now click on the + at the bottom right corner of the form to add a new list.

Fill in:

Enabled
	

Checked
	

Enable/Disable

Filename
	

yoyoads
	

Choose a unique filename

URL
	

(copy/paste the URL)
	

The URL of the blacklist

categories
	

(Leave blank)
	

Used for Category based web filtering

Description
	

Yoyo Ads Blacklist
	

Your description

Looks like (screenshots of version 16.1.4):
../../_images/proxy_blacklist.png

Save changes

Now click on Download ACLSs & Apply to enable the blacklist/ad blocker.
Firewall Rule No Proxy Bypass

To make sure no-one can bypass the proxy you need to add a firewall rule. Go to Firewall ‣ Rules and add the following to the top of the list rule on the LAN interface (if LAN is where your clients and proxy are on).

Action
	

Block

Interface
	

LAN

Protocol
	

TCP/UDP

Source
	

LAN net

Destination Port Range
	

HTTP

Category
	

Block Proxy Bypass

Description
	

Block HTTP bypass

Save

And one more rule to block HTTPS access:

Action
	

Block

Interface
	

LAN

Protocol
	

TCP/UDP

Source
	

LAN net

Destination Port Range
	

HTTPS

Category
	

Block Proxy Bypass

Description
	

Block HTTPS bypass

Save & Apply changes
../../_images/proxy_firewall.png
Configure Browser/Firefox

To configure you browser for use with the proxy, just go to your network settings and configure a proxy like this in firefox:
../../_images/proxy_firefox.png

For a set-for-step guide on full category based web filtering see Setup Web Filtering.


Setup WPAD / PAC
PAC
Introduction

OPNsense supports generating PAC files to provide automatic proxy configuration files to clients. For example if your web GUI is running at http://192.168.0.1/, your PAC URL will be http://192.168.0.1/wpad.dat.

In Firefox you can configure your proxy using PAC by the following steps manually:

    Click the menu Icon and open “Settings”

    Scroll down to “Network Proxy” and click “Settings”

    Check “Automatic Proxy Configuration Address”

    Enter the URL of the PAC file like mentioned in the paragraph above into the text field and click “OK”

Warning

Your browser may be unable to connect to the internet if the PAC file is not available. This type of configuration is not recommended on mobile devices like laptops if employees can use the devices for home office. For such devices WPAD should be used.
Configuring PAC
First Step: Creating Matches

Go to Services ‣ Proxy ‣ Configuration and open Match
../../_images/pac_menu_match.png

Enter a name for the match and an optional description. Then choose what to match on. In our example we want to achieve that hostnames without a FQDN (like server01) and also our internal domain (example.com) will be excluded from the proxy.

Name
	

A unique name for the match to call it from rules.

Description
	

A short description for your own reference.

Negate
	

Inverts the match (any that does not match)

Match Type
	

Choose what you want to match on

The rest of the fields depend on the used Match Type. For example if we match on “Plain Hostname”, we do not need any additional parameters.

The match “Plain Hostname means no dots inside the domain so if we want to create a fqdn match, we can simply invert this:
../../_images/pac_match_fqdn.png

Name
	

is_fqdn

Description
	

can stay empty

Negate
	

checked

Match Type
	

Plain Hostname
../../_images/pac_internal_domain.png

Name
	

not_internal

Description
	

can stay empty

Negate
	

checked

Match Type
	

Hostname matches

Host Pattern
	

Wildcard for your internal domain
Second Step: Create Proxy Servers

Now switch to PAC ‣ Proxies and add new proxy servers.

Name
	

Enter a name which will be shown at the rules view for selection

Description
	

You can add an optional description for this proxy

Proxy Type
	

Enter a Proxy type or DIRECT if no proxy should be used

URL
	

Enter the Proxy URL unless DIRECT has been choosen

In this case it is assumed that only a single LAN and a DMZ exists and that internal connections should not run over the proxy. To make meaningful rules, we need two possible return values:

    The LAN Proxy

    No Proxy

No proxy is quite simple to configure:
../../_images/pac_proxy_direct.png

Name
	

direct

Description
	

can stay empty

Proxy Type
	

Direct Connection

URL
	

empty

For outgoing connectins we need the proxy:
../../_images/pac_proxy_lan.png

Name
	

lan_proxy

Description
	

can stay empty

Proxy Type
	

Proxy

URL
	

Proxy IP + ‘:’ + Proxy Port
Third Step: Create Rules

Now as the matches and the proxies exist, rules can be built. For that, switching to PAC ‣ Rules is required.

Now the following rule needs to be created:
../../_images/pac_rule.png

Enabled
	

checked

Description
	

a description for your reference

Matches
	

the two previously created matches

Join Type
	

And

Match Type
	

If

Proxies
	

Select the LAN proxy

Click the orange reload button and you are done.
WPAD

Web Proxy Auto Discovery is used to find the PAC file for the domain.
Using DNS (Unbound)
Variant 1: Automatic Configuration

Warning

When you use this option, the wpad hosts and the TXT records for the domain will be overridden. This may break some other records like TXT records for SPF for this particular domain.

In Unbound, you can simply check the following checkbox:
../../_images/wpad_dns_unbound2.png

This will define the host records of any domain configured in DHCP as CNAME for your firewall host. It will also override TXT records resolve to the URL to the PAC file.
Variant 2: Manual Configuration

Warning

When DNS is used, OPNsense must respond via HTTP on port 80.

Open the page Services ‣ Unbound DNS ‣ Overrides and add a new host override for the wpad host:
../../_images/wpad_dns_unbound.png

Host
	

wpad

Domain
	

your domain

Type
	

A or AAAA

IP
	

IP of your OPNsense (where the Web interface is reachable

Description
	

can stay empty

Save the settings and apply the changes.
Using DHCP
Variant 1: Automatic Configuration

In the DHCP server settings, you can check the following checkbox:
../../_images/wpad_dhcp.png

In this case, an entry for the protocol and the port of the web interface will be created with the domain you choose in your system settings (domain of the firewall). The hostname is wpad. If you are running the OPNsense web interface on port 80 with HTTP. The following URL will be created:

    http://wpad.example.com:80/wpad.dat

Warning

If you have HTTP Redirect enabled via System ‣ Settings ‣ Administration, make sure your browser accepts the certificate presented by OPNsense, as it won’t download wpad.dat if the certificate is untrusted.
Variant 2: Manual Configuration

Open the page Services ‣ DHCP ‣ Server, select the correct interface and scroll down to the “Additional Options”.

Add this line and save:
../../_images/wpad_dhcp_option.png

Number
	

252

Type
	

String

Value
	

PAC file URL enclosed in double quotes
Firefox Configuration
Open Settings Menu

First, the settings menu must be opened. There are two ways. You can either
../../_images/pac_firefox_menu.png

first click Edit
../../_images/pac_firefox_edit.png

then click Preferences or you can also
../../_images/pac_firefox_menu2.png

click the menu icon and then click Preferences.
Configure Proxy
../../_images/pac_firefox_network_proxy_setting.png

Then scroll down to the bottom of the page and click Settings in the Network Proxy settings.
../../_images/pac_firefox_proxy_settings.png

In the newly opened window, you can setup your proxy settings. If you want to force Firefox to use WPAD/PAC, choose Auto-detect proxy settings for this Network. Click save and you are done.


Setup Anti Virus Protection

OPNsense can offer HTTP and HTTPS protection by utilizing its highly flexible proxy and the industry standard ICAP. An external engine from one of the known vendors is used to offer maximum protection against malware, such as ransomware, trojans and viruses. This protection can be further enhanced by the built-in Intrusion Prevention System and Category Based Web filtering.

This How To will utilize Symantec’s Protection Engine, but any other vendor that support ICAP will work just as well.

Note

The Anti Virus Engine can protect you against malicious websites and infected file downloads, it does not protect the local clients. Therefore it is always a good idea to install a client based solution as well to protect against other forms of infection such as through emails or usb stick.
../../_images/SPE_home.png
Step 1 - Setup the Proxy

Start with setting up the proxy with its basic configuration, see Setup Caching Proxy.
Step 2 - Setup Transparent Mode

To setup the transparent mode, see: Setup Transparent Proxy.
Step 3 - Configure the Engine

For this example we have used Symantecs Protection Engine. The installation is straight forward, please refer to Symantecs documentation for full installation and configuration instructions.

We installed the Engine for Web Proxy purpose and enabled ICAP with its default settings.
../../_images/SPE_ICAP.png
Step 4 - Connect the Engine

Now connect the server that the engine is installed on to OPNsense trough either a switch or a direct cable connection. Preferable use a separate network for this traffic to make sure the unencrypted ICAP traffic can’t be tapped.

Note

ICAP traffic is not encrypted, meaning you have to make sure the traffic is not visible to anyone else. When using transparent HTTPS mode it is best to configure a separate interface for ICAP traffic and connect the Server (Engine) directly with a crosslink cable. Alternatively one may use a VLAN for this purpose.
Step 5 - Configure ICAP

To configure ICAP go to Services ‣ Proxy ‣ Administration and select ICAP Settings for the Forward Proxy tab.

Select enable ICAP and filling the Request and Response URLs. For Symantecs Protection Engine they look like this:

Request Modify URL
	

icap://192.168.2.1:1344/avscanreq

Response Modify URL
	

icap://191.168.2.1:1344/avscan

Now click on Apply
Step 6 - Test using EICAR

To test if the engine is operational and functional go to http://pkg.opnsense.org/test/eicar.com.txt on this page you will find a file with the eiacar test string.

First test the HTTP protocol version. If that works, test the HTTPS version if you have also configured the transparent SSL proxy mode.

Warning

IMPORTANT NOTE : YOU DOWNLOAD THESE FILES AT YOUR OWN RISK!

If everything went well you should see something similar to this in you browser:

The content you just requested contains EICAR Test String and was blocked by the
Symantec Protection Engine based on local administrator settings. Contact your
local administrator for further information.

DONE


Setup Anti Virus Protection using OPNsense Plugins

OPNsense can offer HTTP and HTTPS protection by utilizing its highly flexible proxy and the industry standard ICAP. An external engine from one of the known vendors is used to offer maximum protection against malware, such as ransomware, trojans and viruses. This protection can be further enhanced by the built-in Intrusion Prevention System and Category Based Web filtering.

This How To will use the Plugins C-ICAP and ClamAV.

Note

The Anti Virus Engine can protect you against malicious websites and infected file downloads, it does not protect the local clients. Therefore it is always a good idea to install a client based solution as well to protect against other forms of infection such as through emails or usb stick if they are not analyzed as well.

Note

Note that there is still another attack vector called social engineering. Most attacks would fail without the help of an internal human whose trust is exploited. An active scanner is only a part of the security concept.
Step 1 - Setup the Proxy

Start with setting up the proxy with its basic configuration, see Setup Caching Proxy.
Step 2 - Setup Transparent Mode

To setup the transparent mode, see: Setup Transparent Proxy.
Step 3 - Install and Configure the ClamAV and the C-ICAP plugins

Note

The defaults from c-icap and ClamAV (vendor defaults) are used. Please keep in mind that changing may affect security or performance. If you don’t know how a setting is affecting your network, you should keep it at the default.

    ClamAV

    c-icap

Step 4 - Configure ICAP

To configure ICAP go to Services ‣ Proxy ‣ Administration and select ICAP Settings for the Forward Proxy tab.

Select enable ICAP and filling the Request and Response URLs. For the C-ICAP plugin, the default URLs will be:

Request Modify URL
	

icap://[::1]:1344/avscan

Response Modify URL
	

icap://[::1]:1344/avscan

Now click on Apply
Step 5 - Test using EICAR

To test if the engine is operational and functional go to http://pkg.opnsense.org/test/eicar.com.txt on this page you will find a file with the eiacar test string.

First test the HTTP protocol version. If that works, test the HTTPS version if you have also configured the transparent SSL proxy mode.

Warning

IMPORTANT NOTE : YOU DOWNLOAD THESE FILES AT YOUR OWN RISK!

DONE


Setup Transparent Proxy

OPNsense offers a powerful proxy that can be used in combination with category based web filtering and any ICAP capable anti virus/malware engine. The proxy can be configured to run in transparent mode, this mean the clients browser does not have to be configured for the web proxy, but all traffic is diverted to the proxy automatically by utilizing Network Address Translation.

In this How To, we will explain the basic HTTP as well as HTTPS (SSL bump) transparent proxy modes.

Warning

The Transparent SSL/HTTPS proxy mode uses a technique also called man-in-the-middle, only configure and use this if you know what you are doing. When configured incorrectly you may end up in lessening your security defenses significantly instead of enhancing them. Using a transparent HTTPS proxy can be a dangerous practice and may not be allowed by the services you use, for instance e-banking.
Step 1 - Basic Proxy Setup

To setup the transparent mode(s) a functional basic proxy setup is required. For basic configuration please refer to Setup Caching Proxy.
Step 2 - Transparent HTTP

Go to Services ‣ Web Proxy ‣ Administration

Then select General Forward Settings under the Forward Proxy Tab.

Select Enable Transparent HTTP proxy And Click Apply.
Step 3 - NAT/Firewall Rule

A simple way to add the NAT/Firewall Rule is to click the (i) icon on the left of the Enable Transparent HTTP proxy option and click on add a new firewall rule.
../../_images/screenshot_enable_transparent_http.png

For reference, these are the default settings:

Interface
	

LAN

TCP/IP VERSION
	

IPv4

Protocol
	

TCP

Source
	

LAN net

Source port range
	

any - any

Destination
	

any

Destination port range
	

HTTP - HTTP

Redirect target IP
	

127.0.0.1

Redirect target port
	

other/3128

Description
	

redirect traffic to proxy

NAT reflection
	

Enable

Filter rule association
	

Add associated filter rule

The defaults should be alright, just press Save and Apply Changes.
Step 4 - CA for Transparent SSL

Before we can setup transparent SSL/HTTPS proxy we need to create a Certificate Authority. Go to System ‣ Trust ‣ Authorities or use the search box to get there fast.
../../_images/search_ca.png

Click on add or import ca in the upper right corner of the screen to create a new CA.

For our example we use the following data:

Descriptive name
	

OPNsense-SSL

Method
	

Create an internal Certificate Authority

Key length (bits)
	

2048

Digest Algorithm
	

SHA256

Lifetime (days)
	

356

Country Code
	

NL (Netherlands)

State or Province
	

Zuid Holland

City
	

Middelharnis

Organization
	

OPNsense

Email Address
	

spam@opnsense.org

Common Name
	

opnsense-ssl-ca

Save
Step 5 - Transparent SSL

Go to Services ‣ Web Proxy ‣ Administration Then select General Forward Settings under the Forward Proxy Tab.

Select Enable SSL mode and set CA to use to the CA you have just created. Then Click Apply.
Step 6 - Configure No SSL Bump

This step is very important and requires careful consideration! To make sure that known sites are not bumped and keep their original security layer intact, one needs to add those including all subdomain to the SSL no bump sites field.

To enter a new item type in the field and hit enter to accept. start with a . (dot) to add all subdomains as well. Example: To add all of paypal.com , type .paypal.com and hit enter.

Note

Make sure that all banking sites and sites that you provide personal or login information for are added to this field. If you are not sure what to add, please reconsider using transparent SSL as its clearly not intended for you!
Step 7 - SSL NAT/Firewall Rule

A simple way to add the NAT/Firewall Rule is to click on the (i) icon on the left of the Enable SSL mode option and click on add a new firewall rule.
../../_images/screenshot_enable_transparent_http.png

For reference, these are the default settings:

Interface
	

LAN

TCP/IP VERSION
	

IPv4

Protocol
	

TCP

Source
	

LAN net

Source port range
	

any - any

Destination
	

any

Destination port range
	

HTTPS - HTTPS

Redirect target IP
	

127.0.0.1

Redirect target port
	

other/3129

Description
	

redirect traffic to proxy

NAT reflection
	

Enable

Filter rule association
	

Add associated filter rule

The defaults should be alright, just press Save and Apply Changes.
Step 8 - Configure OS/Browser

Since the CA is not trusted by your browser, you will get a message about this for each page you visit. To solve this you can import the Key into your OS and set as trusted. To export the Key go to System ‣ Trust ‣ Authorities and click on the icon to export the CA certificate. Of course one may choose to accept the certificate for each page manually, but for some pages that may not work well unless not bumped.
../../_images/export_CA_cert.png

Import and change trust settings on your favorite OS. For example, on macOS it looks like this:
../../_images/Trust_Settings_OSX.png

Warning

Again be very careful with this as your system will accept any page signed with this CA certificate. As long as no-one gains access to the private key that is no problem, but if any one can get a get a hold of it then all traffic can be decrypted except those in the do not bump list. You have been warned!

Note

On Android devices, you may get notified about the device being unable to access the internet. This happens because the certificates are pinned to protect the connection against man in the middle attacks otherwise trusted certificates. If you want to make the connection work again, you have to whitelist the following Google domains in your “No Bump Hosts” settings.

    Your local Google domain (for example: google.at for Austria, google.de for Germany, …)

    .google.com

    .googleapis.com

    .gstatic.com

    .1e100.net

DONE


Setup Web Filtering

Category based web filtering in OPNsense is done by utilizing the built-in proxy and one of the freely available or commercial blacklists.

For this this How-to we will utilize the UT1 “web categorization list” from the Université Toulouse managed by Fabrice Prigent. This list is supplied for free under the Creative Commons license.

Other popular lists that are expected to work well with OPNsense are:

    URLBlacklist.com <http://urlblacklist.com/>

        Commercial paid service

    Squidblacklist.org <http://www.squidblacklist.org/>

        Commercial paid service

For this tutorial we will assume:

    Proxy has its default settings / is not configured

    We only want web filtering and nothing else (no caching, no authentication)

Note

For other general/basic setup item of the proxy see Setup Caching Proxy
Step 1 - Disable Authentication

To start go to Services ‣ Web Proxy ‣ Administration.

Click on the arrow next to the Forward Proxy tab to show the drop down menu. Now select Authentication Settings and click on Clear All to disable user authentication. And click Apply to save the change.
Step 2 - Configure Blacklist

Click on the tab Remote Access Control Lists. Now click on the + in the lower right corner of the from to add a new list.

A screen will popup, enter the following details:

Enabled
	

Checked
	

Enable/Disable

Filename
	

UT1
	

Choose a unique filename

URL
	

(copy/paste the URL)
	

The URL of the blacklist

categories
	

(Leave blank)
	

If left blank the full list will be fetched

Description
	

UT1 web filter
	

Your description

The URL of the full compressed UT1 category based list is:

    ftp://ftp.ut-capitole.fr/pub/reseau/cache/squidguard_contrib/blacklists.tar.gz

Note

If you want to add self-hosted lists, be sure to not use the file extensions .doc, .pdf or .txt.
../../_images/proxy_ut1.png

Press Save Changes.
Step 3 - Download the Categories

Now press Download ACLs, please note that this will take a while (can be several minutes) as the full list (>19 MB) will be converted to squid ACLs.
Step 4 - Setup Categories

Now we can select the categories we want to use by clicking on the pencil icon next to the description of the list. This will open the edit window again, but now you will see all available categories extracted from the list.
../../_images/proxy_categories.png

For our example we will filter ads and adult content. The easiest way to do so is clear the list and select the following from the drop down list:
../../_images/proxy_catgegory.png

Now Save changes and press Download ACLs again to download and reconstruct the list with only the selected categories. This will take roughly the same amount of time as the first fetch as the adult alone section is ~15 MB.
Step 5 - Enable Proxy

To enable the proxy just go to Services ‣ Proxy Server ‣ Administration and check Enable proxy en click on Apply. The proxy will bind to LAN and port 3128.

It may take a while for the proxy to start and the play icon on the top right corner of the screen will turn red. Refresh the page to see if the proxy is done loading (play icon will turn green).
Step 6 - Disable Proxy Bypass

To make sure no-one can bypass the proxy you need to add a firewall rule. Go to Firewall ‣ Rules and add the following to the top of the list rule on the LAN interface (if LAN is where your clients and proxy are on).

Action
	

Block

Interface
	

LAN

Protocol
	

TCP/UDP

Source
	

LAN net

Destination Port Range
	

HTTP

Category
	

Block Proxy Bypass

Description
	

Block HTTP bypass

Save

And one more rule to block HTTPS access:

Action
	

Block

Interface
	

LAN

Protocol
	

TCP/UDP

Source
	

LAN net

Destination Port Range
	

HTTPS

Category
	

Block Proxy Bypass

Description
	

Block HTTPS bypass

Save & Apply changes
../../_images/proxy_firewall.png


FreeRADIUS
Installation

First of all, you have to install the FreeRADIUS plugin (os-freeradius) from the plugins view.
../../_images/menu_plugins.png

After a page reload you will get a new menu entry under services for FreeRADIUS. Select and a submenu will pop up with the entries General, User and Client:
General Settings
../../_images/freeradius_general.png

Enable

    To enable the service, you have to check this box.
Enable VLAN assignment

    If you check this box, the RADIUS packets will have some unencrypted tags for the network device to allow dynamic VLAN assignment. In this case, the authentication is still encrypted but some metadata will be readable. You need to enable this checkbox, if you want to set a VLAN on a switchport, which depends on the authenticated user.

Users
../../_images/freeradius_users.png

A user is an entity, which is meant to authenticate against the RADIUS server (computer or human).

To create a user, click the + button.
../../_images/freeradius_edit_user.png

Enabled

    This user will be written to disk and can be used. You can toggle this value to temporary disable users.
Username

    The name which the user will use to authenticate.
Password

    The password the user will use to authenticate.
Description

    Internal information for you to use to find the user. This setting can be used to add some infos like a department.
IP Address and Subnetmask

    If you want to use FreeRADIUS for point to point links, you can add an IP address here which will be assigned to the client. The same is valid for Subnetmask.
VLAN ID

    A layer 2 device like a switch, which supports 802.1X authentication can use this Field to dynamically assign an VLAN number to a switchport based on the authentication result. This is especially useful if you are having moving users (for example if an employee can attach his computer to a docking station at a desk and the switch will assign the VLAN ID of the employee to the switchport. Be aware that the Layer 2 device has to be able to read this information, which means that you have to enable corresponding option in General

Clients
../../_images/freeradius_clients.png

A client in RADIUS is a intermediate device / network device like a VPN gateway, a switch or an access point.

To create a new client, click the + button:
../../_images/freeradius_edit_client.png

Enabled

    This client will be written to disk and can be used. You can toggle this value to temporary disable clients.
Name

    A name used for the client.
Secret

    The secret is used to provide a trust relationship between the client and the FreeRADIUS server. This password should be strong as you only have to type it twice (once in the FreeRADIUS configuration and once in your client configuration) or even copy it. If the passwords do not match, FreeRADIUS will reject all attempts to authenticate.
IP Address or Network with CIDR

    This is the IP address of the Client (not the authenticating device). For example this could be the IP address of your switch.


Setup FreeRADIUS for accounting
Goal of this tutorial

This tutorial can be used to test your Captive portal setup with radius accounting, it’s not intended to use for production setups (because we only use simple flat files for everything). We used Ubuntu linux for this setup, a different operating system might result in some paths being different.

User limits on the OPNsense firewall are set right after login, the Radius server should tell the firewall how many resources are left for the user that logged in successfully. A normal login sequence look like this:

[login] -> [send accounting start] -> [send interim updates while connected] -> [on logout, send accounting stop]
Setup

To setup freeradius in ubuntu, execute the following command:

apt-get install freeradius

Arrange client access

Edit the file /etc/freeradius/clients.conf and append a block for your network, as sample we will use 10.211.55.0/24.

client 10.211.55.0/24 {
    secret      = testing123
    shortname   = test-network
 }

Enable daily session limits

Enable daily session limits, which needs accounting to signal the clients use.

    In /etc/freeradius/sites-available/default uncomment daily in authorize and accounting sections.

    in /etc/freeradius/radiusd.conf uncomment daily in the instantiate section

    append to /etc/freeradius/dictionary

ATTRIBUTE       Daily-Session-Time      3000    integer
ATTRIBUTE       Max-Daily-Session       3001    integer

    uncomment sradutmp in the accounting section, to be able to use the radwho command.

Add test users

You can add your test users to /etc/freeradius/users, they should look like this:

"test" Cleartext-Password := "test", Max-Daily-Session := 1800
        Framed-IP-Address = 10.211.55.100,
        Reply-Message = "Hello, %{User-Name}"

Make sure the second and third lines are indented by a single tab character.

This should result in a user with a maxim use per day of 1800 seconds.
Test radius

For the initial test, it might be practical to debug the traffic going in and out from Freeradius. The next steps help you start Freeradius in debug mode, without output to console:

/etc/init.d/freeradius stop
freeradius -X


How To: Setting Up A Mail Gateway

Warning

A mail gateway under high load may need a lot of memory and CPU power. Keep in mind that the components have some hardware requirements like the ClamAV- and the Redis plugin. It is not recommended to run this software on weak hardware.
Installation

First of all, you have to install the required plugins from the plugins view.
../../_images/menu_plugins.png

The required plugins are:

    ClamAV

    Postfix

    Redis

    Rspamd

After a page reload you will get some new menu entry under services for all installed plugins.
Configuration Of The Plugins
1. ClamAV

For ClamAV, you can follow the instructions in ClamAV.
2. Redis (optional but recommended)

In the next step, we need to install the Redis database. Redis is required for caching and for some features of the rspamd plugin.

Warning

If you don’t set up a Redis instance, some components of rspamd will automatically disable themself silently and it will not be visible in the GUI.
../../_images/redis_general.png

For a basic Redis instance, you can just check Enable Redis and click Apply to start the servers.
3. Rspamd

First of all, you will need to activate the plugin by checking the Enable rspamd checkbox. If you have installed and configured the Redis plugin, you should check the second checkbox as well.
../../_images/rspamd_general.png

If you are ready, rspamd should be up and running.

Now you should configure the rspamd modules you need.

Note

The ClamAV component does enable or disable itself automatically if it has been configured depending on the ClamAV (clamd) configuration.

For example, if the MX should be checked, the menu for the Spam Protection:
../../_images/rspamd_antispam_menu.png

After a click, you will see the form:
../../_images/rspamd_mx_check.png

In this case the configuration is quite simple: Check Enabled, add a cache expiration time (in Seconds) as well as clicking at the Apply button.
Postfix

First of all, you need to configure the domains you want to forward in the Domains menu.
../../_images/postfix_add_new_domain.png

Enter the values for your mail server in the dialog after clicking +:
../../_images/postfix_add_domain_forward.png

After saving usually the apply button needs to be hit but the server is not running anyway as it needs to be configured first. If you add new domains, you have to hit this button to apply changes.
../../_images/postfix_general_tab.png

In the General tab, the Postfix service must be enabled. If your system settings differ from your system settings, you may override them here. For example overriding the hostname makes sense because you may want to use the hostname which has been configured as the MX host in the DNS.

You shhould keep the checkboxes at the bottom enabled as they enable restrictions, which provide an additional layer of security.

Save the changes and switch to Antispam tab.
../../_images/postfix_antispam_tab.png

Enable the Checkbox and click Save.
Follow Up Tasks

In the next step, you should go to the Firewall menu. Create a new rule to pass port TCP/25 traffic from Any to This Firewall.


Relayd

The relayd plugin offers a load balancer which is capable of handling OSI layer 3 or 7 forwarding services to various backend servers while validating their availability.

One of the main advantages over other forwarding services available for OPNsense is that relayd offers a transparant forwarding mode in layer 3 (redirection), which is lightweight and forwards the unmodified session to the target host.
Types of configuration items

Relayd defines the following types of objects which build up to a virtual server definition.
Hosts

These types define the actual target machines being used in your pool, for basic setups these only define an IP address and a unique name to identify the machine.
Tables

A table defines a list of hosts and acts as a grouping, a single host might be used in multiple tables.
Table check

A table check defines how relayd should determine for a group of hosts if the target is ready to use, this could for example be a simple icmp (ping) test or a more advanced check like requesting an uri from a webserver and check the response code.

By default a list of common checks is installed with the plugin, you can add additional checks later if needed.
Virtual Server

A virtual server is where it all comes together, this type of object defines where to accept traffic from (bind address and port) and how to handle traffic when being recieved.

The server type is one of the most important settings and defines if this virtual host is acting either as a redirection (using the firewall/transparant) or a relay (layer 7 mode).

It is possible to choose two different tables to forward to here, in standard (non advanced mode) only the primary table is visible including settings how traffic should be divided (Scheduler) and hosts should be checked as described earlier.

When a backup is specified, it will be used when all hosts in the primary table are down (according to the configured check).

Tip

If the hosts in the table respond to a different port than the one listening on, make sure to collapse the advanced settings to gain access to the (target) port directive.
Protocols

Protocols are templates defining settings and rules for relays. They allow setting generic TCP options, SSL settings, and rules for the selected application layer protocol.

These are only selectable in advanced view mode, for documentation we refer to the relayd.conf man page.
General settings

The general settings tab is used to enable the service and configure global settings, such as how often hosts are being checked and the number of resources relayd is allowed to use.
Status

Using the status page you can gain insights into the running configuration and perform maintenance tasks on various objects. The easy to use presets on top of the page offer the ability to save filter selections locally in your browsers storage for later reuse.
Simple example

One of the easiest setups is a virtual server which monitors backend servers using icmp (ping) and forwards traffic to a group of mail servers listening on port 25 (smtp), the graph below shows the connection from a client to one of the backend servers defined in a table.

In order to set up the example scenario, configure the following settings:

    Backend Hosts (add 2 new with the following properties)

            Enable: [x], Name: host_1, Address: 10.0.0.1

            Enable: [x], Name: host_2, Address: 10.0.0.2

    Table, add new with the following properties

            Name: table

            Hosts: host_1,host_2

            Enable: [x]

    Virtual Server, add with the following properties

        Name: ExampleServer

        Enable: [x]

        Server Type: Redirection

        Listen Address: 192.168.1.1

        Listen Port: 25

        Table: table

        Scheduler: Round Robin

        Table Check: ICMP

Make sure to enable relayd on the generic settings tab, save settings and the new vritual host should be active.


Wazuh Agent
Introduction

Wazuh is an open source unified XDR (Extended Detection and Response) and SIEM (Security Information en Event Management) system capable of offering protection for endpoints and cloud workloads.

The Wazuh architecture is based on agents, running on the monitored endpoints, which collect information and are capable of executing active responses directed by the manager.

The goal of this plugin is to offer an easily installable plugin to connect to the Wazuh manager.

Note

The scope of Wazuh on OPNsense is only to offer configurable agent support. We do not plan nor advise to run the Wazuh central components on OPNsense. Detailed information on how to install these on supported platforms are available directly from the Wazuh website or you can use their cloud based offering available here

Warning

This plugin is provided “as-is” and with very limited [tier 3] community support from the OPNsense team. Using a SIEM/XDR system requires knowledge which usually is out of the (free) community support scope.
Installation

Installation of this plugin is rather easy, go to System ‣ Firmware ‣ Plugins and search for os-wazuh-agent, use the [+] button to install it.

Next go to Services ‣ Wazuh Agent ‣ Settings to configure the service.

Tip

When the ossec log offers too limited insights when debugging issues, try to increase the debug level. You can find this setting under General settings when “advanced mode” is enabled.
Connecting the agent

To connect the agent to the manager, just fill in a hostname under General Settings/Manager hostname, make sure the agent is marked enabled and optionally specify a connect password under Authentication/Password.

Next go to the manager to see if the agent registered itself.
Selecting which logs to ingest

Our Wazuh agent plugin supports syslog targets like we use in the rest of the product, so if an application sends its feed to syslog and registers the application name as described in our development documentation it can be selected to send to Wazuh as well.

For Intrusion detection we can send the events as well using the same (eve) datafeed used in OPNsense, just mark the Intrusion detection events in the general settings.

Note

Wazuh only supports rfc3164 formatted syslog messages, for that reason we record a copy of the requested events into a file named /var/ossec/logs/opnsense_syslog.log using that format.
Installing custom ossec.conf entries

Some Wazuh modules are directly selectable from the gui, but when a feature is needed, which is not offered in the plugin, it’s possible to add static sections manually.

You can add these in /usr/local/opnsense/service/templates/OPNsense/WazuhAgent/ossec_config.d/, for example, to add a custom json feed, add a file containing the following content in there:
/usr/local/opnsense/service/templates/OPNsense/WazuhAgent/ossec_config.d/099-my-feed.conf

1<localfile>
2  <log_format>json</log_format>
3  <location>/path/to/my/file.json</location>
4</localfile>

Use active responses

Wazuh supports active responses so the manager can direct defensive actions when needed. The plugin ships with one action named opnsense-fw to drop traffic from a specified source address.

Note

The opnsense-fw action is stateful and can add and delete addresses from the firewall, more context on these type of actions can be found in the Wazuh documentation.

To use this action, you need to add some configuration in the manager, starting with the definition of this action.
/var/ossec/etc/ossec.conf

1<ossec_config>
2  <command>
3    <name>opnsense-fw</name>
4    <executable>opnsense-fw</executable>
5    <timeout_allowed>yes</timeout_allowed>
6  </command>
7</ossec_config>

After which you can use it in active-response rules, like this (adjust agent id):
/var/ossec/etc/ossec.conf

 1<ossec_config>
 2  <active-response>
 3    <disabled>no</disabled>
 4    <command>opnsense-fw</command>
 5    <location>defined-agent</location>
 6    <agent_id>001</agent_id>
 7    <rules_id>87702</rules_id>
 8    <timeout>180</timeout>
 9  </active-response>
10</ossec_config>

The official documentation contains more information about the options available.

Tip

Active responses are logged into Services ‣ Wazuh Agent ‣ Logfile / active-responses, including the messages received from the manager.

To quickly test if an active-response can be executed on the agent, we advise to use the API console under Wazuh ‣ Tools ‣ API console. Executing the opnsense-fw command for address 172.16.1.30 on agent 001 can be done using:

 1PUT /active-response?agents_list=001
 2{
 3  "command": "!opnsense-fw",
 4  "custom": false,
 5  "alert": {
 6    "data": {
 7      "srcip": "172.16.1.30"
 8    }
 9  }
10}

Tip

Wazuh offers quite some proof of concept documents and blog posts, like this document explaining how Suricata and Wazuh can be combined to respond to detected threats.
Test rule detection

In case log entries are being collected in /var/ossec/logs/opnsense_syslog.log and no events are being collected in the Manager, it’s usually a good idea to check how Wazuh processes these lines.

The Wazuh ‣ Tools ‣ Ruleset test menu item in the manager offers an easy to use tool to inspect log events.


ntopng
Installation

First of all, you have to install the ntopng plugin (os-ntopng) from the plugins view reachable via System ‣ Firmware ‣ Plugins.

After a page reload you will get a new menu entry under Services for ntopng. If you don’t have Redis plugin installed, you’ll receive a warning in ntopng main menu. Please go back to System ‣ Firmware ‣ Plugins, install os-redis, change to Services ‣ Redis and just enable the service. That’s enough to run ntopng.
General Settings

Enable ntopng

    Enable and start ntopng.
Interfaces

    Here you set the interfaces ntopng should listen on. If you don’t select any interface it listens to the first in the system, e.g. em0, but you can change the interfaces within ntopng’s UI on demand; while setting an explicit interface you wont get any other interface presented in its own UI.
HTTP Port

    The port ntopng’s UI should listen on. When you leave it on the default just open a browser and go to your Firewall IP with port 3000 and HTTP. If you want to secure the connection feel free to setup HAProxy or Nginx as a reverse proxy (SSL offloading).
DNS Mode

    Here you can choose if ntopng should try to resolve IPs to host names.



Third-party Plugins
_images/architecture-blue-sky-business-2599538.jpg

Like our community plugins in some cases software is delivered under a non-free license, the Third-party section contains the documentation for these packages as provided by Deciso or one of its partners.

For support on this software, please consult the vendor as found below.
Sunnyvalley

    Zenarmor (Sensei): Overview
    Zenarmor (Sensei): Hardware Requirements
    Zenarmor (Sensei): Installing via Web Interface
    Zenarmor (Sensei): Installing via Command Line


Zenarmor (Sensei): Overview
About

Zenarmor is a plugin for the OPNsense firewall which provides state-of-the-art next-generation features. Zenarmor is developed by Sunny Valley Cyber Security Inc (https://www.zenarmor.com)

If you are running a L4 firewall (all open-source firewalls fall into this category) and looking for features like Application Control, Network Analytics, and TLS Inspection, Zenarmor is the product you’re looking for.
Features

Zenarmor empowers your firewall with the following next-generation features:

    Application Control

    Cloud Application Control (Web 2.0 Controls)

    Advanced Network Analytics

    Web Filtering & Security

    Cloud Threat Intelligence

    User-based Filtering and Reporting

    Active Directory Integration

    RESTful API

    Cloud-based centralized management & Reporting

    Application / Web-category-based Traffic Shaping and Prioritization

    Policy-based filtering and QoS

    Encrypted Threats Prevention

    All-ports full TLS Inspection (for every TCP port, not just HTTPS) Coming soon

Getting Started

    Zenarmor (Sensei): Hardware Requirements

    Zenarmor (Sensei): Installing via Web Interface

    Zenarmor (Sensei): Installing via Command Line

User Manual

You can get detailed How to documents from Zenarmor’s Documentation Site located at https://www.zenarmor.com/docs/opnsense

    Dashboard

    Status

    Reports

    Security

    Application Control

    Web Control

    Configuration

Getting Support

Support for Free Edition

If you need help with Zenarmor, there is an active discussion on the OPNsense forum. Feel free to click here to join the conversation.

You may also submit bug reports by visiting the Report Bug page in the Zenarmor web UI.

With its in-depth coverage, Zenarmor Documentation is always available for reference.

    OPNsense Forum

    Users’ Manual

Premium Subscription Support

When you buy a Zenarmor Premium Subscription, you are entitled to Zenarmor Basic Support. Additional support plans are available on demand.

    Compare Support Plans

    Access Support Center

Support Options for Channel Partners

Sunny Valley Cyber Security Inc provides Tier 3 Support Options for Zenarmor Channel Partners. To learn more about them, please contact sensei-partnership -at- sunnyvalley.io.

To become a partner, you may apply for a partnership via https://www.zenarmor.com/apply-partnership .

Connect via Social Media or Websites

    Twitter: @zenarmor

    Youtube: Zenarmor Hands-on videos

    Company Website: https://www.zenarmor.com

    Product Website: https://www.zenarmor.com

    Zenconsole Cloud Management Portal: https://dash.zenarmor.com

    Zenarmor Blog: https://www.zenarmor.com/blog


Zenarmor (Sensei): Hardware Requirements

Due to the nature of deep packet analysis and detailed drill-down reporting functionality, Zenarmor requires more hardware resources than a standard L3-L4 firewall.

    Note

        With the Sensei 1.5 release, you can offload your reporting database to an external system. This allows you to run Zenarmor on systems with a constrained amount of RAM.

It is recommended that you check if your Ethernet adapter functions well with Netmap.
CPU & Memory

Because the analytics module relies on Elasticsearch to process large amounts of data, the amount of memory available in the system is crucial for the overall performance of Zenarmor.

Tip

    If the number of active devices is more than 500 and the sustained WAN bandwidth is higher than 500 Mbps, we do not recommend deploying Zenarmor as a virtual guest since resources in virtual environments are generally shared between guest systems.

Below is the recommended minimum hardware requirements for Zenarmor based on the number of devices and the amount of sustained bandwidth:

# Active Devices
	

Maximum WAN Bandwidth
	

Minimum Memory
	

Minimum CPU

0-50
	

300 Mbps
	

1 GB
	

A Dual-Core CPU (x86_64 compatible, single core PassMark score of 200)

50-100
	

500 Mbps - 10 Kpps
	

4 GB
	

Intel Dual-Core i3 2.0 GHz (2 Cores, 4 Threads) or equivalent

100-250
	

1 Gbps - 20 Kpps
	

8 GB
	

Intel Dual-Core i5 2.2 GHz (2 Cores, 4 Threads) or equivalent

250-1000
	

1-2 Gbps 40 Kpps
	

16 GB
	

Intel Dual-Core i5 3.20 GHz (2 Cores, 4 Threads) or equivalent

1000-2000
	

1-2 Gbps
	

32 GB
	

Intel Quad-Core i7 3.40 GHz (4 Cores, 8 Threads) or equivalent

2000+
	

2-4.5 Gbps
	

64 GB
	

Intel Quad-Core i9 3.0 GHz (24 Cores, 48 Threads) or equivalent

    Note

        Zenarmor requires at least 1 GB of memory. The installer will not continue if you have less than 1 GB of RAM. We recommend 8 GB memory to have an exceptional reporting experience with the elasticsearch database.

Ethernet Adapter

Zenarmor uses a FreeBSD subsystem called netmap(4) to access raw Ethernet frames. With FreeBSD 11 (OPNsense version <= 20.1) this software can be very particular in terms of proper driver compatibility.

Intel-based adapters, particularly em(4) and igb(4), are observed to perform well in terms of stability and performance.

Sunny Valley Networks is sponsoring developments on this project so you can expect netmap(4) will better support a wide range of Ethernet drivers.
Disk Space

Zenarmor uses Elasticsearch or MongoDB as its backend to store large data sets. Please allow at least 5 MB of disk space per hour per megabit/second throughput.

If you’re running a 100 Mbps link (about 100 users) that is quite active during the daytime and idle the rest of the day, you may calculate the space needed as follows:

5 MB x 12 hours x 100 Mbps = 6 GB per day.
6 GB x 7 days a week = 42 GB per week.
42 x 4 weeks a month = 168 GB per month.

As of version 0.7.0, Zenarmor expires old report data to free up disk space for the most recent data based on the configured number of days of history to keep.


Zenarmor (Sensei): Installing via Web Interface

Note

Zenarmor Free Edition is forever free-of-charge. We strongly recommend you register to keep in touch with updates and new features. You can register at https://www.zenarmor.com/zenarmor-next-generation-firewall

Zenarmor may be installed using the web interface in OPNsense or using the command line interface via SSH or local system access (see Zenarmor (Sensei): Installing via Command Line). The preferred method is the web interface because the process of installing plugins in OPNsense is simple, and Zenarmor requires the use of the web interface to complete the initial configuration after installation.

To install plugins in OPNsense, you must use an account with administrative access.

Note

Before installing Zenarmor, you should ensure you meet the minimum system requirements in order to run Zenarmor or have the best user experience. See Zenarmor (Sensei): Hardware Requirements for more information.
Web Interface Installation

To install Zenarmor, you must first install the Sunny Valley Networks vendor repository plugin. Go to the System ‣ Firmware ‣ Plugins page. Click on the “+” icon next to os-sunnyvalley to install the plugin.

Once the vendor plugin is installed, you should see the Zenarmor plugin available in the list of plugins as os-sensei. If you do not see the Zenarmor plugin, you may need to refresh the “Plugins” page. Click the “+” icon next to os-sensei to install the plugin.

After installing Zenarmor, you should see the Zenarmor menu in the left sidebar of the OPNsense web interface. If you do not see the new, top-level menu, you may need to refresh the page.
../../_images/zenarmor-install-complete.png

Next, you will need to complete the “Initial Configuration Wizard” for Zenarmor to be fully operational.
Initial Configuration Wizard

Regardless of the installation method you used, you will need to complete the initial configuration wizard before you may start using Zenarmor.

To start the “Initial Configuration Wizard”:

    Log in to your OPNsense web interface

    Click Zenarmor from the left menu

    Click on the Dashboard sub-menu to open the configuration wizard

1- Welcome

    Accept the Terms of Service and Privacy Policy by clicking on the checkbox.

../../_images/zenarmor-wizard-welcome.png

    Click the I Agree button to continue to the Hardware Check & Reporting Database section.

2- Hardware Check & Reporting Database

Your hardware will be analyzed to ensure it meets the minimum requirements. You will receive one of the following responses: compatible hardware, low-end hardware, incompatible hardware. The setup will not continue if you have incompatible hardware.
../../_images/zenarmor-wizard-hardware-high-end.png

Compatible
../../_images/zenarmor-wizard-hardware-low-end.png

Low-end
../../_images/zenarmor-wizard-hardware-incompatible.png

Incompatible

    Select the database you wish to use for reporting. High-end systems will have 3 options, while low-end systems only have 2 options.

After the wizard completes the hardware analysis, select the database you wish to use for reporting. High-end systems will have 4 options, while low-end systems only have 3 options except Local ElasticSearch DB.

Note

Zenarmor offers the following Database deployment options:

    Local ElasticSearch DB

    Remote ElasticSearch DB

    MongoDB Database

    SQLite Database

Warning

If you wish to use a remote ElasticSearch database, you must choose it now since you cannot change this after the initial configuration wizard has been completed.
../../_images/zenarmor-wizard-reporting-database-high-end.png

High-end
../../_images/zenarmor-wizard-reporting-database-low-end.png

Low-end

    If you select “Use a Remote Elasticsearch Database”, you will be prompted to enter the URL, username, and password.

Note

If you have SOHO or higher Zenarmor paid subscription, we recommend that you install your license key before proceeding with the initial configuration wizard since this will activate a feature that will enable you to have central reporting for many firewalls from a single Elasticsearch instance. Otherwise, only a single remote ES instance can be used with a single firewall.
../../_images/zenarmor-wizard-reporting-database-remote.png

Click the Install Database button to install the local database if one is chosen and to continue to the Interface Selection section.
../../_images/zenarmor-installing-ecs.png

Click the Next button to proceed with interface selection.
../../_images/zenarmor-db-install-finished.png

    Click the Next button Interface Selection section.

3- Deployment Mode & Interface Selection

You may follow the instructions for Zenarmor deployment mode and interface selection:

Select the deployment mode depending on your topology and requirements. By default, the Routed mode with emulated netmap driver option is selected on OPNsense. You may find detailed information in the “Deployment Modes Guide”, see here.

PREREQUISITE

Before selecting Netmap driver deployment options, make sure that the hardware offloadings are disabled on your node. Since the Hardware Offloading feature is incompatible with Netmap.
../../_images/zenarmor-selecting-deployment-mode.png

You may check the CPU Pinning option. Zenarmor has a setting to make CPU pinning optional, giving you more flexibility in how you configure your system for optimal performance. By default, Zenarmor is pinned to a dedicated core in order to prevent CPU context-switching overhead. Because if the process wanders between CPU processors, CPU cache misses occur, which has a negative impact on performance.

You may disable this setting depending on your requirements by clicking on the Do not pin engine packet processors to dedicated CPU cores option.

    Select the Ethernet Interface(s) to protect. To do so, click on an interface and use the right or left arrow buttons to move it to the protected/unprotected interfaces combo box.

For detailed information on “Deployment Modes”, see here.
../../_images/zenarmor-wizard-interface-selection-available.png

Click the Set Security Zone drop-down menu to assign a tag for the interface. You may set a custom security zone name or select one of the options available, such as DMZ, LAN, guest, wifi, or wan.
../../_images/zenarmor-wizard-set-security-zone.png

To add a custom security zone tag, click the Custom button in the Set Security Zone drop-down menu. After typing the new security zone name, such as vpn, click Add button.
4- Activate Subscription

Installation wizard offers you the following options in this step:

    Start 15-day Free Trial of a Business Subscription

    Activate your current subscription key

    Continue with the Free Edition

If you wish to try the 15-day Free Business Edition, select the Get Me 15-day Free Trial of Business Subscription option and type your e-mail address to claim your subscription key.

Tip

    Everyone who installs Zenarmor and login into their Zenconsole may take advantage of a 15-Day Free Trial of Zenarmor Business Edition without entering credit card information.

    Click Next to continue to the Finish section.

If you have a subscription, select I already have my subscription key option to activate your subscription key.
../../_images/zenarmor-wizard-activating-subscription.png

You may also use the Free Edition by selecting the Get Me the Free Edition option. You may enter your email address if you wish to subscribe to the Zenarmor email list to stay up-to-date on the latest news.
../../_images/zenarmor-getting-free-edition.png

Click Next to proceed to the Finish section.
5- Finish

    Click the Complete button to save your initial configuration data and start using Zenarmor.

../../_images/zenarmor-wizard-finish.png


Zenarmor (Sensei): Installing via Command Line

Although the preferred method of installation is the web interface, Zenarmor may also be installed using the command line interface via SSH or direct system access. Once Zenarmor is installed, you will need to complete the initial configuration using the web interface.

To install Sensei in OPNsense with the command line interface, you must use an administrative account with shell access.
Command Line Installation

The command line installation method was the primary means for installing Zenarmor before it was officially available on the “Plugins” page in the OPNsense web interface. This option is still available for users who have direct access to the OPNsense system yet prefer using command line tools or who may only have remote shell access via SSH to administrate their OPNsense installations. However, accessing the web interface is still necessary after installation to complete the initial configuration of Zenarmor.

You may install Zenarmor if you have local system access to OPNsense or remote access using SSH.
Local System Access

When you have local access to OPNsense, you may simply log into OPNsense using the “root” user or another administrator account. You should see a list of OPNsense menu options.
../../_images/opnsense-direct-system-access.png
SSH Access

If you only have shell access to OPNsense, you may install Zenarmor remotely by logging into OPNsense using a SSH client with the following command where “root” is the administrator account and “your-firewall-ip” is the IP address or hostname of the OPNsense system. You should see a list of OPNsense menu options.

$ ssh root@your-firewall-ip

../../_images/opnsense-ssh-login.png
Download & Run Zenarmor Installer

Once you are successfully logged into OPNsense either by local system access or SSH, enter option “8” to open the shell. Run the following command to download and execute the installation script.

# curl https://updates.sunnyvalley.io/getzenarmor | sh

../../_images/zenarmor-cli-install-.png

The script will copy the installation files onto the filesystem and will add a top-level menu item within the OPNsense web interface. Depending on the speed of your hardware and Internet connection, the installation may take several minutes to complete.

Once the installation has been completed, you may disconnect from your terminal session.

You will now need to complete the “Initial Configuration Wizard” for Zenarmor to be fully operational. See the Initial Configuration Wizard section for information.


Troubleshooting
_images/ask-blackboard-356079.jpg

Sometimes, even with all the hard work done to prepare your setup, issues occur. Generally it’s always good to check your logs (System ‣ Log Files or the ones found in the module your trying to setup), but sometimes more help is needed.
General issue workflow

Before reporting issues, please make sure yours still exists on the latest version. We generally advice to check the existing issues and our forum before reporting new ones.

In case your issue was introduced after a (minor) upgrade, you can use opnsense-revert to downgrade specific packages installed on the system.

Using the firmware section (System ‣ Firmware ‣ Status) you can perform a health check on the system, on the bottom of the status overview is a button named Run an audit which can be expanded to offer the Health selection.

When clicked this outputs something like the following:

***GOT REQUEST TO AUDIT HEALTH***
>>> Check installed kernel version
Version 19.7.3 is correct.
>>> Check for missing or altered kernel files
No problems detected.
>>> Check installed base version
Version 19.7.3 is correct.
>>> Check for missing or altered base files
No problems detected.
>>> Check for and install missing package dependencies
Checking all packages: .......... done
>>> Check for missing or altered package files
Checking all packages: ....
opnsense-19.7.4_1: checksum mismatch for /usr/local/etc/inc/auth.inc
Checking all packages...
Checking all packages......... done
***DONE***

When mismatches are reported, you can reinstall affected packages in the Packages section of the firmware screen. In the case above you would reinstall opnsense, since the auth.inc looks tainted.

Note

We advise to include the output of the health check if it seems to report issues when creating bug reports on GitHub.

Tip

Always try to be precise in issue reports, either if their about a possible bug or a feature request, it helps if intentions are absolutely clear. Our GitHub repositories use templates which should guide you through, we kindly ask you to use them (tickets not using our templates are treated as low priority).
Topics

Some of the common mistakes we have seen over the years, combined with pointers where to look for solutions can be found in the list below.

    Password reset
    WebGui access reset
    Boot
    System hardening vs performance
    Gateways and monitoring
    Network
    OpenVPN
    Performance



Password reset

Sometimes people lose their passwords, in which case it can be practical to reset the root password without performing a reinstall.

This guide describes step by step how to reset the root password.

Note

You can also use the installer to reset the password, use the Password Reset - Recover Installation option in the installer after the keymap selection.
Step 1 : power

Since you need to influence the boot process to reset the password, you should start with powering off the (virtual) device.
Step 2 : console

Make sure you are able to access the (virtual) console, in case it’s a physical machine you might want to connect a monitor and keyboard, when it’s an appliance with serial access, make sure to connect to the serial/usb port using an application like putty.

Tip

When using devices from the OPNsense shop (https://shop.opnsense.com), usually there’s a mini-usb to serial cable included in the box, the Serial Console connectivity guide will help you with the setup.
Step 3 : boot single

Swith the power and wait for the OPNsense splash screen to appear, the choose “Boot [S]single User” which should be option 2 in the list. (press 2)
Step 4: password reset

This stage depends on the type of installation, the root filesystem could either be UFS or ZFS, both requiring different commands to enable modifications in single user mode.

For UFS file systems, execute the following command in the shell to enable disk modifications:

/sbin/mount -o rw /

When using ZFS, the following commands are required

/sbin/mount -u /
/sbin/zfs mount -a

Now the disk can be written to, use the following commands to reset the password and reboot the machine:

opnsense-shell password
reboot

The opnsense-shell will ask for a confirmation, respond with Y


WebGui access reset

If for some reason the webgui certificate is broken, you can reconfigure access using the console menu. Select Set interface IP address (option 2) from the menu, reconfigure an interface, after providing the address configuration you can either (temporary) switch back to HTTP or in the next step generate a new self-signed certificate.

It is also possible to reset the defaults in the final step (“Restore web GUI access defaults?”), in case something went wrong while setting up anti lockout policies or after changing interfaces.

Tip

When logged in directly via a console or shell, you can also use the following command to generate a new self-signed certificate and restart the web ui:

configctl webgui restart renew


Boot
hangs at “booting…”

On some serial connected devices the console settings are different, in which case you would not be able to start the installer.

If you can reach the loader prompt, you could try to change some kernel parameters before booting.

set hint.uart.0.flags=0x0
set hint.uart.1.flags=0x10
set comconsole_speed=115200
set comconsole_port=0x2F8
set console=comconsole
boot

Note

To enter the loader prompt press 3 when the OPNsense boot menu is visible

After installation, you could persist these settings in System ‣ Settings ‣ Tunables

System hardening vs performance

OPNsense tends to choose more strict hardening options by default, so when comparing performance between upstream standard FreeBSD it’s good to know which settings differ and can have an impact on your measurements. This document aims to describe (some of) the differences, so when you value performance over security it is more obvious which toggles might be worthwhile to change.

Keep in mind that most of the settings will need a reboot and can be altered using system tunables in System ‣ Settings ‣ Tunables.
IPv4 random ID’s [net.inet.ip.random_id]

control IP(v4) IDs generation behaviour. This closes a minor information leak which allows remote observers to determine the rate of packet generation on the machine by watching the counter. At the same time, on high-speed links, it can decrease the ID reuse cycle greatly. IPv6 flow IDs and fragment IDs are always random. (source man -S 4 inet)

Our default is 1 (enabled).
Spectre and Meltdown

To mitigate some of the speculative execution vulnerabilities, there are a couple of settings available in FreeBSD. More information about the various vulnerabilities and associated patches can be found here

Meltdown mitigation using Page Table Isolation (PTI), although also enabled in FreeBSD it’s worth to mention which setting is responsible for enabling this feature. To disable PTI set vm.pmap.pti to 0. Not all cpu’s are vulnerable for Meltdown, in which case PTI can be disabled safely.

Spectre variant 2, the system offers IBRS-based mitigation on Intel CPUs. The IBRS mitigation main disadvantage is the significant performance penalty. In OPNsense IBRS is enabled (for Intel) by default by disabling (0) hw.ibrs_disable, upstream FreeBSD standard is disabled (1).
User/group separation (security.bsd)

Freebsd offers a couple of toggles to tighten security for ordinary users, these likely don’t impact performance a lot, but these are the ones including descriptions that differ on our end (source sysctl -d security.bsd).

Setting
	

Description

security.bsd.hardlink_check_gid [0->1]
	

Unprivileged processes cannot create hard links to files owned by other groups

security.bsd.hardlink_check_uid [0->1]
	

Unprivileged processes cannot create hard links to files owned by other users

security.bsd.unprivileged_proc_debug [1->0]
	

Unprivileged processes may use process debugging facilities

security.bsd.see_other_gids [1->0]
	

Unprivileged processes may see subjects/objects with different real gid

security.bsd.see_other_uids [1->0]
	

Unprivileged processes may see subjects/objects with different real uid

security.bsd.unprivileged_read_msgbuf [1->0]
	

Unprivileged processes may read the kernel message buffer


Gateways and monitoring

The address you are trying to monitor should be reachable using the interface the gateway is attached to, either directly or using a static route (check System ‣ Routes ‣ Status).
dpinger:.. sendto error: XXX

Usually found in System ‣ Log Files ‣ General, every code has a meaning, usually explained in errno.h (man errno)

Some common ones are explained in the Common error codes section.
arpresolve: can’t allocate llinfo for..

This message usually means that the configured gateway lies outside the configured subnets for this firewall (for IPv4).

Tip

Double check the subnets of your interface and virtual IP’s, you can also use Interfaces ‣ Overview for a quick list of all configured addresses.

Network
Netmap (IPS, Sensei, …)

General

Netmap is a technology which enables fast packet processing while minimizing overhead, there are however some pitfalls which may turn your network interface unreachable.

Before using this technology, always make sure you have access via another interface (or console) to your firewall in case connectivity is dropped.

In order for netmap to function properly it is imperative that all sorts of driver / hardware acceleration is disabled (Interfaces -> Settings), this include VLAN Hardware Filtering as well (which wasn’t disabled pre 20.7).

Some drivers have may have additional tunables, which enable hardware acceleration, make sure to disable them as well (.e.g intel ixl has hw.ixl.enable_head_writeback, which we disable by default)

Below you will find a list of tunables which are know to be (partial) incompatible with netmap.

Tunable
	

Description

hw.ixl.enable_head_writeback
	

Intel ixl(4) tunable for increased tx performance, OPNsense standard value is disabled.

dev.ax.<interface number>.sph_enable
	

AMD tunable to split header and payload into a separate buffer respectively, Netmap requires a uniform view of a packet. Disabled by default on OPNsense.

Decoupling Netmap from an application

It can be useful to split the functionality of Netmap and the application using it in order to determine whether it’s Netmap or the application at fault for connectivity issues. To aid in this, Netmap’s bridge utility has been added to our pkg repository for easy installation and use. To avoid ambiguity, it has been renamed to netmap-bridge.

You can install it by running pkg install netmap-bridge (man netmap-bridge).

netmap-bridge provides a L2 software bridge between two interfaces, but can also be used to bridge an interface and the host network stack like Suricata does. To replicate the behaviour of Suricata without actually running Suricata, run netmap-bridge -i netmap:igb1. Replace the interface as appropriate. While it is running, pass traffic as normal to determine if an original issue persists.
Common error codes

Any piece of software that uses system calls to communicate over sockets use the standard interface errno.h (man errno). If an error is logged, a return code is associated to a specific reason of failure. Some common ones are explained below:

XX
	

Name
	

Description

55
	

ENOBUFS
	

No buffer space available. An operation on a socket or pipe was not performed because the system lacked sufficient buffer space or because a queue was full. Check connectivity from the machine itself using ping, most common mistakes are misconfigured routes, interface issues (disconnected) and policy based routing issues forcing traffic to the wrong target (using reply-to)

64
	

EHOSTDOWN
	

Host is down. A socket operation failed because the destination host was down. Expecting an (layer 2) ARP response but none was returned, often misconfigured subnets or hosts are actually not accessible over L2

65
	

EHOSTUNREACH
	

No route to host. A socket operation was attempted to an unreachable host The routing table is a good place to look (System ‣ Routes ‣ Status)


OpenVPN
Assigned Interfaces

While not strictly necessary, it is possible to assign individual interfaces for OpenVPN servers and clients alike. However doing so may yield unexpected behaviour of firewall rules. Most notably, rules created on an assigned interface of an OpenVPN Roadwarrior server are created with the reply-to directive by default, which breaks client connectivity.

Tip

In cases as described above, it can be observed that incoming traffic matches and passes the corresponding firewall rule, but reply traffic is never sent back to the connected client. This can be verified via the Web GUI by going to Firewall -> Log Files -> Live View and optionally by performing a packet capture on the affected interface.

There are multiple ways to fix this problem. For most setups, it will be sufficient to disable the automatically created IPv4 and IPv6 Gateways under System -> Gateways -> Configuration. Doing so will also disable the automatic addition of the reply-to directive to rules created on the interface, and client connectivity will be restored.

Another option is to manually select the option “Disable Reply-To” on each firewall rule you generate on the assigned interface. See Rules for further details.

The third option is to globally disable the generation of reply-to completely as described in (Advanced) Settings. However this method can break Multi-WAN setups.


Performance
Receive-side scaling
Introduction

RSS is used to distribute packets over CPU cores using a hashing function – either with support in the hardware which offloads the hashing for you, or in software. The idea is to take as input the TCP 4-tuple (source address, source port, destination address, destination port) of a packet, hash this input using an in-kernel defined key, and selecting the resulting values’ LSB as an index into a user-configurable indirection table. The indirection table is loaded into the hardware during boot and is used by the NIC to decide which CPU to interrupt with a given packet. All of this allows packets of the same origin/destination (a.k.a. flows) to be queued consistently on the same CPU.

Note

By default, RSS will be disabled since it’s impact is quite far reaching.

Only enable this feature if you’re interested in testing it and seeing if it will increase your throughput under high load – such as when using IDS/IPS.

Since we do not have every type of hardware available – nor the time to test all of them, no guarantee is given that a NIC driver will properly handle the kernel implementation or is even capable of using it.

The implementation of RSS is coupled with PCBGROUP – an implementation which introduces notions of CPU affinity for connections. While the latter will be of lesser importance for OPNsense, since it specifically applies to connections built up in userland using sockets (which is relevant to servers, not middleboxes), the idea of distributing work on a lower level with hardware support provides a myriad of benefits.
Network card / driver

Assuming you are using a modern NIC which supports multiple hardware queues and RSS, the configuration of a NIC will decide how and on which queue packets arrive on your system. This is also hardware dependent and will not be the same on every NIC. Should your driver support the option to enable/disable RSS, a sysctl tunable will be available.

It is possible for a NIC to perform RSS without being able to configure it. Should you wish to know if it can be enabled/disabled:

sysctl -a | grep rss

should show any drivers exposing the option via a tunable.

It is also possible that a driver does not expose this ability to the user, in which case you’d want to look up whether the NIC/driver supports RSS at all using online datasheets or a simple google search. For example, igb enables RSS by default, but does not reflect this in any configuration parameter. However, since it uses multiple queues:

# dmesg | grep vectors

igb0: Using MSI-X interrupts with 5 vectors
igb1: Using MSI-X interrupts with 5 vectors
igb2: Using MSI-X interrupts with 5 vectors
igb3: Using MSI-X interrupts with 5 vectors

It will most likely have some form of packet filtering to distribute packets over the hardware queues. In fact, igb does RSS by default.

For most NICs, RSS is the primary method of deciding which CPU to interrupt with a packet. NICs that do not implement any other type of filter and whose RSS feature is missing or turned off, will most likely interrupt only CPU 0 at all times – which will reduce potential throughput due to cache line migrations and lock contention. Please keep system-wide RSS disabled if this is the case.

The last but not least thing to consider is the fact that driver support with the in-kernel implementation of RSS is a must. Proper driver support will ensure the correct key and indirection table being set in hardware. Drivers which support RSS according to the source code (but mostly untested):

    em

    igb -> tested & working

    axgbe -> tested & working

    netvsc

    ixgbe

    ixl

    cxgbe

    lio

    mlx5

    sfxge

Kernel support

Internally, FreeBSD uses netisr as an abstraction layer for dispatching packets to the upper protocols. Within the implementation, the default setting is to restrict packet processing to one thread only. Since RSS now provides a way to keep flows local to a CPU, the following sysctls should be set in System->Settings->Tunables:

    net.isr.bindthreads = 1

    net.isr.maxthreads = -1

The first option causes threads to be bound to a CPU, the next one assigns a workstream to each core available.

Furthermore, the RSS implementation also provides a few necessary sysctls:

    net.inet.rss.enabled = 1

Makes sure RSS is enabled. This is disabled by default to prevent regressions on NICs that do not properly implement the RSS interface.

    net.inet.rss.bits = X

This one is dependent on the amount of cores you have. By default the amount of bits here represent the amount of cores x 2 in binary. This is done on purpose to provide load-balancing, though there is no current implementation for this so we recommend setting this value to the amount of bits representing the number of CPU cores. This means we use the following values:

    for 4-core systems, use ‘2’

    for 8-core systems, use ‘3’

    for 16-core systems, use ‘4’

    Etc.

Note

Remember to reboot the machine after changing net.inet.rss.enabled as this option can only be set during boot.
Validate settings

If RSS is enabled with the ‘enabled’ sysctl, the packet dispatching policy will move from ‘direct’ to ‘hybrid’. This will directly dispatch a packet on the current context when allowed, otherwise it will queue the packet on the bound CPU on which it came in on. Please note that this will increase the interrupt load as seen in ‘top -P’. This simply means that packets are being processed with the highest priority in the CPU scheduler - it does not mean the CPU is under more load than normal.

The correct working of netisr can be verified by running:

netstat -Q

Note regarding IPS

When Suricata is running in IPS mode, Netmap is utilized to fetch packets off the line for inspection. By default, OPNsense has configured Suricata in such a way that the packet which has passed inspection will be re-injected into the host networking stack for routing/firewalling purposes. The current Suricata/Netmap implementation limits this re-injection to one thread only. Work is underway to address this issue since the new Netmap API (V14+) is now capable of increasing this thread count. Until then, no benefit is gained from RSS when using IPS.

Development Manual
_images/ideas_join_the_development.jpg

The OPNsense® project invites developers to start developing with OPNsense: “For your own purpose or even better to join us in creating the best open source firewall available!” The development workflow & build process have been redesigned to make it more straightforward and easy for developers to build OPNsense.

Being able to get the sources and build it yourself is one of the key factors of open source software. One reason that for starting the OPNsense project is that the team believes sources and build tools should be freely available and as easy to use as possible.

    Development Workflow
    Coding Guidelines
        Basics and Future
        PSR-1 Basic Coding Standard
        PSR-2 Coding Style Guide
        PSR-12 Coding Style Guide
        Python PEPs
    Architecture
    Backend
        Overview
        Bootup / autorun options
        CARP status
        Using configd
        Using plugins
        Using Templates
    Frontend
        Creating Models
        Creating Models / Field types
        Routing
        Using controllers and views
        View construction (and tools)
        Dashboard widgets
    Components
        Menu System
        Access Control List
        Authentication
    API Reference
        Captiveportal
        Core
        Cron
        Dhcp
        Dhcpv4
        Dhcpv6
        Dhcrelay
        Diagnostics
        Firewall
        Firmware
        Ids
        Interfaces
        Ipsec
        Kea
        Menu
        Monit
        Openvpn
        Proxy
        Routes
        Routing
        Syslog
        Trafficshaper
        Trust
        Unbound
        Wireguard
        Acmeclient
        Apcupsd
        Backup
        Bind
        Caddy
        Chrony
        Cicap
        Clamav
        Collectd
        Crowdsec
        Dechw
        Diagnostics
        Dnscryptproxy
        Dyndns
        Fetchmail
        Freeradius
        Ftpproxy
        Gridexample
        Haproxy
        Helloworld
        Hwprobe
        Iperf
        Lldpd
        Maltrail
        Mdnsrepeater
        Muninnode
        Netdata
        Netsnmp
        Nginx
        Nodeexporter
        Nrpe
        Ntopng
        Nut
        Openconnect
        Postfix
        Proxy
        Proxysso
        Proxyuseracl
        Puppetagent
        Qemuguestagent
        Quagga
        Radsecproxy
        Redis
        Relayd
        Rspamd
        Shadowsocks
        Siproxd
        Smart
        Softether
        Sslh
        Stunnel
        Tayga
        Telegraf
        Tftp
        Tinc
        Tor
        Udpbroadcastrelay
        Vnstat
        Wazuhagent
        Wireguard
        Wol
        Zabbixagent
        Zabbixproxy
        Zerotier
        OPNBECore
    Examples
        Hello world module & plugin
        Using grids module & plugin
        API enable standard services
    How-tos
        Use the API
        Profiling/Debugging the kernel
        Remote debugging the kernel


Development Workflow
../_images/flow.png

It’s pretty hard to approach a larger repository you have never worked with. The biggest issue is that few projects have defined development (as in actual coding) workflow laid out for new contributors, so one is just going to be stabbing in the dark for a few days or weeks until things start making sense. Speaking of sense, let’s explain how we’ve designed the development experience for OPNsense and how you can start contributing code in no time.
Structure

Source, Ports, Core, Tools

The structure is pretty much FreeBSD: we have a source code repository and a ports tree. Historically, we also have a core code and tools repository. The tools repository is project shell code gluing all repositories together, producing final images, while the core is the important GUI and system configuration bits.

Note

As of 16.1 there is also plugin support, the source repository is plugins tree . Plugins are a modular way of easily extending the existing system.

Why core is not a part of source

The first thing that’s interesting is that the core is not part of the source repository, because it depends on third party software found in the ports. We can’t stick core into source, because ports are things that don’t fit into the base system. It also helps to keep source repository changes to the minimum to make major FreeBSD upgrades easier in the future.

Why core isn’t part of ports either

Why is the core repository not in the ports? Well, we have a couple of custom ports in the ports tree, but these are small. The core repository as well as the ports tree itself are so big that it made sense to keep them separate. Another reason is that the core repository only contains scripts in Shell, Python and PHP. So the tools repository actually treats the core repository as a package that depends on all the ports it needs. This way, on the images, it looks like the core code is just another package. That makes upgrading the core code very easy and fast without modifying base. We can even upgrade to newer ports pages and add and remove them as we go forward.
Building

Not Clobbering the Build System

The tools repository is designed to run on a stock FreeBSD using chroot mechanics to keep the build contained and consistent. There’s nothing worse than a build system that modifies the build system and at some point starts to dash out working images–only to stop working some time in the future. No, no, no.

You can also “cross-build” between FreeBSD versions. We’ve successfully built images on FreeBSD 10.1 when OPNsense was still running on FreeBSD 10.0. (version 16.1 now runs on FreeBSD 10.2) That’s not a huge gap and the ABI is the same, but we expect this to work with FreeBSD 11 and beyond as well so that if you have a FreeBSD box you will always be able to produce your own images if you desire–without spinning up extra machines, jails or virtual machines.

Here are the build instructions for OPNsense.

Tip

As of November 2015 OPNsense is equipped with a tool that can completely reinstall a running system in place for a thorough factory reset or to restore consistency of all the OPNsense files. It can also wipe the configuration directory, but won’t do that by default. The opnsense-bootstrap script is particularly useful if you want to convert a hosted FreeBSD system to OPNsense.
Virtual Machine for Development

Running: Use a Virtual Machine for Development

It’s just easier and less tedious if the kernel crashes, to revert to a previous state, or isolate and test different features. A VM can be set up easily using the ISO images. Also very good for testing installation and upgrades. Of course, at some point you will want to bring OPNsense to your actual target device—just make sure you know the system well enough before you attempt this.

VirtualBox is a solid tool for the job, but be sure to check out FreeBSD’s Bhyve as well (it was added in FreeBSD 10.0). However, If you are only interested in GUI coding, you can skip all the build parts and directly download an image and spin it up. Because…
Packages

It Gets Even Better

Once you have a running instance, how to produce and push code? Well, there’s a couple optional of packages that help you to be productive:

# pkg install vim-console emacs-nox joe nano gnu-watch git tmux screen

The most important one is git for obtaining the code, the rest is optional if you need it—mostly editors and terminal wrappers. It is also possible to mount sshfs or do sftp to sync files from the repo if you would like to use a graphical editor from your own system. As the root user do the following:

# cd
# git clone https://github.com/opnsense/core

Once you have the repository, you switch it live using:

# cd core
# make mount

Yes, the changes that you make in the repository will show up directly in the GUI now! Unfortunately, this will mount the repo over /usr/local so if you modify packages the changes will light up in git. Be careful. To prevent that from happening you can temporarily unmount using:

# make umount

To finish that off the boot sequence will mount the core repository set up in /root/core as early as possible (if it’s available) and will use its modifications for booting up (with the exception of /usr/local/etc/rc itself). This makes it possible to work on the backend configuration and boot sequence improvements without having out of sync system files and repositories.
Summary

Easy Access is Key to Collaboration

Although this is just a peek into OPNsense development workflow it brings to attention a key aspect: moving barriers out of the way to enable as many people as possible to produce quick results. Yes,there are barriers like git and GitHub to deal with, maybe even learning FreeBSD intricacies, but once you have your code in the GUI and working fine, you’ll feel proud enough to endure the hardships of making sure your patch will have a place in our upstream repositories so the community as a whole can benefit from your dedication.

The OPNsense core team looks forward to your feedback; “We are seeking for more improvements in the build system and eagerly await your pull requests.” Take care and code responsibly. :)


Coding Guidelines
../_images/guidelines_new.png

    Basics and Future
    PSR-1 Basic Coding Standard
    PSR-2 Coding Style Guide
    PSR-12 Coding Style Guide
    Python PEPs


Basics and Future

This article explains the basic coding guidelines that apply and put the development effort into perspective by explaining the difficulties of legacy code and the interaction/migration to new MVC-based code. It also explains guideline differences between new and legacy code.
PHP code

For PHP code the PSR-12 coding standard applies.
Python

For Python code the Python Enhancement Proposals (PEPs) apply. See the Python Developer’s Guide for detailed information.
Architecture

Documentation is available about our architecture and used components.
Safeguard user input

We aim to validate user input before injecting it in the configuration in order to provide a more user friendly interface and prevent bad things to happen in the future.

Although we do understand that the perfect validation isn’t always possible at once (too much referential constraints, not always as easy to catch) it is a best practice to ask yourself if a specific input could be validated (if not now, what about the future).

The issue with user input impossible to validate is that it will bite you eventually, leading to future security issues waiting to happen (for example a non authorized user can write commands that will be executed with elevated privileges, we saw this with openvpn for example).

For this reason we do not allow plain text configuration data to be stored in our configuration (although some legacy components still use this opnsense/core#d62015 )

Note

Feature requests for custom user inputs will be declined in our public repositories, defining what a feature should do also helps designing the right feature.

Tip

If custom input is needed, in most cases you can use hooks to include additional configuration data in the service, most services offer this type of support (either with predefined directories or via the template system).

This prevents arbitrary users from adding undefined configuration data.

The different field types in our model system are aimed to help the developer safeguard his or her code for unexpected input.
Ideal Development

Our ideal OPNsense system looks like a standard FreeBSD system using our pluggable user interface for management, which supports both real users as “machine” users (REST).

When developing we want the code to be clean and coded as DRY (Don’t Repeat Yourself) as possible and do not want to invent the wheel when not needed.

The user interface should to be able to run as non-root user instead of root by restructuring the way commands are passed to the system (configd).
Reality: Overdue Maintenance

In reality we forked a system that went without code maintenance for a very long time and we needed to transition that into something more structured.

One of the first things (on the programming part of the system) we did was build components around an existing framework (Phalcon) to create new modules, which could use validated configuration data (from the config.xml), supply a RESTful API and generate HTML output using standard templates (Volt).

We created the configd system, which can generate system configuration and execute system calls using predefined templates. And then we started using those new components for our first newly designed modules (like the proxy and the traffic shaper). More information about the “to-be” architecture can be found in our architecture documentation.
Strategy

Knowing we can’t change the world in a single day and having a lot of legacy to drag around with us, our strategy consists of three parts:

1) Cleanup and maintenance Restructure old (legacy) code, basically all code in the src/www, src/etc/inc to make it better readable, easier to use and remove unused / unnecessary parts. By doing so we want to extend the lifetime of the old code a bit and make the transition in new code easier eventually.

2) Detach Move system configuration calls to configd where possible, which gives the administrator the advantage of running those commands from the command line and helps removing the need for root user access in the future. The ipsec VICI implementation is one example of this stage.

3) Moving on (re)build new parts, using our new modules, which provide a layered development system to automatically support API calls from other systems and XML based model templates to describe configuration data.

See also:

    Hello World Module

    Howto use the API

Our guidelines somewhat depend of the stage the code is in, when writing new code, all actions should use the API system for actually changing configuration and performing configuration tasks. They should, of course, use the normal PSR coding standards for PHP code and follow the Python PEPs.

When moving to the legacy part of the system, our goal is to stick as close to PSR1/2 as possible, knowing it will never be perfect.


PSR-1 Basic Coding Standard

Note
The PSR1 and PSR2 Coding Standards are provided by FIG under a MIT license.
See license details: http://www.php-fig.org/bylaws/licensing-policies/
The original content of this page can be found at php-fig

This section of the standard comprises what should be considered the standard coding elements that are required to ensure a high level of technical interoperability between shared PHP code.

The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
1. Overview

    Files MUST use only <?php and <?= tags.

    Files MUST use only UTF-8 without BOM for PHP code.

    Files SHOULD either declare symbols (classes, functions, constants, etc.) or cause side-effects (e.g. generate output, change .ini settings, etc.) but SHOULD NOT do both.

    Namespaces and classes MUST follow an “autoloading” PSR: [PSR-0, PSR-4].

    Class names MUST be declared in StudlyCaps.

    Class constants MUST be declared in all upper case with underscore separators.

    Method names MUST be declared in camelCase.

2. Files
2.1. PHP Tags

PHP code MUST use the long <?php ?> tags or the short-echo <?= ?> tags; it MUST NOT use the other tag variations.
2.2. Character Encoding

PHP code MUST use only UTF-8 without BOM.
2.3. Side Effects

A file SHOULD declare new symbols (classes, functions, constants, etc.) and cause no other side effects, or it SHOULD execute logic with side effects, but SHOULD NOT do both.

The phrase “side effects” means execution of logic not directly related to declaring classes, functions, constants, etc., merely from including the file.

“Side effects” include but are not limited to: generating output, explicit use of require or include, connecting to external services, modifying ini settings, emitting errors or exceptions, modifying global or static variables, reading from or writing to a file, and so on.

The following is an example of a file with both declarations and side effects; i.e, an example of what to avoid:

<?php
// side effect: change ini settings
ini_set('error_reporting', E_ALL);

// side effect: loads a file
include "file.php";

// side effect: generates output
echo "<html>\n";

// declaration
function foo()
{
    // function body
}

The following example is of a file that contains declarations without side effects; i.e., an example of what to emulate:

<?php
// declaration
function foo()
{
    // function body
}

// conditional declaration is *not* a side effect
if (! function_exists('bar')) {
    function bar()
    {
        // function body
    }
}

3. Namespace and Class Names

Namespaces and classes MUST follow an “autoloading” PSR: [PSR-0, PSR-4].

This means each class is in a file by itself, and is in a namespace of at least one level: a top-level vendor name.

Class names MUST be declared in StudlyCaps.

Code written for PHP 5.3 and after MUST use formal namespaces.

For example:

<?php
// PHP 5.3 and later:
namespace Vendor\Model;

class Foo
{
}

Code written for 5.2.x and before SHOULD use the pseudo-namespacing convention of Vendor_ prefixes on class names.

<?php
// PHP 5.2.x and earlier:
class Vendor_Model_Foo
{
}

4. Class Constants, Properties, and Methods

The term “class” refers to all classes, interfaces, and traits.
4.1. Constants

Class constants MUST be declared in all upper case with underscore separators. For example:

<?php
namespace Vendor\Model;

class Foo
{
    const VERSION = '1.0';
    const DATE_APPROVED = '2012-06-01';
}

4.2. Properties

This guide intentionally avoids any recommendation regarding the use of $StudlyCaps, $camelCase, or $under_score property names.

Whatever naming convention is used SHOULD be applied consistently within a reasonable scope. That scope may be vendor-level, package-level, class-level, or method-level.
4.3. Methods

Method names MUST be declared in camelCase().


PSR-2 Coding Style Guide

Note
The PSR1 and PSR2 Coding Standards are provided by FIG under a MIT license.
See license details: http://www.php-fig.org/bylaws/licensing-policies/
The original content of this page can be found at php-fig

This guide extends and expands on PSR-1, the basic coding standard.

The intent of this guide is to reduce cognitive friction when scanning code from different authors. It does so by enumerating a shared set of rules and expectations about how to format PHP code.

The style rules herein are derived from commonalities among the various member projects. When various authors collaborate across multiple projects, it helps to have one set of guidelines to be used among all those projects. Thus, the benefit of this guide is not in the rules themselves, but in the sharing of those rules.

The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
1. Overview

    Code MUST follow a “coding style guide” PSR [PSR-1].

    Code MUST use 4 spaces for indenting, not tabs.

    There MUST NOT be a hard limit on line length; the soft limit MUST be 120 characters; lines SHOULD be 80 characters or less.

    There MUST be one blank line after the namespace declaration, and there MUST be one blank line after the block of use declarations.

    Opening braces for classes MUST go on the next line, and closing braces MUST go on the next line after the body.

    Opening braces for methods MUST go on the next line, and closing braces MUST go on the next line after the body.

    Visibility MUST be declared on all properties and methods; abstract and final MUST be declared before the visibility; static MUST be declared after the visibility.

    Control structure keywords MUST have one space after them; method and function calls MUST NOT.

    Opening braces for control structures MUST go on the same line, and closing braces MUST go on the next line after the body.

    Opening parentheses for control structures MUST NOT have a space after them, and closing parentheses for control structures MUST NOT have a space before.

1.1. Example

This example encompasses some of the rules below as a quick overview:

<?php
namespace Vendor\Package;

use FooInterface;
use BarClass as Bar;
use OtherVendor\OtherPackage\BazClass;

class Foo extends Bar implements FooInterface
{
    public function sampleFunction($a, $b = null)
    {
        if ($a === $b) {
            bar();
        } elseif ($a > $b) {
            $foo->bar($arg1);
        } else {
            BazClass::bar($arg2, $arg3);
        }
    }

    final public static function bar()
    {
        // method body
    }
}

2. General
2.1 Basic Coding Standard

Code MUST follow all rules outlined in PSR-1.
2.2 Files

All PHP files MUST use the Unix LF (linefeed) line ending. All PHP files MUST end with a single blank line.

The closing ?> tag MUST be omitted from files containing only PHP.
2.3. Lines

There MUST NOT be a hard limit on line length.

The soft limit on line length MUST be 120 characters; automated style checkers MUST warn but MUST NOT error at the soft limit.

Lines SHOULD NOT be longer than 80 characters; lines longer than that SHOULD be split into multiple subsequent lines of no more than 80 characters each.

There MUST NOT be trailing whitespace at the end of non-blank lines.

Blank lines MAY be added to improve readability and to indicate related blocks of code.

There MUST NOT be more than one statement per line.
2.4. Indenting

Code MUST use an indent of 4 spaces, and MUST NOT use tabs for indenting.

Note

N.b.: Using only spaces, and not mixing spaces with tabs, helps to avoid problems with diffs, patches, history, and annotations. The use of spaces also makes it easy to insert fine-grained sub-indentation for inter-line alignment.
2.5. Keywords and True/False/Null

PHP keywords MUST be in lower case.

The PHP constants true, false, and null MUST be in lower case.
3. Namespace and Use Declarations

When present, there MUST be one blank line after the namespace declaration.

When present, all use declarations MUST go after the namespace declaration.

There MUST be one use keyword per declaration.

There MUST be one blank line after the use block.

For example:

<?php
namespace Vendor\Package;

use FooClass;
use BarClass as Bar;
use OtherVendor\OtherPackage\BazClass;

// ... additional PHP code ...

4. Classes, Properties, and Methods

The term “class” refers to all classes, interfaces, and traits.
4.1. Extends and Implements

The extends and implements keywords MUST be declared on the same line as the class name.

The opening brace for the class MUST go on its own line; the closing brace for the class MUST go on the next line after the body.

<?php
namespace Vendor\Package;

use FooClass;
use BarClass as Bar;
use OtherVendor\OtherPackage\BazClass;

class ClassName extends ParentClass implements \ArrayAccess, \Countable
{
    // constants, properties, methods
}

Lists of implements MAY be split across multiple lines, where each subsequent line is indented once. When doing so, the first item in the list MUST be on the next line, and there MUST be only one interface per line.

<?php
namespace Vendor\Package;

use FooClass;
use BarClass as Bar;
use OtherVendor\OtherPackage\BazClass;

class ClassName extends ParentClass implements
    \ArrayAccess,
    \Countable,
    \Serializable
{
    // constants, properties, methods
}

4.2. Properties

Visibility MUST be declared on all properties.

The var keyword MUST NOT be used to declare a property.

There MUST NOT be more than one property declared per statement.

Property names SHOULD NOT be prefixed with a single underscore to indicate protected or private visibility.

A property declaration looks like the following.

<?php
namespace Vendor\Package;

class ClassName
{
    public $foo = null;
}

4.3. Methods

Visibility MUST be declared on all methods.

Method names SHOULD NOT be prefixed with a single underscore to indicate protected or private visibility.

Method names MUST NOT be declared with a space after the method name. The opening brace MUST go on its own line, and the closing brace MUST go on the next line following the body. There MUST NOT be a space after the opening parenthesis, and there MUST NOT be a space before the closing parenthesis.

A method declaration looks like the following. Note the placement of parentheses, commas, spaces, and braces:

<?php
namespace Vendor\Package;

class ClassName
{
    public function fooBarBaz($arg1, &$arg2, $arg3 = [])
    {
        // method body
    }
}

4.4. Method Arguments

In the argument list, there MUST NOT be a space before each comma, and there MUST be one space after each comma.

Method arguments with default values MUST go at the end of the argument list.

<?php
namespace Vendor\Package;

class ClassName
{
    public function foo($arg1, &$arg2, $arg3 = [])
    {
        // method body
    }
}

Argument lists MAY be split across multiple lines, where each subsequent line is indented once. When doing so, the first item in the list MUST be on the next line, and there MUST be only one argument per line.

When the argument list is split across multiple lines, the closing parenthesis and opening brace MUST be placed together on their own line with one space between them.

<?php
namespace Vendor\Package;

class ClassName
{
    public function aVeryLongMethodName(
        ClassTypeHint $arg1,
        &$arg2,
        array $arg3 = []
    ) {
        // method body
    }
}

4.5. abstract, final, and static

When present, the abstract and final declarations MUST precede the visibility declaration.

When present, the static declaration MUST come after the visibility declaration.

<?php
namespace Vendor\Package;

abstract class ClassName
{
    protected static $foo;

    abstract protected function zim();

    final public static function bar()
    {
        // method body
    }
}

4.6. Method and Function Calls

When making a method or function call, there MUST NOT be a space between the method or function name and the opening parenthesis, there MUST NOT be a space after the opening parenthesis, and there MUST NOT be a space before the closing parenthesis. In the argument list, there MUST NOT be a space before each comma, and there MUST be one space after each comma.

<?php
bar();
$foo->bar($arg1);
Foo::bar($arg2, $arg3);

Argument lists MAY be split across multiple lines, where each subsequent line is indented once. When doing so, the first item in the list MUST be on the next line, and there MUST be only one argument per line.

<?php
$foo->bar(
    $longArgument,
    $longerArgument,
    $muchLongerArgument
);

5. Control Structures

The general style rules for control structures are as follows:

    There MUST be one space after the control structure keyword

    There MUST NOT be a space after the opening parenthesis

    There MUST NOT be a space before the closing parenthesis

    There MUST be one space between the closing parenthesis and the opening brace

    The structure body MUST be indented once

    The closing brace MUST be on the next line after the body

The body of each structure MUST be enclosed by braces. This standardizes how the structures look, and reduces the likelihood of introducing errors as new lines get added to the body.
5.1. if, elseif, else

An if structure looks like the following. Note the placement of parentheses, spaces, and braces; and that else and elseif are on the same line as the closing brace from the earlier body.

<?php
if ($expr1) {
    // if body
} elseif ($expr2) {
    // elseif body
} else {
    // else body;
}

The keyword elseif SHOULD be used instead of else if so that all control keywords look like single words.
5.2. switch, case

A switch structure looks like the following. Note the placement of parentheses, spaces, and braces. The case statement MUST be indented once from switch, and the break keyword (or other terminating keyword) MUST be indented at the same level as the case body. There MUST be a comment such as // no break when fall-through is intentional in a non-empty case body.

<?php
switch ($expr) {
    case 0:
        echo 'First case, with a break';
        break;
    case 1:
        echo 'Second case, which falls through';
        // no break
    case 2:
    case 3:
    case 4:
        echo 'Third case, return instead of break';
        return;
    default:
        echo 'Default case';
        break;
}

5.3. while, do while

A while statement looks like the following. Note the placement of parentheses, spaces, and braces.

<?php
while ($expr) {
    // structure body
}

Similarly, a do while statement looks like the following. Note the placement of parentheses, spaces, and braces.

<?php
do {
    // structure body;
} while ($expr);

5.4. for

A for statement looks like the following. Note the placement of parentheses, spaces, and braces.

<?php
for ($i = 0; $i < 10; $i++) {
    // for body
}

5.5. foreach

A foreach statement looks like the following. Note the placement of parentheses, spaces, and braces.

<?php
foreach ($iterable as $key => $value) {
    // foreach body
}

5.6. try, catch

A try catch block looks like the following. Note the placement of parentheses, spaces, and braces.

<?php
try {
    // try body
} catch (FirstExceptionType $e) {
    // catch body
} catch (OtherExceptionType $e) {
    // catch body
}

6. Closures

Closures MUST be declared with a space after the function keyword, and a space before and after the use keyword.

The opening brace MUST go on the same line, and the closing brace MUST go on the next line following the body.

There MUST NOT be a space after the opening parenthesis of the argument list or variable list, and there MUST NOT be a space before the closing parenthesis of the argument list or variable list.

In the argument list and variable list, there MUST NOT be a space before each comma, and there MUST be one space after each comma.

Closure arguments with default values MUST go at the end of the argument list.

A closure declaration looks like the following. Note the placement of parentheses, commas, spaces, and braces:

<?php
$closureWithArgs = function ($arg1, $arg2) {
    // body
};

$closureWithArgsAndVars = function ($arg1, $arg2) use ($var1, $var2) {
    // body
};

Argument lists and variable lists MAY be split across multiple lines, where each subsequent line is indented once. When doing so, the first item in the list MUST be on the next line, and there MUST be only one argument or variable per line.

When the ending list (whether or arguments or variables) is split across multiple lines, the closing parenthesis and opening brace MUST be placed together on their own line with one space between them.

The following are examples of closures with and without argument lists and variable lists split across multiple lines.

<?php
$longArgs_noVars = function (
    $longArgument,
    $longerArgument,
    $muchLongerArgument
) {
   // body
};

$noArgs_longVars = function () use (
    $longVar1,
    $longerVar2,
    $muchLongerVar3
) {
   // body
};

$longArgs_longVars = function (
    $longArgument,
    $longerArgument,
    $muchLongerArgument
) use (
    $longVar1,
    $longerVar2,
    $muchLongerVar3
) {
   // body
};

$longArgs_shortVars = function (
    $longArgument,
    $longerArgument,
    $muchLongerArgument
) use ($var1) {
   // body
};

$shortArgs_longVars = function ($arg) use (
    $longVar1,
    $longerVar2,
    $muchLongerVar3
) {
   // body
};

Note that the formatting rules also apply when the closure is used directly in a function or method call as an argument.

<?php
$foo->bar(
    $arg1,
    function ($arg2) use ($var1) {
        // body
    },
    $arg3
);

7. Conclusion

There are many elements of style and practice intentionally omitted by this guide. These include but are not limited to:

    Declaration of global variables and global constants

    Declaration of functions

    Operators and assignment

    Inter-line alignment

    Comments and documentation blocks

    Class name prefixes and suffixes

    Best practices

Future recommendations MAY revise and extend this guide to address those or other elements of style and practice.


PSR-12 Coding Style Guide

Note
The PSR1, PSR2 and PSR12 Coding Standards are provided by FIG under a MIT license.
See license details: http://www.php-fig.org/bylaws/licensing-policies/
The original content of this page can be found at php-fig
1. Overview

This specification extends, expands and replaces PSR-2, the coding style guide and requires adherence to PSR-1, the basic coding standard.

Like PSR-2, the intent of this specification is to reduce cognitive friction when scanning code from different authors. It does so by enumerating a shared set of rules and expectations about how to format PHP code. This PSR seeks to provide a set way that coding style tools can implement, projects can declare adherence to and developers can easily relate to between different projects. When various authors collaborate across multiple projects, it helps to have one set of guidelines to be used among all those projects. Thus, the benefit of this guide is not in the rules themselves but the sharing of those rules.

PSR-2 was accepted in 2012 and since then a number of changes have been made to PHP which has implications for coding style guidelines. Whilst PSR-2 is very comprehensive of PHP functionality that existed at the time of writing, new functionality is very open to interpretation. This PSR, therefore, seeks to clarify the content of PSR-2 in a more modern context with new functionality available, and make the errata to PSR-2 binding.
Previous language versions

Throughout this document, any instructions MAY be ignored if they do not exist in versions of PHP supported by your project.
Example

This example encompasses some of the rules below as a quick overview:

<?php

declare(strict_types=1);

namespace Vendor\Package;

use Vendor\Package\{ClassA as A, ClassB, ClassC as C};
use Vendor\Package\SomeNamespace\ClassD as D;

use function Vendor\Package\{functionA, functionB, functionC};

use const Vendor\Package\{ConstantA, ConstantB, ConstantC};

class Foo extends Bar implements FooInterface
{
    public function sampleFunction(int $a, int $b = null): array
    {
        if ($a === $b) {
            bar();
        } elseif ($a > $b) {
            $foo->bar($arg1);
        } else {
            BazClass::bar($arg2, $arg3);
        }
    }

    final public static function bar()
    {
        // method body
    }
}

2. General
2.1 Basic Coding Standard

Code MUST follow all rules outlined in PSR-1.

The term ‘StudlyCaps’ in PSR-1 MUST be interpreted as PascalCase where the first letter of each word is capitalized including the very first letter.
2.2 Files

All PHP files MUST use the Unix LF (linefeed) line ending. All PHP files MUST end with a single blank line.

The closing ?> tag MUST be omitted from files containing only PHP.
2.3 Lines

There MUST NOT be a hard limit on line length.

The soft limit on line length MUST be 120 characters.

Lines SHOULD NOT be longer than 80 characters; lines longer than that SHOULD be split into multiple subsequent lines of no more than 80 characters each.

There MUST NOT be trailing whitespace at the end of lines.

Blank lines MAY be added to improve readability and to indicate related blocks of code except where explicitly forbidden.

There MUST NOT be more than one statement per line.
2.4 Indenting

Code MUST use an indent of 4 spaces for each indent level, and MUST NOT use tabs for indenting.
2.5 Keywords and Types

All PHP reserved keywords and types MUST be in lower case.

Any new types and keywords added to future PHP versions MUST be in lower case.

Short form of type keywords MUST be used i.e. bool instead of boolean, int instead of integer etc.
3. Declare Statements, Namespace, and Import Statements

The header of a PHP file may consist of a number of different blocks. If present, each of the blocks below MUST be separated by a single blank line, and MUST NOT contain a blank line. Each block MUST be in the order listed below, although blocks that are not relevant may be omitted.

    Opening <?php tag.

    File-level docblock.

    One or more declare statements.

    The namespace declaration of the file.

    One or more class-based use import statements.

    One or more function-based use import statements.

    One or more constant-based use import statements.

    The remainder of the code in the file.

When a file contains a mix of HTML and PHP, any of the above sections may still be used. If so, they MUST be present at the top of the file, even if the remainder of the code consists of a closing PHP tag and then a mixture of HTML and PHP.

When the opening <?php tag is on the first line of the file, it MUST be on its own line with no other statements unless it is a file containing markup outside of PHP opening and closing tags.

Import statements MUST never begin with a leading backslash as they must always be fully qualified.

The following example illustrates a complete list of all blocks:

<?php

/**
 * This file contains an example of coding styles.
 */

declare(strict_types=1);

namespace Vendor\Package;

use Vendor\Package\{ClassA as A, ClassB, ClassC as C};
use Vendor\Package\SomeNamespace\ClassD as D;
use Vendor\Package\AnotherNamespace\ClassE as E;

use function Vendor\Package\{functionA, functionB, functionC};
use function Another\Vendor\functionD;

use const Vendor\Package\{CONSTANT_A, CONSTANT_B, CONSTANT_C};
use const Another\Vendor\CONSTANT_D;

/**
 * FooBar is an example class.
 */
class FooBar
{
    // ... additional PHP code ...
}

Compound namespaces with a depth of more than two MUST NOT be used. Therefore the following is the maximum compounding depth allowed:

<?php

use Vendor\Package\SomeNamespace\{
  SubnamespaceOne\ClassA,
  SubnamespaceOne\ClassB,
  SubnamespaceTwo\ClassY,
  ClassZ,
};

And the following would not be allowed:

<?php

use Vendor\Package\SomeNamespace\{
    SubnamespaceOne\AnotherNamespace\ClassA,
    SubnamespaceOne\ClassB,
    ClassZ,
};

When wishing to declare strict types in files containing markup outside PHP opening and closing tags, the declaration MUST be on the first line of the file and include an opening PHP tag, the strict types declaration and closing tag.

For example:

<?php declare(strict_types=1) ?>
<html>
<body>
    <?php
        // ... additional PHP code ...
    ?>
</body>
</html>

Declare statements MUST contain no spaces and MUST be exactly declare(strict_types=1) (with an optional semi-colon terminator).

Block declare statements are allowed and MUST be formatted as below. Note position of braces and spacing:

declare(ticks=1) {
    // some code
}

4. Classes, Properties, and Methods

The term “class” refers to all classes, interfaces, and traits.

Any closing brace MUST NOT be followed by any comment or statement on the same line.

When instantiating a new class, parentheses MUST always be present even when there are no arguments passed to the constructor.

new Foo();

4.1 Extends and Implements

The extends and implements keywords MUST be declared on the same line as the class name.

The opening brace for the class MUST go on its own line; the closing brace for the class MUST go on the next line after the body.

Opening braces MUST be on their own line and MUST NOT be preceded or followed by a blank line.

Closing braces MUST be on their own line and MUST NOT be preceded by a blank line.

<?php

namespace Vendor\Package;

use FooClass;
use BarClass as Bar;
use OtherVendor\OtherPackage\BazClass;

class ClassName extends ParentClass implements \ArrayAccess, \Countable
{
    // constants, properties, methods
}

Lists of implements and, in the case of interfaces, extends MAY be split across multiple lines, where each subsequent line is indented once. When doing so, the first item in the list MUST be on the next line, and there MUST be only one interface per line.

<?php

namespace Vendor\Package;

use FooClass;
use BarClass as Bar;
use OtherVendor\OtherPackage\BazClass;

class ClassName extends ParentClass implements
    \ArrayAccess,
    \Countable,
    \Serializable
{
    // constants, properties, methods
}

4.2 Using traits

The use keyword used inside the classes to implement traits MUST be declared on the next line after the opening brace.

<?php

namespace Vendor\Package;

use Vendor\Package\FirstTrait;

class ClassName
{
    use FirstTrait;
}

Each individual trait that is imported into a class MUST be included one-per-line and each inclusion MUST have its own use import statement.

<?php

namespace Vendor\Package;

use Vendor\Package\FirstTrait;
use Vendor\Package\SecondTrait;
use Vendor\Package\ThirdTrait;

class ClassName
{
    use FirstTrait;
    use SecondTrait;
    use ThirdTrait;
}

When the class has nothing after the use import statement, the class closing brace MUST be on the next line after the use import statement.

<?php

namespace Vendor\Package;

use Vendor\Package\FirstTrait;

class ClassName
{
    use FirstTrait;
}

Otherwise, it MUST have a blank line after the use import statement.

<?php

namespace Vendor\Package;

use Vendor\Package\FirstTrait;

class ClassName
{
    use FirstTrait;

    private $property;
}

When using the insteadof and as operators they must be used as follows taking note of indentation, spacing, and new lines.

<?php

class Talker
{
    use A;
    use B {
        A::smallTalk insteadof B;
    }
    use C {
        B::bigTalk insteadof C;
        C::mediumTalk as FooBar;
    }
}

4.3 Properties and Constants

Visibility MUST be declared on all properties.

Visibility MUST be declared on all constants if your project PHP minimum version supports constant visibilities (PHP 7.1 or later).

The var keyword MUST NOT be used to declare a property.

There MUST NOT be more than one property declared per statement.

Property names MUST NOT be prefixed with a single underscore to indicate protected or private visibility. That is, an underscore prefix explicitly has no meaning.

There MUST be a space between type declaration and property name.

A property declaration looks like the following:

<?php

namespace Vendor\Package;

class ClassName
{
    public $foo = null;
    public static int $bar = 0;
}

4.4 Methods and Functions

Visibility MUST be declared on all methods.

Method names MUST NOT be prefixed with a single underscore to indicate protected or private visibility. That is, an underscore prefix explicitly has no meaning.

Method and function names MUST NOT be declared with space after the method name. The opening brace MUST go on its own line, and the closing brace MUST go on the next line following the body. There MUST NOT be a space after the opening parenthesis, and there MUST NOT be a space before the closing parenthesis.

A method declaration looks like the following. Note the placement of parentheses, commas, spaces, and braces:

<?php

namespace Vendor\Package;

class ClassName
{
    public function fooBarBaz($arg1, &$arg2, $arg3 = [])
    {
        // method body
    }
}

A function declaration looks like the following. Note the placement of parentheses, commas, spaces, and braces:

<?php

function fooBarBaz($arg1, &$arg2, $arg3 = [])
{
    // function body
}

4.5 Method and Function Arguments

In the argument list, there MUST NOT be a space before each comma, and there MUST be one space after each comma.

Method and function arguments with default values MUST go at the end of the argument list.

<?php

namespace Vendor\Package;

class ClassName
{
    public function foo(int $arg1, &$arg2, $arg3 = [])
    {
        // method body
    }
}

Argument lists MAY be split across multiple lines, where each subsequent line is indented once. When doing so, the first item in the list MUST be on the next line, and there MUST be only one argument per line.

When the argument list is split across multiple lines, the closing parenthesis and opening brace MUST be placed together on their own line with one space between them.

<?php

namespace Vendor\Package;

class ClassName
{
    public function aVeryLongMethodName(
        ClassTypeHint $arg1,
        &$arg2,
        array $arg3 = []
    ) {
        // method body
    }
}

When you have a return type declaration present, there MUST be one space after the colon followed by the type declaration. The colon and declaration MUST be on the same line as the argument list closing parenthesis with no spaces between the two characters.

<?php

declare(strict_types=1);

namespace Vendor\Package;

class ReturnTypeVariations
{
    public function functionName(int $arg1, $arg2): string
    {
        return 'foo';
    }

    public function anotherFunction(
        string $foo,
        string $bar,
        int $baz
    ): string {
        return 'foo';
    }
}

In nullable type declarations, there MUST NOT be a space between the question mark and the type.

<?php

declare(strict_types=1);

namespace Vendor\Package;

class ReturnTypeVariations
{
    public function functionName(?string $arg1, ?int &$arg2): ?string
    {
        return 'foo';
    }
}

When using the reference operator & before an argument, there MUST NOT be a space after it, like in the previous example.

There MUST NOT be a space between the variadic three dot operator and the argument name:

public function process(string $algorithm, ...$parts)
{
    // processing
}

When combining both the reference operator and the variadic three dot operator, there MUST NOT be any space between the two of them:

public function process(string $algorithm, &...$parts)
{
    // processing
}

4.6 abstract, final, and static

When present, the abstract and final declarations MUST precede the visibility declaration.

When present, the static declaration MUST come after the visibility declaration.

<?php

namespace Vendor\Package;

abstract class ClassName
{
    protected static $foo;

    abstract protected function zim();

    final public static function bar()
    {
        // method body
    }
}

4.7 Method and Function Calls

When making a method or function call, there MUST NOT be a space between the method or function name and the opening parenthesis, there MUST NOT be a space after the opening parenthesis, and there MUST NOT be a space before the closing parenthesis. In the argument list, there MUST NOT be a space before each comma, and there MUST be one space after each comma.

<?php

bar();
$foo->bar($arg1);
Foo::bar($arg2, $arg3);

Argument lists MAY be split across multiple lines, where each subsequent line is indented once. When doing so, the first item in the list MUST be on the next line, and there MUST be only one argument per line. A single argument being split across multiple lines (as might be the case with an anonymous function or array) does not constitute splitting the argument list itself.

<?php

$foo->bar(
    $longArgument,
    $longerArgument,
    $muchLongerArgument
);

<?php

somefunction($foo, $bar, [
  // ...
], $baz);

$app->get('/hello/{name}', function ($name) use ($app) {
    return 'Hello ' . $app->escape($name);
});

5. Control Structures

The general style rules for control structures are as follows:

    There MUST be one space after the control structure keyword

    There MUST NOT be a space after the opening parenthesis

    There MUST NOT be a space before the closing parenthesis

    There MUST be one space between the closing parenthesis and the opening brace

    The structure body MUST be indented once

    The body MUST be on the next line after the opening brace

    The closing brace MUST be on the next line after the body

The body of each structure MUST be enclosed by braces. This standardizes how the structures look and reduces the likelihood of introducing errors as new lines get added to the body.
5.1 if, elseif, else

An if structure looks like the following. Note the placement of parentheses, spaces, and braces; and that else and elseif are on the same line as the closing brace from the earlier body.

<?php

if ($expr1) {
    // if body
} elseif ($expr2) {
    // elseif body
} else {
    // else body;
}

The keyword elseif SHOULD be used instead of else if so that all control keywords look like single words.

Expressions in parentheses MAY be split across multiple lines, where each subsequent line is indented at least once. When doing so, the first condition MUST be on the next line. The closing parenthesis and opening brace MUST be placed together on their own line with one space between them. Boolean operators between conditions MUST always be at the beginning or at the end of the line, not a mix of both.

<?php

if (
    $expr1
    && $expr2
) {
    // if body
} elseif (
    $expr3
    && $expr4
) {
    // elseif body
}

5.2 switch, case

A switch structure looks like the following. Note the placement of parentheses, spaces, and braces. The case statement MUST be indented once from switch, and the break keyword (or other terminating keywords) MUST be indented at the same level as the case body. There MUST be a comment such as // no break when fall-through is intentional in a non-empty case body.

<?php

switch ($expr) {
    case 0:
        echo 'First case, with a break';
        break;
    case 1:
        echo 'Second case, which falls through';
        // no break
    case 2:
    case 3:
    case 4:
        echo 'Third case, return instead of break';
        return;
    default:
        echo 'Default case';
        break;
}

Expressions in parentheses MAY be split across multiple lines, where each subsequent line is indented at least once. When doing so, the first condition MUST be on the next line. The closing parenthesis and opening brace MUST be placed together on their own line with one space between them. Boolean operators between conditions MUST always be at the beginning or at the end of the line, not a mix of both.

<?php

switch (
    $expr1
    && $expr2
) {
    // structure body
}

5.3 while, do while

A while statement looks like the following. Note the placement of parentheses, spaces, and braces.

<?php

while ($expr) {
    // structure body
}

Expressions in parentheses MAY be split across multiple lines, where each subsequent line is indented at least once. When doing so, the first condition MUST be on the next line. The closing parenthesis and opening brace MUST be placed together on their own line with one space between them. Boolean operators between conditions MUST always be at the beginning or at the end of the line, not a mix of both.

<?php

while (
    $expr1
    && $expr2
) {
    // structure body
}

Similarly, a do while statement looks like the following. Note the placement of parentheses, spaces, and braces.

<?php

do {
    // structure body;
} while ($expr);

Expressions in parentheses MAY be split across multiple lines, where each subsequent line is indented at least once. When doing so, the first condition MUST be on the next line. Boolean operators between conditions MUST always be at the beginning or at the end of the line, not a mix of both.

<?php

do {
    // structure body;
} while (
    $expr1
    && $expr2
);

5.4 for

A for statement looks like the following. Note the placement of parentheses, spaces, and braces.

<?php

for ($i = 0; $i < 10; $i++) {
    // for body
}

Expressions in parentheses MAY be split across multiple lines, where each subsequent line is indented at least once. When doing so, the first expression MUST be on the next line. The closing parenthesis and opening brace MUST be placed together on their own line with one space between them.

<?php

for (
    $i = 0;
    $i < 10;
    $i++
) {
    // for body
}

5.5 foreach

A foreach statement looks like the following. Note the placement of parentheses, spaces, and braces.

<?php

foreach ($iterable as $key => $value) {
    // foreach body
}

5.6 try, catch, finally

A try-catch-finally block looks like the following. Note the placement of parentheses, spaces, and braces.

<?php

try {
    // try body
} catch (FirstThrowableType $e) {
    // catch body
} catch (OtherThrowableType | AnotherThrowableType $e) {
    // catch body
} finally {
    // finally body
}

6. Operators

Style rules for operators are grouped by arity (the number of operands they take).

When space is permitted around an operator, multiple spaces MAY be used for readability purposes.

All operators not described here are left undefined.
6.1. Unary operators

The increment/decrement operators MUST NOT have any space between the operator and operand.

$i++;
++$j;

Type casting operators MUST NOT have any space within the parentheses:

$intValue = (int) $input;

6.2. Binary operators

All binary [arithmetic][], [comparison][], [assignment][], [bitwise][], [logical][], [string][], and [type][] operators MUST be preceded and followed by at least one space:

if ($a === $b) {
    $foo = $bar ?? $a ?? $b;
} elseif ($a > $b) {
    $foo = $a + $b * $c;
}

6.3. Ternary operators

The conditional operator, also known simply as the ternary operator, MUST be preceded and followed by at least one space around both the ? and : characters:

$variable = $foo ? 'foo' : 'bar';

When the middle operand of the conditional operator is omitted, the operator MUST follow the same style rules as other binary [comparison][] operators:

$variable = $foo ?: 'bar';

7. Closures

Closures MUST be declared with a space after the function keyword, and a space before and after the use keyword.

The opening brace MUST go on the same line, and the closing brace MUST go on the next line following the body.

There MUST NOT be a space after the opening parenthesis of the argument list or variable list, and there MUST NOT be a space before the closing parenthesis of the argument list or variable list.

In the argument list and variable list, there MUST NOT be a space before each comma, and there MUST be one space after each comma.

Closure arguments with default values MUST go at the end of the argument list.

If a return type is present, it MUST follow the same rules as with normal functions and methods; if the use keyword is present, the colon MUST follow the use list closing parentheses with no spaces between the two characters.

A closure declaration looks like the following. Note the placement of parentheses, commas, spaces, and braces:

<?php

$closureWithArgs = function ($arg1, $arg2) {
    // body
};

$closureWithArgsAndVars = function ($arg1, $arg2) use ($var1, $var2) {
    // body
};

$closureWithArgsVarsAndReturn = function ($arg1, $arg2) use ($var1, $var2): bool {
    // body
};

Argument lists and variable lists MAY be split across multiple lines, where each subsequent line is indented once. When doing so, the first item in the list MUST be on the next line, and there MUST be only one argument or variable per line.

When the ending list (whether of arguments or variables) is split across multiple lines, the closing parenthesis and opening brace MUST be placed together on their own line with one space between them.

The following are examples of closures with and without argument lists and variable lists split across multiple lines.

<?php

$longArgs_noVars = function (
    $longArgument,
    $longerArgument,
    $muchLongerArgument
) {
   // body
};

$noArgs_longVars = function () use (
    $longVar1,
    $longerVar2,
    $muchLongerVar3
) {
   // body
};

$longArgs_longVars = function (
    $longArgument,
    $longerArgument,
    $muchLongerArgument
) use (
    $longVar1,
    $longerVar2,
    $muchLongerVar3
) {
   // body
};

$longArgs_shortVars = function (
    $longArgument,
    $longerArgument,
    $muchLongerArgument
) use ($var1) {
   // body
};

$shortArgs_longVars = function ($arg) use (
    $longVar1,
    $longerVar2,
    $muchLongerVar3
) {
   // body
};

Note that the formatting rules also apply when the closure is used directly in a function or method call as an argument.

<?php

$foo->bar(
    $arg1,
    function ($arg2) use ($var1) {
        // body
    },
    $arg3
);

8. Anonymous Classes

Anonymous Classes MUST follow the same guidelines and principles as closures in the above section.

<?php

$instance = new class {};

The opening brace MAY be on the same line as the class keyword so long as the list of implements interfaces does not wrap. If the list of interfaces wraps, the brace MUST be placed on the line immediately following the last interface.

<?php

// Brace on the same line
$instance = new class extends \Foo implements \HandleableInterface {
    // Class content
};

// Brace on the next line
$instance = new class extends \Foo implements
    \ArrayAccess,
    \Countable,
    \Serializable
{
    // Class content
};


Python PEPs

For Python code the Python Enhancement Proposals (PEPs) apply. See the Python Developer’s Guide for detailed information. The most basic one is PEP8: Style Guide for Python Code. Compliance with PEP8 can be checked using the Python style guide checker.


Architecture

The main focus of the OPNsense project is to provide a secure and manageable platform for all your security applications. This means high quality software that is easily maintainable and bug free. We think that having a framework with a clear separation of concerns is essential to achieving these goals.

OPNsense is a fork of pfSense ®. The existing code base of pfSense ® does not always apply a clear separation of concerns. This means we need a transition of the old (legacy) code base to a new one with a clear separation. We have chosen a gradual transition to avoid a big bang and keep the product feature rich while increasing code quality. This enables simple addition of new features with less bugs and shorter time to market.

This article describes how this will be achieved.
High-level architecture

OPNsense Components.png

As the above model shows there are two main areas in our stack, the frontend implemented with PHP/Phalcon and the backend using a custom service built in Python.

The frontend handles user interaction and communicates with the backend service. Applying configuration changes, monitoring and controlling services offered by OPNsense is done by the backend service.

By using a fully configurable backend service, we avoid hardcoding of services and ease the implementation of new features.

The frontend stack delivers a model driven approach to handle configuration data, including automatic validation.

Manipulation of the core configuration file is handled at the frontend model; the backend service is merely a consumer of the information provided.
Backend Architecture

OPNsense backend.png

Configd, is responsible for the core system interaction like starting and stopping of daemons and generating configuration files for used services and applications.

The daemon listens on a unix domain socket and is capable of executing actions defined in it’s own configuration directory (“/usr/local/opnsense/service/conf/actions_*.conf”).

Currently there are two types of services implemented in the daemon:

    script : execute external (rc) scripts

    inline : perform inline actions which are part of configd, currently only template generation.


Template generation is handled by Jinja2 (http://jinja.pocoo.org/), more information on how to create application templates can be found at Using Templates.
Frontend Architecture

OPNsense frontend.png
Routing

The OPNsense framework uses components from Phalcon where possible; the first layer initializes Phalcon’s routing, which handles requests and delivers them to the controller based on its url. User content is generated using Volt templates, which are picked by the controller. Because Phalcon’s default Models function with (relational) databases and we are using XML data, our model implementation is custom. But wherever possible we use components from Phalcon (for example, validation is handled using Phalcon’s classes). For a detailed description on the routing principles used in OPNsense, visit Frontend Routing.
Controllers and views

Not all parts of the framework are already implemented, but by deriving all controllers from the base in the OPNsense project it’s easy to extend and adapt to future needs. Documentation on how to implement controllers, with the use of views, can be found at Using controllers and views.
Models

All models are defined by a combination of a class and an XML containing a (nested) definition. More information on defining models can be found at the frontend model page Creating Models.
Communication

Communication to the backend service is handled via a unix domain socket.
Core system

The core of OPNsense is powered by an almost standard FreeBSD ® system extended with packages using the pkg system. GIT is used for version control and the repositories are split into 4 parts:

    src : the base (FreeBSD ®) system

    ports : the ports collection containing third party software

    core : the OPNsense gui and system configuration parts

    tools : easy tools to build OPNsense

Tip
For detailed information about the development workflow see:
OPNsense development workflow


Backend

The OPNsense backend consists of several components (see Architecture for a full stack description).

Our core backend service (configd) is implemented using Python. and provides two main features:

    Service interaction (using configd actions)

    Generation of configuration data (using templates)

Because some of the codebase still integrates with our legacy codebase, we provide additional plugin options for the following components:

    Services (the services status)

    Syslog (define syslog targets)

    Interface (register interfaces, firewall use etc.)

    Service configuration (legacy service configuration, new style uses configd templates)

Services which need to be executed at system startup can use rc(8) or our syshook system.

    Overview
    Bootup / autorun options
    CARP status
    Using configd
    Using plugins
    Using Templates


Overview

The life of a service starts during the boot process, but with different hooks available, sometimes it is challenging to find the correct one. This paragraph aims to explain the various integration spots availabe, which are being explained in more detail in the rest of the chapter.
Bootup

After the kernel is loaded and the machine starts to boot, the following integration points are being executed in sequence:

    syshook/early, simple shell scripts to run before any network services are loaded, can for example be used to load specific drivers.

    plugins/device, register and create devices, services like OpenVPN use this on our end to make sure tun and tap devices exist before doing further configuration.

    plugins/configure/early, configure early event in bootup process, before normal services are being started (things like ssh and the webconfigurator use this spot)

    plugins/firewall allows for automatic firewall (nat) rule registration in cases where the service is able to ship its own rules. (some do this optionally for easy setup)

    plugins/configure/vpn, configure vpn event, vpn type services are being configured here (e.g. IPsec, OpenVPN)

    plugins/configure/bootup, configure bootup event, normal legacy service configuration, when not using the rc(8) system (for example: unbound, ntpd)

    syshook/start, simple shell scripts to run after all networking has been setup.

    rc(8), regular rc(8) scripts (executed using the above the rc.syshook.d/start`)

Tip

Use pluginctl -c to display available events and the plugins attached to them.
Normal operation

Now the system is booted and events may take place, some of the common integration points with their purpose are listed below:

    syshook/carp, when a high-availability node changes roles from/to master or backup, these scripts are being executed. This offers the ability to prevent client services from connecting when in the wrong mode.

    plugins/configure/newwanip will be triggered after an interface retrieves a new address.

    plugins/interface handles dynamic registration of new (virtual) interfaces.

    plugins/syslog registers syslog facilities

    plugins/xmlrpc registers configuration synchronisation points.

Shutdown (reboot)

When the system is shutdown or being rebooted, we can hook actions using the syshook/stop script directory. Services like the backup hook into this to flush contents before being terminated.


Bootup / autorun options
syshook

OPNsense offers an easy method to plug in custom scripts during boot stages and assorted system events.

Syshook scripts should be installed in:

/usr/local/etc/rc.syshook.d/<subdir>/

They can contain any executable file (e.g. shell scripts) in the following subdirectories:

    backup

            scripts used for periodic backup and restore

    carp

            scripts used for CARP MASTER / BACKUP events

    config

            scripts used when a configuration change took place (config.xml changed).

Note

This event is intended to be atomic for every changed revision, it’s triggered using configd system event config_changed and is loosely coupled via a syslog-ng handler within the standard Config->save() method. The syshook event contains a pointer to the backup file in question (e.g. /conf/backup/config-1601651332.5394.xml), so the consumer (script) knows which revision to process.

Tip

Try to keep custom config handlers as small and efficient as possible since the number of triggered events can grow rapidly.

    early

            start script before system network startup

    monitor (deprecated)

            scripts handling gateway monitoring alerts, no longer in use by core but provided for compatibility

    start

            start script after system network startup

    stop

            stop script before normal system shutdown

    update

            update script after core package update (post-update)

    upgrade

            upgrade script migration tool for major upgrade (pre-upgrade)

File names can use a number prefix “XX-” to retain a particular order. “20-” is typically used for core scripts, while “50-” is used for plugins.

Example (vmware guestd start, filename /usr/local/etc/rc.syshook.d/early/50-vmware)

#!/bin/sh

export vmware_guest_vmblock_enable="YES"
export vmware_guest_vmhgfs_enable="YES"
export vmware_guest_vmmemctl_enable="YES"
export vmware_guest_vmxnet_enable="YES"

/usr/local/etc/rc.d/vmware-kmod start

Do not forget to set executable permissions on your syshook files.
rc(8)

Part of the bootup process of OPNsense is probing the available rc(8) configuration files in /etc/rc.conf.d/, when a daemon is enabled, the system will call the regular rc(8) start command.

In case the daemon needs some extra preparation, an additional “bootup” script can be provided, which will be run before executing normal “start”.

Example (from a configured squid proxy server using /etc/rc.conf.d/squid):

squid_enable=YES
squid_opnsense_bootup_run="/usr/local/opnsense/scripts/proxy/setup.sh"

The configd template system can be used to generate the necessary configuration file(s).

CARP status
General

The CARP (Common Address Redundancy Protocol) protocol is quite a powerful feature of the firewall, which allows multiple machines to share IPv4 / IPv6 addresses among each other.

To determine if a host should be master, it listens on the network for carp broadcast packets and determines if its priority is higher than the others on the network (the highest advertising frequency wins).

A higher advskew (Advertising Frequency Skew) will lower its advertisements and renders the node less attractive of being a master.

Combined with the advskew value, the system also uses the current demotion value (sysctl net.inet.carp.demotion) which will be added to its preset advskew in the gui. This value informs the user about the health of the node. When its value is 0, all is ok, when some cable is unplugged it will for example add a value to the “demotion counter”.

The following demotion events are available by default in the kernel.

    Interface down (net.inet.carp.ifdown_demotion_factor)

    Error sending announcements (net.inet.carp.senderr_demotion_factor)

    Busy processing pfsync updates (net.pfsync.carp_demotion_factor)

Custom service hooks

In some cases the status of the node should be influenced by the services on the machine, for example when a dynamic routing system isn’t initialized yet, it might be better to wait before propagating as being a better alternative in the cluster.

This mechanism should be comparable to what is available for pfsync ( when states are being synced, we propagate with a higher advskew using the value in net.pfsync.carp_demotion_factor)

The idea of the service status hook is to register service check scripts into a single directory and validate status as a whole (if any of the test scripts fail, we add a demotion factor for “services”).

Note

Some inspiration for this hook came from how OpenBSD handles demotion in ospfd (https://man.openbsd.org/ospfd.conf.5 –> demote)

To create new tests, just add executable scripts in the following directory, which exits 0 if all is good and something other than 0 on issues (e.g. exit 1).

/usr/local/etc/rc.carp_service_status.d/<service_test>

Tip

Make sure test scripts are as lightweight as possible, so it wouldn’t mind of they run more often than strictly needed.

Note

We use a high demotion value (

) when one of the services fails its test, so we don’t need to remember our current state (reading sysctl net.inet.carp.demotion would be enough) and can use a bitwise and to check if it’s set.

A simple test which always reports service as being down, can be as simple as the following:
/usr/local/etc/rc.carp_service_status.d/test_service

#!/bin/sh

exit 1

Trigger event

To ask the system to evaluate status again, we should call the carp_service_status script, using configd so we don’t need to be root to trigger a test.

configctl interface update carp service_status

Note

Services using this facility should emit this event themself after normal operation has proceeded.
Logging

Carp status changes are usually logged to syslog (System ‣ Log Files ‣ General), so does our carp service status check.

When the test service example is installed, we would expect a log line which looks like the following after triggering an event:

....  OPNsense carp: carp demoted by 1048576 due to service disruption (services: test_service)

This informs the user about the amount of demotion and which services are responsible for it.

When service status is recovered again, it will send something like the following to syslog.

..... carp promoted by 1048576 due to service recovery


Using configd
General

To add new services and system calls, which can be used from the frontend system or command line, you can create configd actions.

All available templates should be installed at the following location on the OPNsense system:

/usr/local/opnsense/service/conf/actions.d/

Please note that all actions which should be accessible from the frontend should have a registered configd action, if possible use standard rc(8) scripts for service start/stop.
Naming convention

Service templates should use distinctive names to identify your service and contain simple / clear actions.

For example, we will describe the template for ssh, which is installed by default.

File name:

/usr/local/opnsense/service/conf/actions.d/actions_sshd.conf

Our ssh service has two actions available:

    restart

            starts / restarts ssh service

    stop

            stops / kills all ssh daemons

[restart]
command:/usr/local/etc/rc.sshd
parameters:
type:script
message:starting sshd

[stop]
command:/bin/pkill -TERM sshd; exit 0
parameters:
type:script
message:stop sshd

Between brackets [] you find the name of the action, the definition of the actual call is defined in the following parameter:value pairs. When a service or module provides a lot of actions, it sometimes is practical to add another level of operation.

For example, the restart service call for this service will translate to: sshd restart

In case we have an action like filter diag info, you can create an actions_filter.conf which contains a section [diag.info].
Action properties

Property
	

Syntax
	

Description

command
	

text
	

shell command string to execute

parameters
	

%s for every parameter
	

list of parameters to use, example : /i %s

type
	

script|script_output
	

type of call:

        script (only return exit status)

        script_output (return result)

message
	

text
	

Message to send to syslog (you can use %s parameters)

description
	

text
	

User-friendly description, also allows GUI usage
Test action

To test a new configd action, please restart the configd service first using:

service configd restart

Next use the supplied helper command to execute our action:

configctl sshd restart

Extending the Environment

Configd’s own configuration can be found in the configd.conf file. In some cases it can be practical to extend the envrionment with additional settings for the configd actions to use.

To add environment variables, create a new config file in the conf/configd.conf.d/ directory using the .conf extension containing an [environment] section. For example, to add a proxy server (for the firmware updater), use settings like these:
/usr/local/opnsense/service/conf/configd.conf.d/proxy.conf

[environment]
HTTP_PROXY=http://proxy-adddress:8080
HTTPS_PROXY=http://proxy-adddress:8080

Note

After changing the configd configuration, don’t forget to restart the configd service via the gui or service configd restart (as root).

Warning

When using the same settings as already specified in the base configuration, these settings will be overwritten. The parsing order of configuration files is to read all vendor shipped properties first and read additional files next. Last property found is the one being used (e.g. specifying a new PATH in the environment, will overwrite the one being shipped in our configd.conf.)


Using plugins
General

Plugins are located in the following location:

/usr/local/etc/inc/plugins.inc.d/

And contain files with the extension “.inc”.

All automatically registered functions start with the name of the file (without the extension), followed by the purpose. For example vpn_configure would be the configure handle in a plugin file name vpn.inc.

With the use of these plugins, you have the ability to hook into different areas of the system, such as registration of new interface types and making sure services are shown in the regular service overview.

Note

When plugins fail and cause PHP errors, these will be collected in /tmp/PHP_errors.log, these plugins are not registered and executed when emitting such errors
Services

To register services, the <plugin>_services() function should return a structure containing its name, description and operating properties.

function myplugin_services()
{
    $service = array();
    $service['name'] = 'myservice';
    $service['description'] = gettext('My service');
    $service['configd']['restart'] = array('myservice restart');
    $service['configd']['start'] = array('myservice start');
    $service['configd']['stop'] = array('myservice stop');
    $services[] = $pconfig;
    return $services;
}

To list all available services from the command line, you can use pluginctl (bundled with our core system).

pluginctl -s

The same tool can also be used to execute the [re]start/stop operations, for the example above, a restart would look like:

pluginctl -s myservice restart

Configure

The configure plugin can be used to catch certain events, such as bootup, newwanip and others.

A small sample of a registration is shown below, which registers the functions myplugin_configure() on bootup and myplugin_configure()_vpn on vpn state change where the latter is accepting two (2) parameters at most.

function myplugin_configure()
{
    return array(
        'bootup' => array('myplugin_configure')
        'vpn' => array('myplugin_configure_vpn:2')
    );
}

To list all available hooks, you can use pluginctl without parameters:

pluginctl -c

Below you will find an incomplete list of the most common used events that are handled at the moment:

Event
	

When

early
	

Early in bootup process, before normal services are started (things like ssh and the webconfigurator use this spot)

bootup
	

Bootup, normal legacy service configuration, when not using the rc(8) system (for example: unbound, ntpd)

newwanip
	

Triggered after configuration of a new interface address, expects a maximum of two positional parameters ($verbose and $interface).

pluginctl can also be used to trigger a specific event, such as:

pluginctl -c monitor

Firewall

To register firewall rules, create a function called <plugin>_firewall(), this will pass a plugin object you can use to generate new firewall rules.

A very simplified example of such a rule is included below:

function myplugin_firewall(\OPNsense\Firewall\Plugin $fw) {
    $fw->registerFilterRule(500000, array("direction" => "in", "protocol" => "udp", "to_port" => 9999));
}

configctl can be used to reload the firewall and test your plugin:

configctl filter reload

This will generate a rule like (in /tmp/rules.debug):

pass in quick proto udp from {any} to {any} port {9999}

Interface

To register new (virtual) interfaces, create a function called <plugin>_interfaces(), which should return a named array containing the unique interface name as key (enc0 for ipsec for example).

Every item should contain the following properties:

Property
	

Syntax
	

Description

enable
	

boolean
	

interface enabled, if so it will be saved in the config

descr
	

text
	

User readable description

networks
	

array, [network, mask]
	

list of named arrays containing remote networks

type
	

text
	

“none”

if
	

text
	

physical interface (e.g. enc0)

virtual
	

boolean
	

Virtual interface, true/false

Example:

function myplugin_interfaces()
{
    global $config;

    $interfaces = array();
    if (isset($config['myplugin']['enable'])) {
        $oic = array("enable" => true);
        $oic['if'] = 'tun0';
        $oic['descr'] = 'myplugin';
        $oic['type'] = "none";
        $oic['virtual'] = true;
        $oic['networks'] = array();
        $interfaces['tun0'] = $oic;
    }

    return $interfaces;
}

Device

To register virtual network devices types which can be used verbatim or manually assigned to interfaces, the <plugin>_devices() function should return a structure containing such devices and additional definitions.

Device registration covers a number of aspects such as interfaces assignment page presentation, external (re)configuration function, automatic configuration of assigned devices, and matching device name pattern amongst others. Available settings are described below:

Property
	

Syntax
	

Description

function
	

text
	

Calls function of that name with device name as argument

volatile
	

boolean
	

This interface can disappear so do not attempt boot recovery

configurable
	

boolean
	

Assigned interface can set IPv4/IPv6 mode if true or missing

pattern
	

text
	

Regex to identify device names in bulk

type
	

text
	

Unqiue type setting required for assignments page

names
	

array [ see below ]
	

List of devices with individual names as associative keys

…descr
	

text
	

Descriptive text of device, e.g. for assignments page

…ifdescr
	

text
	

Verbatim description, e.g. as stored in config.xml

…name
	

text
	

Device name same as array key for convenient access

Example:

function my myplugin_devices()
{
    $devices = [];

    $devices[] = [
        'function' => 'function_name_to_configure',
        'names' => ['dev0' => [
            'descr' => 'descriptive text',
            'ifdescr' => 'verbatim description',
            'name' => 'dev0',
        ]],
        'pattern' => '^dev',
        'volatile' => true,
        'type' => 'bridge',
    ];

    return $devices;
}

Syslog

To register syslog targets, the <plugin>_syslog() function should return a structure containing targets and definitions.

function myplugin_syslog()
{
    $logfacilities = array();
    $logfacilities['myplugin'] = array(
        'facility' => array('myplugin'),
    );
    return $logfacilities;
}

Note

As of OPNsense 19.7 Syslog-NG is included in our base system, these files will only be used to identify applications for custom syslog remote targets in System->Settings->Logging / targets.

To test if a service registration functions properly, just restart the syslog facility:

pluginctl -s syslogd restart

Note

In order to define local targets for Syslog-NG you can just add local filters which will be collected into one large syslog configuration. The readme on GitHub describes the process. When running into issues, always make sure to manually restart syslog-ng first (service syslog-ng restart), definition errors won’t be written into any log.

Note

In case additional source sockets should be used by Syslog-NG you can add files in /usr/local/opnsense/service/templates/OPNsense/Syslog/sources/ containing definitions. The 001-local.conf file contains examples from jailed core services.
XMLRPC (HA) sync

When a configuration section should be exposed to High Availability sync, you can use the xmlrpc plugin hook.

If a plugin exposes a configuration section to ha sync, it can be enabled separately in the synchronization settings System->High Availability->Settings.

A simple example to expose the configuration section Myplugin within the OPNsense xml path looks like this:

function myplugin_xmlrpc_sync()
{
    $result = array();
    $result[] = array(
        'description' => gettext('My Plugin'),
        'section' => 'OPNsense.Myplugin',
        'id' => 'myplugin',
        'services' => 'myplugin', // optional, in case a service with the same name exists
    );
    return $result;
}

Note

If your plugin depends on other components in the system, make sure you enable synchronization for those as well.


Using Templates
General

For config file generation, we provide a backend service which can bind config.xml data to templates written in Jinja2 (http://jinja.pocoo.org/docs/dev/).

All available templates should be installed at the following location on the OPNsense system:

    /usr/local/opnsense/service/templates/

Naming convention

All templates should be put into a directory structure containing the vendor and package/application name, our sample application is placed inside the directory:

/usr/local/opnsense/service/templates/OPNsense/Sample

Template package content

Every template directory should contain at least 2 files:

    a content descriptor, containing the actual targets, named +TARGETS

    one or more template(s)

Targets

The +TARGETS file contains the source template name inside the template directory and the (dynamic) target filename divided by a colon (:) multiple lines may be inserted per file.

For example :

example_simple_page.txt:/tmp/template_sample/simple_page.txt

Will create a file /tmp/template_sample/simple_page.txt using the template example_simple_page.txt.

Note

Optionally you can specify which file or files to remove on call of “template cleanup”, which can be specified by using an extra tag next to the target, such as: example_simple_page.txt:/tmp/template_sample/simple_page.txt:/tmp/template_sample/simple_page.*

By default all targets will be removed when calling cleanup.

If you want to use information from within the config.xml file as output filename, you can use tags to address the content, like [version] to input the tag version from the xml file. When generating multiple files from 1 template, you can use one wildcard (%) to address a section of the config file, for example [interfaces.%.if] loops over the interfaces and outputs the value of if.
Target overwrites

Every template package can specify overwrites, which can be used by vendors who implement and maintain their own templates for features in OPNsense.

Simply add files using the target definition in the +TARGETS.D directory of the templates folder using as extension .TARGET.

For example an overwrite for OPNsense/Sample can use the following name and location /usr/local/opnsense/service/templates/OPNsense/Sample/+TARGETS.D/custom.TARGET

Note

Be vey careful using this feature, you need to maintain these templates yourself and features may break after upgrades of OPNsense.
Templates

For more information of the template language itself, please look at http://jinja.pocoo.org/docs/dev/ and the examples installed in /usr/local/opnsense/service/templates/OPNsense/Sample.

There’s one special case when using the template engine, every wildcard used for the output file generation is also provided to the template, so you are able to determine which filter let to this output.

Those filters are stored in the variable TARGET_FILTERS.

{% if TARGET_FILTERS['interfaces.wan'] %}
{% endif %}

Test usage

The templates can be rendered via the backend service (configd), to test this functionality on a running OPNsense system, use:

# generate template package
configctl template reload OPNsense/Sample
# cleanup files
configctl template cleanup OPNsense/Sample


Python template usage example

The template system itself is a separate module which is used by configd, to use (or test) the system without the daemon, use:

# import template system and config.xml handling
from modules import template
from modules import config

# construct a new template object, set root to /tmp/
tmpl = template.Template(target_root_directory='/tmp/')
# open the config.xml and bind to template object
conf = config.Config('/config.xml')
tmpl.set_config(conf.get())

# generate output for OPNsense/Sample
generated_filenames = tmpl.generate('OPNsense/Sample')

# print results
for filename in generated_filenames:
  print ('.. generated : %s'%filename)


Frontend

The OPNsense frontend is implemented with PHP/Phalcon.

    Creating Models
        Designing the model
        Special model types
        Usage example
        Guidelines
        Custom (app specific) field types
        Adding constraints
        Migrations
    Creating Models / Field types
    Routing
    Using controllers and views
    View construction (and tools)
    Dashboard widgets


Creating Models

A model represents the data which the application will use and takes care of the interaction to that data. In OPNsense most of the relevant data is physically stored in an XML structure (config.xml). The primary goal for OPNsense models is to structure the use of configuration data, by creating a clear abstraction layer.

In this chapter we will explain how models are designed and build.

    Designing the model
    Special model types
    Usage example
    Guidelines
    Custom (app specific) field types
    Adding constraints
    Migrations


Designing the model

Index

    Designing the model

        volatile fields

    Special model types

        In memory models

        Legacy wrappers

Creating models for OPNsense is divided into two separate blocks:

    A PHP class describing the actions on our data (also acts as a wrapper to our data),

    The definition of the data and the rules it should apply to.

Every model’s class should be derived from OPNsense\Base\BaseModel, a very simple model without any (additional) logic is defined with:

<?php
namespace myVendorName\myModule;

use OPNsense\Base\BaseModel;

class myModel extends BaseModel
{
}

This class should be placed inside the model directory of our project, in this case the full path for our class file would be

    /usr/local/opnsense/mvc/app/models/myVendorName/myModule/myModel.php

When you design a model, the next thing to do is to figure out what data is relevant for your application or module and think of the rules it should comply to (for example, if you need an email address you might want to validate the input). Designing the actual model is as simple as creating an xml file and putting in your structure, the name of our XML file should be the same as the base name of our model suffixed by .xml.

Using the same model, we would create the following file:

    /usr/local/opnsense/mvc/app/models/myVendorName/myModule/myModel.xml

And start describing our (information) model, like this:

<model>
    <mount>//myManufacturer/myModule</mount>
    <description>A description of this model (metadata)</description>
    <version>1.0.0</version>
    <items>
        <exampleNumber type="TextField">
            <Mask>/^([0-9]){0,1}$/</Mask>
            <Default>5</Default>
            <ValidationMessage>you should input a number from 0 to 9</ValidationMessage>
        </exampleNumber>
        <contacts>
            <entity type="ArrayField">
                <email type="EmailField">
                    <ValidationMessage>you should input a valid email address!</ValidationMessage>
                </email>
                <name type="TextField"/>
            </entity>
            <someText type="TextField"/>
        </contacts>
    </items>
</model>

Now let’s explain what’s happing here one tag at a time.

    the <model> tag is used for identification of the file. (this is a model file)

    Next in line is the <mount> tag, this tells the system where this information lives in the configuration file, in this case ROOT_tag/myManufacturer/myModule

    If desired, there is some space reserved to explain the usage of the model, the <description> tag

    A version tag is added, which is used to support migrations. These are described in more details in the migration topic

    Last item on the top of our list is the <items> tag, this is where the magic begins.

The content of a items tag describes the full tree based structure which holds our data, in theory this could be as large as you want it to be, but keep in mind that the content for your model should be logical and understandable. Every node in the tree could have a type, which defines its behavior, nodes without a type are just containers.

From top to bottom we find the following nodes in our tree:

    exampleNumber, defined as a TextField

        Mask, validation can be performed by a regex expression, this sets the expression

        Default, this field is default filled with a number: 5

        ValidationMessage, when validation fails, this message is returned

    contacts, this is a container

    entity, is defined as a recurring item, which holds the next items

    email, defined as an EmailField

        when validation fails, the ValidationMessage is returned

    name, defined as a TextField without any validations

    someText, not part of the entity tag and also defined as text without validation

The fieldtypes are easily extendable in the base system and all common ones live in their own namespace at OPNsense\Base\FieldTypes deriving from BaseField.

Note

When designing application specific fieldtypes, you can point to a field type within the application namespace using a full or partial path.

For example using Vendor\Component\FieldTypes\MyFieldType to point to a specific non common field type or .\MyFieldType when linked from the application model itself (which assumes a namespace FieldTypes exists)
volatile fields

In some cases it can be practical to define fields which act as standard fields, but will not be persisted in the configuration. Examples of this are fields used to generate other type of content, such as a certificate or fields that reflect data stored elsewhere.

To make a field volatile, just add the tag volatile="true" in the xml clause, for example:

<serial type="IntegerField" volatile="true"/>

Special model types
In memory models

In same cases it might be practical to use all of the standard model tools, but prevent data from being persisted. For this purpose the memory model may be used. Examples of such applications are diagnostic tools, which do require user input, but is only relevant for that perticular call.

To use these models, use the following mountpoint: <mount>:memory:</mount>
Legacy wrappers

While migrating legacy components, sometimes the distance between the current situation (using raw xml access) and the desired one (being a fully validated model) is hard to overcome. It’s not always clear which type of data is being used, and when moving data inside a new model and changing it’s access path, a proper validation is mandatory.

When data lives inside it’s own easy to distinct “container”, a standard model may be overlayed. An example of such a case is the static route component. Which underneath looks like this (without payload):

<staticroutes>
   <route/>
   <route/>
</staticroutes>

The other case is when a collection of items does not live inside a unique container, for example the following payload:

<cert/>
<cert/>
<cert/>

Legacy modules would iterate over $config['cert'] in this case. Since cert does not have an upper container the model is able to control in full (as it’s the root of the config.xml), we can not overlay a standard model to specify the fields used and their constraints.

This is where our legacy wrapper comes into play. In order to use this feature, you have to use the following mountpoint format:

    /tag+ << start with an exact path [/] and end with a plus [+]

In the “cert” example our mountpoint would like like : <mount>/cert+</mount>

Note

All used fields still need to be specified, fields left out of the model, will be removed from the configuration in the same way a regular model would act.

Note

As legacy wrappers can not be versioned, migrations do not apply. In the long run it’s always better to use full models, but these constructions offer an option for a “softer landing”.


Usage example

Now let’s test our model using a small PHP script (in /usr/local/opnsense/mvc/script/ ):

<?php
// initialize phalcon components for our script
require_once("load_phalcon.php");

// include myModel and the shared config component
use myVendorName\myModule\myModel;
use OPNsense\Core\Config;

// create a new model, reading the model definition and the current data from our config.xml
$myMdl = new myModel();
$myMdl->exampleNumber =1;
$myMdl->contacts->someText = "just a test";

// add a new contact node
$node = $myMdl->contacts->entity->add();
$node->email = "test@test.com";
$node->name = "my test user";

// perform validation on the data in our model
$validationMessages = $myMdl->performValidation();
foreach ($validationMessages as  $messsage) {
    echo "validation failure on field ". $messsage->getField()."  returning message : ". $messsage->getMessage()."\n";
}

// if validation succeeded, write data back to config
if ($validationMessages->count() == 0) {
    // serialize our model to the config file (config.xml)
    // (this raises an error on validation failures)
    $myMdl->serializeToConfig();
    $cnf = Config::getInstance();
    $cnf->save();
}

If you fill in an invalid value to one of the validated fields, you can easily try the validation. Try to input the text “X” into the field exampleNumber to try out.

When inspecting our config.xml file, you will notice the following content has been added to the root:

<myManufacturer>
  <myModule>
    <exampleNumber>1</exampleNumber>
    <contacts>
      <entity>
        <email>test@test.com</email>
        <name>my test user</name>
      </entity>
      <someText>just a test</someText>
    </contacts>
  </myModule>
</myManufacturer>


Guidelines

Some (simple) guidelines developing models

    One model should always be completely responsible for the its mount point, so if there’s a model at mount point /A/B there can’t be a model at /A/B/C

    Try to keep models logical and understandable, it’s better to build two models for you application if the content of two parts aren’t related to each other. It’s no issue to create models at deeper levels of the structure.

        When using more models in a application/module, you might want to consider the following naming convention: /Vendor/Module/Model

    Try to avoid more disc i/o actions than necessary, only call save() if you actually want to save content, serializeToConfig just keeps the data in memory.


Custom (app specific) field types

Applications can add their own custom field types, which should be derived from BaseField or one of its descendants. A very simple single item custom field type could look like this:
Build the field type

<?php
namespace myVendorName\myModule;
use OPNsense\Base\FieldTypes\BaseField;
use Phalcon\Validation\Validator\Regex;

class SimpleCustomField extends BaseField
{
    protected $internalIsContainer = false;
    protected $internalValidationMessage = "standard error";
    public function getValidators()
    {
        $validators = parent::getValidators();
        $reservedwords = array('all', 'pass', 'block', 'out');
        $validators[] = new ExclusionIn(array(
            'message' => 'can not use a reserved word',
            'domain' => $reservedwords));
    }
    return $validators;
}

This example extends the standard validations with a list of reserved words, in which case it would yield can not use a reserved word if one of the reserved words are provided.

Note

This file should be placed in the subdirectory FieldTypes of the model itself.

Tip

Use BaseListField as simple template for list type items.
Use in model

The validation can be used as any standard type, when prefixed with . the model knows it concerns a local field.

<model>
    <mount>//OPNsense/MyFirst/App</mount>
    <version>1.0.0</version>
    <description>
        My first application
    </description>
    <items>
        <general>
            <name type=".\SimpleCustomField">
                <Required>Y</Required>
            </name>
        </general>
    </items>
</model>

Tip

Inspect the basic field types for inspiration, a concrete example of a custom field type can be found in the firewall section

Adding constraints

Constraints can be used on top of type validations provided by the base fields described in the previous chapter. The base class BaseConstraint is used as base type and contains shared functionality.

Since fields are usually only validated when there’s change detected, it’s usually necessary to add back references to chain validations.
DependConstraint

When choices depend on each other, you can use the DependConstraint type. The following example makes sslurlonly depend on the sslbump option, since the <reference> tag is needed to make sure when one of the settings changes, the other is validated again too.

<sslbump type="BooleanField">
    <Constraints>
        <check001>
            <type>DependConstraint</type>
            <addFields>
                <field1>sslurlonly</field1>
            </addFields>
        </check001>
    </Constraints>
</sslbump>
<sslurlonly type="BooleanField">
    <Constraints>
        <check001>
            <reference>sslbump.check001</reference>
        </check001>
    </Constraints>
</sslurlonly>

AllOrNoneConstraint

Make sure that options are only valid when selected in combination.
SingleSelectConstraint

When options are not valid in combination, you can hook options together so only one of the options can be selected at the same time.
UniqueConstraint

This constraint helps to make sure all items within an ArrayField are unique, such as the following example which makes sure all “filenames” in this set are unique.

<filename type="TextField">
    <Constraints>
        <check001>
            <type>UniqueConstraint</type>
        </check001>
    </Constraints>
</filename>

ComparedToFieldConstraint

The ComparedToFieldConstraint compares the value of the current field to the value of a referenced field on the same level (for example in the same ArrayField). It is for example used for the rspamd plugin, to ensure that some values are in the correct order. This constraint can be used to compare numeric values.

Example:

<check003>
  <ValidationMessage>This field must be bigger than the greylist score.</ValidationMessage>
  <type>ComparedToFieldConstraint</type>
  <field>greylistscore</field>
  <operator>gt</operator>
</check003>

In this example, the valueof the current field must be greater than the value of the field “greylistscore”.

Field values:

ValidationMessage
	

Validation message (translateable) which will be shown in case the validation fails.

type
	

ComparedToFieldConstraint

field
	

the other field which we reference

operator
	

The operator to check the value. Valid operators are gt, gte, lt, lte, eq, neq

Operators:

gt
	

greater than

gte
	

greater than or equal

lt
	

lesser than

lte
	

lesser than or equal

eq
	

equal

neq
	

not equal
SetIfConstraint

The SetIfConstraint is used to make some fields conditionally mandatory. It is mainly used in the nginx plugin for example to choose an implementation type. In general the other field should be an OptionField, but does not need to. In general it is a good idea to hide or show fields which are (not) required by an implementation in the frontend as well to simplify the web interface. Please note: the checked field is intended to be on the same level (for example ArrayField).

Example:

<check001>
  <ValidationMessage>This field must be set.</ValidationMessage>
  <type>SetIfConstraint</type>
  <field>match_type</field>
  <check>id</check>
</check001>

In this example, the value will be mandatory, if the field “match_type” has the value “id”.

Field Values:

ValidationMessage
	

Validation message (translateable) which will be shown in case the validation fails.

type
	

SetIfConstraint

field
	

the other field which we reference

check
	

The value of the other field which makes this field required


Migrations

When using the <version/> tag in the model xml you automatically allow upgrades of your configuration data. If the tag is missing, it will automatically assume your at version 0.0.0 (initial version).

The migration feature provides a pluggable framework to offer new and changed attributes after installation of new software and is therefor automatically triggered when performing upgrades or installing packages.

Tip

You can always trigger migrations manually by executing /usr/local/opnsense/mvc/script/run_migrations.php from a console. This will output all installed modules and the upgrades performed.

If no overrides are provided and the module version of the running configuration doesn’t equal the one installed, there automatically will be a migration created using the BaseModelMigration base class. This will take care of basic changes, such as adding new fields and applying defaults.

Note

The current version will always be saved as an attirbute on the model xml (e.g. <Alias version="1.0.0">)
Custom migrations

In some cases one wants to perform custom actions when upgrading between version, such as gathering data from legacy configuration settings.

The directory Migrations in the model directory is used to hold the migration code on a per version basis. By default classes (and files) in there use the following naming scheme: M1_0_0 which stands for [M]igration version [1.0.0].

Note

If different models share a namespace, you can change the prefix of the migration files, when nothing is provided the default is M, the tag <migration_prefix/> can be used to change this to something else. (e.g. <migration_prefix>MFP</migration_prefix>)

The boilerplate for a model migration looks like this (for a migration to 1.0.0):

class M1_0_0 extends BaseModelMigration
{
    /**
     * default model migration
     * @param $model
     */
    public function run($model)
    {
        parent::run($model);
    }

    /**
     * post migration action, run after config sync
     * @param $model
     */
    public function post($model)
    {
        return;
    }
}

It contains two methods, run() and post(). The first one is executed in memory, before serializing data back to the running configuration and for all version steps in sequence. (an upgrade from 1.0.0 to 1.0.2 might execute 1.0.1, 1.0.2, 1.0.3). The configuration data itself will be synced ones in this case.

Note

Except in special cases, a run() method should always contain a parent method call parent::run($model); to perform the basic migration function.

The post action is called after normal model configuration and can sometimes be practical to alter the raw model xml, for example if model versions require a move of datasets, without actually changing content.

Note

Although there are toggles in place, data migration can easily lead to race conditions. Always try to design your software for change, adding fields which pass validation by default for example is always preferred above situations which will fail by default.

Creating Models / Field types

OPNsense comes with a collection of standard field types, which can be used to perform standard field type validations. These field types can be found in /usr/local/opnsense/mvc/app/models/OPNsense/Base/FieldTypes/ and usually decent from the BaseField type.

This paragraph aims to provide an overview of the types included by default and their use.

Tip

When using lists, the Multiple (Y/N) keyword defines if there may be more than one item selected at a time.

Tip

The xml keyword Required can be used to mark a field as being required.
ArrayField

The basic field type to describe a container of objects, such as a list of addresses.

Note

This type can’t be nested, only one level of ArrayField types is supported, you can use ModelRelationField to describe master-detail constructions.

Tip

In case a model needs static (non persistent) records, the getStaticChildren() method may be implemented to spawn static entries. See also the custom field chapter for implementation scenarios.
AuthGroupField

Returns and validates system (user) groups (found in System ‣ Access ‣ Groups)
AuthGroupField

Parameter
	

Options
	

Purpose

default
	

text
	

Default value for new attributes

Required
	

Y,N
	

Mark field as required

ValidationMessage
	

text
	

Error message on validation failure

BlankDesc
	

text
	

Set a label for the empty option

Multiple
	

Y,N
	

Allow to select multiple options
AuthenticationServerField

Select and validate authentication providers, maintained in System ‣ Access ‣ Servers.
AuthenticationServerField

Parameter
	

Options
	

Purpose

default
	

text
	

Default value for new attributes

Required
	

Y,N
	

Mark field as required

ValidationMessage
	

text
	

Error message on validation failure

BlankDesc
	

text
	

Set a label for the empty option

Multiple
	

Y,N
	

Allow to select multiple options

Filters
	

Y,N
	

A structure of regex filters per atribute to exclude certain options from the list
AutoNumberField

An integer sequence, which automatically increments on every new item of the same type in the same level.
AutoNumberField

Parameter
	

Options
	

Purpose

default
	

text
	

Default value for new attributes

Required
	

Y,N
	

Mark field as required

ValidationMessage
	

text
	

Error message on validation failure

MinimumValue
	

int
	

Minimum number also starting point of the sequence

MaximumValue
	

int
	

Maximum number
Base64Field

Validate if a given string contains a valid base64 decodable value.
Base64Field

Parameter
	

Options
	

Purpose

default
	

text
	

Default value for new attributes

Required
	

Y,N
	

Mark field as required

ValidationMessage
	

text
	

Error message on validation failure

Mask
	

regex
	

Optional validation regex
BooleanField

Boolean field, where 0 means false and 1 is defined as true
BooleanField

Parameter
	

Options
	

Purpose

default
	

text
	

Default value for new attributes

Required
	

Y,N
	

Mark field as required

ValidationMessage
	

text
	

Error message on validation failure
CertificateField

Option list with system certificates defined in System ‣ Trust.
CertificateField

Parameter
	

Options
	

Purpose

default
	

text
	

Default value for new attributes

Required
	

Y,N
	

Mark field as required

ValidationMessage
	

text
	

Error message on validation failure

BlankDesc
	

text
	

Set a label for the empty option

Multiple
	

Y,N
	

Allow to select multiple options

Type
	

ca, crl, cert
	

Type of certificate to select, defaults to cert
CSVListField

List of (comma) separated values, which can be validated using a regex.
CSVListField

Parameter
	

Options
	

Purpose

default
	

text
	

Default value for new attributes

Required
	

Y,N
	

Mark field as required

ValidationMessage
	

text
	

Error message on validation failure

Mask
	

regex
	

Optional validation regex

MaskPerItem
	

Y,N
	

Apply regex validation to each item separately
ConfigdActionsField

Select available configd actions, supports filters to limit the number of choices. For example, the example below only shows actions which have a description.

<command type="ConfigdActionsField">
    <filters>
        <description>/(.){1,255}/</description>
    </filters>
</command>

ConfigdActionsField

Parameter
	

Options
	

Purpose

default
	

text
	

Default value for new attributes

Required
	

Y,N
	

Mark field as required

ValidationMessage
	

text
	

Error message on validation failure

BlankDesc
	

text
	

Set a label for the empty option

Multiple
	

Y,N
	

Allow to select multiple options

Filters
	

Y,N
	

A structure of regex filters per atribute to exclude certain options from the list
CountryField

Select and validate countries in the world.
CountryField

Parameter
	

Options
	

Purpose

default
	

text
	

Default value for new attributes

Required
	

Y,N
	

Mark field as required

ValidationMessage
	

text
	

Error message on validation failure

BlankDesc
	

text
	

Set a label for the empty option

Multiple
	

Y,N
	

Allow to select multiple options

AddInverted
	

Y,N
	

Add ‘inverted’/excluded countries to the list, copies contry codes prefixes an ! (e.g. !NL)
DescriptionField

Validate if the input contains a valid description, meaning it should be a string of 1 to 255 characters.
DescriptionField

Parameter
	

Options
	

Purpose

default
	

text
	

Default value for new attributes

Required
	

Y,N
	

Mark field as required

ValidationMessage
	

text
	

Error message on validation failure
EmailField

Validate if the input contains an email address.
EmailField

Parameter
	

Options
	

Purpose

default
	

text
	

Default value for new attributes

Required
	

Y,N
	

Mark field as required

ValidationMessage
	

text
	

Error message on validation failure
HostnameField

Check if hostnames are valid, includes the following options:
HostnameField

Parameter
	

Options
	

Purpose

default
	

text
	

Default value for new attributes

Required
	

Y,N
	

Mark field as required

ValidationMessage
	

text
	

Error message on validation failure

IpAllowed
	

Y,N
	

Allow an ip address

HostWildcardAllowed
	

Y,N
	

Allow * for all hostnames

FqdnWildcardAllowed
	

Y,N
	

Allow partial wildcard for fully qualified domain names (e.g. *.my.top.level.domain)

ZoneRootAllowed
	

Y,N
	

Allow the zone root marker (@)

IsDNSName
	

Y,N
	

Allow less strict names, used for various dns entries as specified by RFC2181

AsList
	

Y,N
	

Field type should return list items

FieldSeparator
	

text
	

Separator character to use
IntegerField

Validate if the input contains an integere value, optionally constrained by minimum and maximum values.
EmailField

Parameter
	

Options
	

Purpose

default
	

text
	

Default value for new attributes

Required
	

Y,N
	

Mark field as required

ValidationMessage
	

text
	

Error message on validation failure

MinimumValue
	

int
	

Minimum number

MaximumValue
	

int
	

Maximum number
InterfaceField

Option list with interfaces defined in Interfaces ‣ Assignments, supports filters. The example below shows a list of non-dhcp active interfaces, for which multiple items may be selected, but at least one should be. It defaults to lan
InterfaceField

Parameter
	

Options
	

Purpose

default
	

text
	

Default value for new attributes

Required
	

Y,N
	

Mark field as required

ValidationMessage
	

text
	

Error message on validation failure

BlankDesc
	

text
	

Set a label for the empty option

Multiple
	

Y,N
	

Allow to select multiple options

Filters
	

Y,N
	

A structure of regex filters per atribute to exclude certain options from the list

AddParentDevices
	

Y,N
	

Add parent devices in the list when not assigned

AllowDynamic
	

Y,N,S
	

Allow dynamic (hotplug) interfaces, when set to S hotplug interfaces without a static address are ignored

<interfaces type="InterfaceField">
    <Required>Y</Required>
    <multiple>Y</multiple>
    <default>lan</default>
    <filters>
        <enable>/^(?!0).*$/</enable>
        <ipaddr>/^((?!dhcp).)*$/</ipaddr>
    </filters>
</interfaces>

IPPortField

Validates an IP:port combination (e.g. 192.168.1.1:22). Can be used to validate a single item or a list of items and can optionally enforce either ipv4 or ipv6 addresses.
IPPortField

Parameter
	

Options
	

Purpose

default
	

text
	

Default value for new attributes

Required
	

Y,N
	

Mark field as required

ValidationMessage
	

text
	

Error message on validation failure

AsList
	

Y,N
	

Field type should return list items

FieldSeparator
	

text
	

Separator character to use

AddressFamily
	

ipv4, ipv6
	

Which address family to use, blank means ipv4+ipv6
JsonKeyValueStoreField

A construct to validate against a json dataset retreived via configd, such as

<program type="JsonKeyValueStoreField">
  <ConfigdPopulateAct>syslog list applications</ConfigdPopulateAct>
  <SourceFile>/tmp/syslog_applications.json</SourceFile>
  <ConfigdPopulateTTL>20</ConfigdPopulateTTL>
  <SortByValue>Y</SortByValue>
</program>

In which case syslog list applications is called to retrieved options, which is valid for 20 seconds (TTL) before fetching again.
JsonKeyValueStoreField

Parameter
	

Options
	

Purpose

default
	

text
	

Default value for new attributes

Required
	

Y,N
	

Mark field as required

ValidationMessage
	

text
	

Error message on validation failure

BlankDesc
	

text
	

Set a label for the empty option

Multiple
	

Y,N
	

Allow to select multiple options

ConfigdPopulateAct
	

text
	

Configd command responsible for the data

SourceFile
	

text
	

Temporary filename where results are stored

ConfigdPopulateTTL
	

int
	

Time To Live in seconds

SortByValue
	

Y,N
	

Sort by value, default sorts by key
LegacyLinkField

Read-only pointer to legacy config data, reads (single) property from the legacy configuration and returns its content when it exists (null if xml item doesn’t exist).

The following example would read the enabled property from the config xml, which resides in <ipsec><enabled>1</enabled></ipsec>

<enabled type="LegacyLinkField">
    <Source>ipsec.enable</Source>
</enabled>

Note

Values stored into this fieldtype will be discarded without further notice, which practically means the target structure will always contain an empty field as long as its used as a pointer. When functionality migrates to mvc, you can switch the type and supply migration code to load the initial values.
MacAddressField

Validate if the given value (or multiple values) is a valid MAC address.
MacAddressField

Parameter
	

Options
	

Purpose

default
	

text
	

Default value for new attributes

Required
	

Y,N
	

Mark field as required

ValidationMessage
	

text
	

Error message on validation failure

AsList
	

Y,N
	

Field type should return list items

FieldSeparator
	

text
	

Separator character to use
ModelRelationField

Define relations to other nodes in the model, such as to point the attribute pipe to a pipe node in the TrafficShaper model.

<pipe type="ModelRelationField">
    <Model>
        <pipes>
            <source>OPNsense.TrafficShaper.TrafficShaper</source>
            <items>pipes.pipe</items>
            <display>description</display>
        </pipes>
    </Model>
</pipe>

To display multiple fields, the display_format is required.

<pipe type="ModelRelationField">
    <Model>
        <pipes>
            <source>OPNsense.TrafficShaper.TrafficShaper</source>
            <items>pipes.pipe</items>
            <display>number,description</display>
            <display_format>%s - %s</display_format>
        </pipes>
    </Model>
</pipe>

ModelRelationField

Parameter
	

Options
	

Purpose

default
	

text
	

Default value for new attributes

display
	

text
	

Comma separated list of fields to display

display_format
	

text
	

vsprintf() format string

Required
	

Y,N
	

Mark field as required

ValidationMessage
	

text
	

Error message on validation failure

BlankDesc
	

text
	

Set a label for the empty option

Multiple
	

Y,N
	

Allow to select multiple options

Model
	

xml
	

structure as described in the sample above
NetworkAliasField

Validate if the value is a valid network address (IPv4, IPv6), special net or alias. Predefined special networks contain the following choices:

        any

                any network

        (self)

                This firewall

        [interface]

                Interface network, where interface is one of lan, wan, opt[XX] (e.g. opt1, opt2)

        [interface]ip

                Interface address

All network/host type aliases (including, but not limited to GeoIP) defined in Firewall -> Aliases are also valid choices.
NetworkAliasField

Parameter
	

Options
	

Purpose

default
	

text
	

Default value for new attributes

Required
	

Y,N
	

Mark field as required

ValidationMessage
	

text
	

Error message on validation failure

BlankDesc
	

text
	

Set a label for the empty option
NetworkField

Validate if the value is a valid network address (IPv4, IPv6).
NetworkField

Parameter
	

Options
	

Purpose

default
	

text
	

Default value for new attributes

Required
	

Y,N
	

Mark field as required

ValidationMessage
	

text
	

Error message on validation failure

Mask
	

regex
	

Optional validation regex

NetMaskRequired
	

Y,N
	

Is a netmask required

NetMaskAllowed
	

Y,N
	

Is a netmask allowed

AddressFamily
	

ipv4, ipv6
	

Which address family to use, blank means ipv4+ipv6

FieldSeparator
	

text
	

Separator character to use

WildcardEnabled
	

Y,N
	

Allow the use of the any clause

AsList
	

Y,N
	

Field type should return list items

Strict
	

Y,N
	

Disallow the usage of host bits when a netmask is used
NumericField

Validate input to be of numeric type.
NumericField

Parameter
	

Options
	

Purpose

default
	

text
	

Default value for new attributes

Required
	

Y,N
	

Mark field as required

ValidationMessage
	

text
	

Error message on validation failure

MinimumValue
	

int
	

Minimum number

MaximumValue
	

int
	

Maximum number
OptionField

Validate against a static list of options.
OptionField

Parameter
	

Options
	

Purpose

default
	

text
	

Default value for new attributes

Required
	

Y,N
	

Mark field as required

ValidationMessage
	

text
	

Error message on validation failure

BlankDesc
	

text
	

Set a label for the empty option

Multiple
	

Y,N
	

Allow to select multiple options

OptionValues
	

xml
	

Xml structure containing keys and values, when keys should be numeric, the value tag is also supported <opt1 value='1'>option1</opt1>

When the list of available options is relatively large, its also possible to nest the options one level, which generates <optgroup> clauses in our model. As of 24.1 they can be defined using the following structure:

<field type="OptionField">
    <OptionValues>
        <opt1 value='option group 1'>
           <opt1 value='option1'>option 1</opt1>
        </opt1>
        <option_group2>
           <opt2>option 2</option2>
        </option_group2>
    </OptionValues>
</field>

PortField

Check if the input contains a valid portnumber or (optionally) predefined service name. Can be a range when EnableRanges is set to Y.
PortField

Parameter
	

Options
	

Purpose

default
	

text
	

Default value for new attributes

Required
	

Y,N
	

Mark field as required

ValidationMessage
	

text
	

Error message on validation failure

BlankDesc
	

text
	

Set a label for the empty option

Multiple
	

Y,N
	

Allow to select multiple options, when set the type is treated as a list

EnableWellKnown
	

Y,N
	

Allow the usage of well known names such as ‘http’ and ‘ssh’

EnableRanges
	

Y,N
	

Allow the usa of ranges, such as 80:100
ProtocolField

List field type to validate if the provided value is a valid protocol name as defined by /etc/protocols (e.g. TCP, UDP) extended with the any option.
ProtocolField

Parameter
	

Options
	

Purpose

default
	

text
	

Default value for new attributes

Required
	

Y,N
	

Mark field as required

ValidationMessage
	

text
	

Error message on validation failure

BlankDesc
	

text
	

Set a label for the empty option

Multiple
	

Y,N
	

Allow to select multiple options
TextField

Validate regular text using a regex.
TextField

Parameter
	

Options
	

Purpose

default
	

text
	

Default value for new attributes

Required
	

Y,N
	

Mark field as required

ValidationMessage
	

text
	

Error message on validation failure

Mask
	

regex
	

Optional validation regex
UniqueIdField

Generate unique id numbers.
UniqueIdField

Parameter
	

Options
	

Purpose

default
	

text
	

Default value for new attributes

Required
	

Y,N
	

Mark field as required

ValidationMessage
	

text
	

Error message on validation failure
UpdateOnlyTextField

Write only text fields, can be used to store passwords
TextField

Parameter
	

Options
	

Purpose

default
	

text
	

Default value for new attributes

Required
	

Y,N
	

Mark field as required

ValidationMessage
	

text
	

Error message on validation failure

Mask
	

regex
	

Optional validation regex
UrlField

Validate if the input contains a valid URL.
UrlField

Parameter
	

Options
	

Purpose

default
	

text
	

Default value for new attributes

Required
	

Y,N
	

Mark field as required

ValidationMessage
	

text
	

Error message on validation failure
VirtualIPField

Select a virtual address defined in Interfaces -> Virtual IPs -> Settings, use with a bit of care as the keys (addresses) are subjected to change.
VirtualIPField

Parameter
	

Options
	

Purpose

default
	

text
	

Default value for new attributes

Required
	

Y,N
	

Mark field as required

ValidationMessage
	

text
	

Error message on validation failure

BlankDesc
	

text
	

Set a label for the empty option

Multiple
	

Y,N
	

Allow to select multiple options

Type
	

text
	

The virtual ip type to select, * for all (default)


Routing
General

To retain backward compatibility with legacy code, we try to keep the old pages at their original location. For the new code, we define two root folders in the url:

    /ui/ for the new user interface parts

    /api/ used for webservices (REST)

This part of the routing is handled by lighthttpd using mod_alias and mod_rewrite.
User interface Routing

If you look at the controller directory in OPNsense, you will notice there are different directory levels under the root controller directory in /usr/local/opnsense/mvc/app/controllers. To support different apps and vendors eventually, we already used a structure which is automatically used to setup the routing.

At the first level we use the vendor of the app, in our case that will always be OPNsense.

The next level is used to name the topic (or app), for example we use Sample for our example application.

Finally you may place your standard Phalcon classes for controllers in that directory, so if you want to create a page helloworld, that should come with a controller helloworldController.php (and a indexAction to define the index action for that page).

The complete path of the helloworld page would eventually be:

/usr/local/opnsense/mvc/app/controllers/OPNsense/Sample/helloworldController.php

When publishing the page, the vendor part of the controller is not used in the mapping, so in this example the helloworld index page will be at:

https://{url}/ui/sample/helloworld/

All the parts of the url are automatically converted to lower-case, so Sample will be mapped to sample.

This routing is setup via the index page of our new code base and uses /usr/local/opnsense/mvc/app/config/services.php to wire it all together.
API routing

Routing for API functions is quite similar to routing UI components, just create a Api directory under the app path and place a controller class to handle the request. The only major difference is that it’s handled by a separate PHP file (called api.php) instead of the index.php file used to configure the ui part, details of the routing can be found in /usr/local/opnsense/mvc/app/config/services_api.php .

If our sample app needs an API to echo something back via a controller called tools it could be put into a file called:

/usr/local/opnsense/mvc/app/controllers/OPNsense/Sample/Api/toolsController.api

And called via the following url:

https://{host}}/api/sample/tools/echo

When the controller has a method called echoAction.


Using controllers and views
General

After routing is performed, the controller takes care of the actual code to execute for the request. Because we want to implement some basics for every request that gets processed you should inherit from our base classes to ensure basic functionality such as authorisation and CSRF protection.

Controllers are placed in the directory /usr/local/opnsense/mvc/app/controllers/<Vendor_name>/<Module_name>/ and should use the standard Phalcon naming conventions, suffix Controller.php on every class file and suffix Action on all action methods.

For a detailed description of how Controllers work in Phalcon, please look at the Phalcon documentation at http://docs.phalconphp.com/en/latest/reference/controllers.html
View based controllers

For rendering standard pages we have chosen to use Volt templates, the base controller to inherit from in this case is OPNsense\Base\ControllerBase and should take care of binding a template to the controller. Every template automatically receives standard features (such as the menu system).

The wireframe for implementing a single action should look like this:

<?php
    public function indexAction()
    {
       // address some variables to pass through the view
        $this->view->my_variable1 = 'test 1';
        $this->view->my_variable2 = 'test 2';
       // pick a template
        $this->view->pick('SampleVendor/Sample/index');
    }

And the volt template SampleVendor/Sample/index.volt could contain something like:

the contents of my_variable1 => <b> {{ my_variable1 }} </b> <br>
the contents of my_variable2 => <b> {{ my_variable2 }} </b> <br>

A full example can be found in the OPNsense\Sample controller directory.

More information on how to write Volt pages can be found here : http://docs.phalconphp.com/en/latest/reference/volt.html
User forms

When designers need forms for users to input data, they can use the getForm() method on our standard controller to feed a simple xml file as definition for the template engine to use. The example section contains a step by step guide how to use these.

The getForm() method itself merily passes the structure to thew view, which can use this information to render forms on page load (statically). In our standard layout partials we offer some different record types which we will detail below:

Attributes

Name
	

Description

id
	

unique id of the attribute

type
	

type of input or field. For a list of valid types, use the Type table below

label
	

attribute label (visible text)

size
	

size (width in characters) attribute if applicable

height
	

height (length in characters) attribute if applicable

help
	

help text

advanced
	

property “is advanced”, only display in advanced mode

hint
	

input control hint

style
	

css class(es) to add, helps identifying items easier using jQuery selectors

width
	

width in pixels if applicable

allownew
	

allow new items (for list) if applicable

readonly
	

if true, input fields will be readonly

Types

Name
	

Description

header
	

Header row

text
	

Single line of text

password
	

Password field for sensitive input. The contents will not be displayed.

textbox
	

Multiline text box

checkbox
	

Checkbox

dropdown
	

Single item selection from dropdown

select_multiple
	

Multiple item select from dropdown

hidden
	

Hidden fields not for user interaction

info
	

Static text (help icon, no input or editing)
API based controllers

For API calls a separate class is used to derive from, which implements a simple interface to handle calls. The main difference with the view controllers is that an action should return a named array containing response data instead of picking a template.

A simple index controller to echo a request back looks like this:

class TestController extends ApiControllerBase
{
    /**
     * @return array
     */
    public function echoAction()
    {
        if ($this->request->hasPost("message")) {
            $message = $this->request->getPost("message");
        } else {
            $message = " " ;
        }

        return array("message" => $message);
    }
}

When placed inside the API directory of Vendor/Sample can be called by sending a post request to /api/sample/test/echo, using jQuery:

$.ajax({
    type: "POST",
    url: "/api/sample/test/echo",
    success: function(data){
        alert(data.message) ;
    },
    data:{message:"test message"}
});

Tip

OPNsense ships with two standard controllers to incorporate default action scenario’s, such as mutating models and restarting services. These can be found in our repository here and are named ApiMutableModelControllerBase, ApiMutableServiceControllerBase. Both extend ApiControllerBase as described in this chapter. The mutable model controller is explained in more detail in using grids, the service controller is explained in api enable services
Searchable recordsets

The tip in the previous chapter described how to use grids when using models, but in some cases there are datasets without being bound to a model. For example when traversing legacy data or gathering system statistics.

For this reason we added the method searchRecordsetBase() in ApiControllerBase. Using this method offers the ability to hook a recordset into the same search functionality as being available in model grids.

The following parameters are being offered:

Name
	

Description

$records
	

array as record set, e.g. [ [‘id’ => ‘1’], [‘id’ => ‘2’], … ]

$fields
	

Optional list of fields when not all data should be returned

$defaultSort
	

Optional default sort order (fielndname in recordset)

$filter_funct
	

Optional pluggable filter function, which is call with the record in question

$sort_flags
	

Default set to SORT_NATURAL | SORT_FLAG_CASE

Note

In order to filter sets on fields, make sure all records contain the requested field. Currently it’s not possible to omit fields when being sorted.

Implementing this into your own controller should be as simple as:

class TestController extends ApiControllerBase
{
    /**
     * @return array
     */
    public function searchAction()
    {
        $records = [];
        $records[] = ['id' => '1', 'description' => 'test 1'];
        $records[] = ['id' => '2', 'description' => 'test 2'];
        $records[] = ['id' => '3', 'description' => 'test 3'];
        return $this->searchRecordsetBase($records);
    }
}

Easy csv export/import helpers

In order to export or import csv structured data, some helpers are available to ease these operations. The ApiControllerBase adds a simple recordset export method (exportCsv()) and ApiMutableModelControllerBase contains a method to import data (importCsv()).

When data is being exported from a model using an ArrayField type, the :code`asRecordSet()` method can be used to extract the data easily.

The smallest functional example to download a file from a controller implemented with ApiMutableModelControllerBase would look like:

public function downloadAction()
{
    $this->exportCsv($this->getModel()->path->to->items->asRecordSet());
}

Feeding data back into the model:

public function uploadReservationsAction()
{
    if ($this->request->isPost() && $this->request->hasPost('payload')) {
        return $this->importCsv(
            'path.to.items',
            $this->request->getPost('payload'),
            ['my_key']
        );
    }
}



View construction (and tools)

Although most of our code base is being processed server side, some things just require interaction on the clients machine for a fluent user experience.

In this chapter we will try to explain some of the components we use when designing pages and how pages are usually constructed.
Layout

To ease reading of volt templates, we recommend using a fixed layout when creating templates. The base of our rendered page always contains the standard layout which is hooked via our standard frontend controller.

Below you will find the sections and their order, which we will describe briefly.

{#
  {1} Copyright notice
#}
<script>
$( document ).ready(function() {
  {2} UI code
});
</script>
{3} page html
{{ partial("layout_partials/base_dialog",...)}}  {4} dialog forms (see getForm())

    The copyright block, 2 clause BSD with the authors on top

    Javascript code which belongs to this page

    HTML code, usually starts with some <div> containers and uses standard Bootstrap 3 layouting

    When forms are used, these are placed last, these will be generated to the client as standard html code

ajaxCall

ajaxCall(url, sendData, callback) is a wrapper around jQuery’s $.ajax call preset to a POST type request and wrapping the sendData into a json object. The callback function will be called with the data and status received from the endpoint.
example usage

ajaxCall('/api/monit/status/get/xml', {}, function(data, status) {
    console.log(data)
});

ajaxGet

ajaxGet(url,sendData,callback) is also a wrapper around jQuery’s $.ajax call, but for a GET type request.
example usage

ajaxGet('/api/diagnostics/interface/getInterfaceNames', {}, function(data, status) {
    console.log(data);
});

mapDataToFormUI

The mapDataToFormUI(data_get_map, server_params) can be used to map data retrieved from a controller to a form in the browser.

This function accepts two parameters, data_get_map contains a mapping between form id’s and server endpoints, server_params is optional and can be used to set option in the GET type request.

When the endpoint is successfully called it should return a json type structure containing the path to the item, as an example using data_get_map = {'myform': '/api/path/to/formdata'};:

{
  "netflow": {
    "capture": {
      "interfaces": {
        "lan": {
          "value": "LAN",
          "selected": 1
        },
        "wan": {
          "value": "WAN",
          "selected": 0
        }
      },
    },
    "collect": {
      "enable": "1"
    }
  }
}

Which maps to the fields in this simplified structure (usually rendered via our volt templates):

<form id="myform">
    <select multiple="multiple" id="netflow.capture.interfaces">
    </select>
    <input type="checkbox" id="netflow.collect.enable">
</form>

The function returns a $.Deferred() which will be resolved when all endpoints are called.
saveFormToEndpoint

saveFormToEndpoint(url, formid, callback_ok, disable_dialog, callback_fail) is the opposite of mapDataToFormUI() and retrieves the data from the form and sends it to the configured (url) endpoint as json structure. Underneath this function uses getFormData(parent) defined in opnsense.js which is responsible for extracting values from different form types such as <input> and <select> types. When the attributes should be type safe (e.g. an integer in json format should be presented as 1 and not as "1"), there is the possibility to “cleanse” the data first using a filter. In this case define an attribute on the input tag with the name type_formatter containing the function to call.

<input type="text" type_formatter="my_convert_to_int_function" id="myform.myintval">

Which could be implemented in the form javascript as:

function my_convert_to_int_function(payload)
{
    if (/^[+-]?[0-9]*$/.test(payload)) {
        return  parseInt(payload);
    } else {
        return payload;
    }
}

The response data looks similar to the example data in mapDataToFormUI, but more condensed since selections will be returned as single (separated) values, such as lan,wan if both options where set.

Using the example with the function above, a valid integer would offer a json object similar to {"myform": {"myintval": 1}}, unparsable data would look like {"myform": {"myintval": "1x"}}, in which case backend validations are able to feedback validation results.
updateServiceControlUI

The code:updateServiceControlUI(serviceName) function hooks the service control on top of the standard template, where you can find the [re]start, stop and status of the service.

It assumes the following endpoints exists for the module:

    /api/{{serviceName}}/service/status

            returns the status of the service (running, stopped) in a field named “status”

    /api/{{serviceName}}/service/start

            start the service

    /api/{{serviceName}}/service/restart

            restart the service

    /api/{{serviceName}}/service/stop

            stop the service

Dialog wrappers

We are using BootstrapDialog to display standard dialogs, to limit the boilerplates needed to show these dialog we added the following wrapper funcitons:
stdDialogInform(title, message, close, callback, type, cssClass)

Informational dialog with a single close button, using the following parameters:

    title: string dialog title

    message: string dialog message

    close: string close button text

    callback: function() to be called after close

    type: string dialog type. one of : danger, default, info, primary, success, warning

    cssClass: string css class to use

stdDialogConfirm(title, message, accept, decline, callback, type)

Ok/Cancel dialog type using the following parameters:

    title: string dialog title

    message: string dialog message

    accept: string accept button text

    decline: string decline button text

    callback: function() to be called after close

    type: string dialog type. one of : danger, default, info, primary, success, warning

stdDialogRemoveItem(message, callback)

Simple remove item (warning) dialog, using a message and optionally a callback.
$.SimpleActionButton

Using the jQuery extension SimpleActionButton one can register simple ajax calls on components click events, which will call the selected endpoint and show a progress animation (spinner) to the user.

The following parameters can be supplied as data attributes on the target object:

    endpoint : endpoint to call (e.g. /api/my/action)

    label : button label text

    service-widget : the service widget to refresh after execution, see updateServiceControlUI()

    error-title : error dialog title

The method itself can be feed with callbacks to call before (onPreAction()) and after (onAction()) execution.

An example of a button could look like this:

<button class="btn btn-primary" id="reconfigureAct"
        data-endpoint='/api/component/service/reconfigure'
        data-label="{{ lang._('Apply') }}"
        data-service-widget="component"
        data-error-title="{{ lang._('Error reconfiguring component') }}"
        type="button"
></button>

To utilize the callbacks, one could use:

$('#btnTest').SimpleActionButton({
    onPreAction: function() {
        const dfObj = new $.Deferred();
        console.log("called before endpoint execution, returning a promise.");
        return dfObj;
    },
    onAction: function(data, status){
        console.log("action has been executed.");
    }
});

$.UIBootgrid

The UIBootgrid jQuery extension is a wrappper around a slightly modified jquery-bootgrid component, the pattern we implement with our wrapper is inspired by this example.

Defining the html table is best explained in the jquery-bootgrid examples, our wrapper eases the implementation of the javascript code.

The minimal implementation contains a reference to the search endpoint which should return a json resultset containing rows and pagination data (current, rowCount, total).

$("#my_grid").UIBootgrid(
    {   search:'/api/path/to/search',
        get:'/api/path/to/get',
        set:'/api/path/to/set',
        add:'/api/path/to/add',
        del:'/api/path/to/del',
        toggle:'/api/path/to/toggle',
        info:'/api/path/to/info'
    }
);

The other optional endpoints are either used to populate a form, as defined in the data-editDialog property on the table or can be used to feed actions, such as set (set new values, return validation errors), add a new record, del an existing record or toggle if the record should be enabled or disabled. info endpoints are not used very often (and can safely be omitted), these are mainly intended as simple trigger to display an info dialog.

A full example of a basic grid is available in our Using grids module & plugin example

In some cases the developer wants to signal the user about the fact that changes need to be applied in order to be active, for this scenario one can use the data-editAlert property of the table, which offers the ability to show an alert after changes. Below example would be shown when the table tag contains data-editAlert="exampleChangeMessage"

<div id="exampleChangeMessage" class="alert alert-info" style="display: none" role="alert">
    {{ lang._('After changing settings, please remember to apply them with the button below') }}
</div>

Tip

You can access the general settings of the jquery-bootgrid plugin using the options property, which can be convenient when you would like to change requests or responses as being exchanged with the server. The available options are described here
$.SimpleFileUploadDlg

The simple file upload dialog can be used to select a file and upload it to a specified endpoint.

To define a button sending data to /api/path/to/import_controller, the following code could be used:

<button
    id="upload"
    type="button"
    data-title="Import"
    data-endpoint='/api/path/to/import_controller'
    class="btn btn-xs"
><span class="fa fa-fw fa-table"></span></button>

Note

The structure of this POST contains a payload and a filename property.

Initializing this button could be done using:

$("#upload").SimpleFileUploadDlg();

Tip

The SimpleFileUploadDlg action supports an onAction handler similar to the one described in $.SimpleActionButton
OPNsense settings

We added a couple of settings to the list, which help to extend our plugin a bit more easily. Below we will explain which settings (within the options tag) are added by us:

    useRequestHandlerOnGet

        Boolean value which enables the use of the request handler when a get request is executed ot fetch data for the dialog. This can be used to add parameters to the request.

    onBeforeRenderDialog

        function handler which will be called before an edit dialog is being displayed, can be used to change the otherwise static dialogs. Should return a $.Deferred() object. (e.g. return (new $.Deferred()).resolve();)

Formatters

Formatters can be used in the grid heading to choose the presentation of an attribute, we include a couple of standard formatters which are:

    commands (commands list, edit,copy and delete)

    commandsWithInfo (same as commands, but with an info button as well)

    rowtoggle (show enabled status and act as toggle button)

    boolean (show boolean value)

Visible columns

jquery-bootgrid offers the ability to add columns which are not visible by default using the data-visible tag. When using our wrapper, these can be used to set defaults as well, but the users last selection is also recorded in its local browser storage as well as the number of results shown in the grid when opening the same page again.


Dashboard widgets
General

OPNsense provides an easy framework for developing dashboard widgets within a simple abstraction layer. Each widget is a separate Javascript module that extends from a base widget class. Each widget exposes a set of functions that are called by the dashboard framework logic. Each widget class also exposes the API endpoints it uses to fetch data, so that the dashboard controller can apply per-widget ACL checks.

The framework provides the following features:

    A responsive and dynamic grid that allows the user to build up a custom layout.

    The layout can be saved per logged in user.

    Administrators that restrict access to specific pages for specific users will automatically restrict access to the widgets that also use the same data feed.

    Widgets are fully asynchronous, meaning they are fully independent from one another, making sure that resource intensive widgets will not hold up other widgets.

This framework uses GridStack to create the dashboard grid.

Widgets are placed in the src/opnsense/www/js/widgets/ directory.
Example

Before going into any details, it is often most useful to present an example that includes most of the core logic: the interfaces overview widget.
ACL

Every widget must expose the endpoints it’s using to the framework, so the controller can determine whether this widget is accessible for the current logged in user. To do this, any <widget>.js file must start with the following line(s):

// endpoint:/api/endpoint/used/by/widget

For example:

// endpoint:/api/interfaces/overview/*

Multiple lines can be used if the widget uses multiple endpoints. If any of these endpoints are inaccessible, the widget will not be loaded. Note that the same rules as for any other ACL applies here.
Functions

The BaseWidget shows the skeleton of the widget Javascript module. Widgets extend this class to provide defaults to the framework. To make life a little easier for common patterns, other base widgets may also be exposed. Currently these are:

    BaseTableWidget: Exposes a dynamic table that can be configured in multiple orientations and only needs a data feed.

    BaseGaugeWidget: Exposes a Gauge widget that allows presenting simple current/total values with multiple hooks to customize the widget.

The following functions are available to be overridden by the widget when extended from the BaseWidget:
Constructor

constructor(config) {}

To provide sensible defaults to the framework, a derived javascript class should always call super() first in the constructor. Afterwards, the defaults can be overridden. The properties are:

    this.title. Sets the title of the widget in the header.

    this.tickTimeout. Sets the interval (in ms) in which the onWidgetTick() function is called. The default is 5000

If the widget has been persisted (the user pressed ‘save’), the loaded widget configuration is passed in the constructor. Any custom data necessary for the widget to properly reload itself can be found in the this.config property, if any.
getGridOptions

getGridOptions() {}

To provide flexibility, the widget can optionally override this function and return an object that will be merged and loaded into the GridStack API. This function is called before the widget is rendered to the DOM. For example, the following code:

getGridOptions() {
    return {
        // trigger overflow-y:scroll after 650px height
        sizeToContent: 650
    }
}

will insert the sizeToContent: 650 key-value pair into the GridStack options, making sure that the height of the widget does not exceed a maximum of 650 pixels before a scrollbar is inserted. The GridStack API reference can be found here.

This object is also persisted once the dashboard has been saved, meaning these properties are also passed in the constructor on a widget reload.

The properties do not have to correspond to the GridStack API, any custom data can be pushed here.
getMarkup

getMarkup() {}

This function must return a jQuery object that contains the static markup that’s necessary to build the layout of the widget. This function will usually just return the container (with styling attached) where dynamic content will be loaded using onMarkupRendered()
onMarkupRendered

async onMarkupRendered() {}

As soon as the dashboard has loaded, and all widget markup has been rendered to the DOM, dynamic content can be provided to fill the widget by defining this function. Since this is an async function, any API call within this function must be awaited. For example:

async onMarkupRendered() {
    await ajaxGet('/api/interfaces/overview/interfacesInfo', {}, (data, status) => {
        // do something with the data
    });
}

This will make sure that all other widgets remain responsive, and a spinner appears while the data is being loaded. Use jQuery to update the markup as prepared by getMarkup().
onWidgetResize

onWidgetResize(elem, width, height) {}

If a widget is resized by the user, or is resized due to layout constraints / browser resize, this function will be called with the updated width and height. The widget element is passed into the function as well.

Use this function to keep the widget responsive and the layout coherent for different sizes. For example:

onWidgetResize(elem, width, height) {
    if (width > 500) {
        $('.interface-info-detail').parent().show();
        $('.interface-info').css('justify-content', 'initial');
        $('.interface-info').css('text-align', 'left');
    } else {
        $('.interface-info-detail').parent().hide();
        $('.interface-info').css('justify-content', 'center');
        $('.interface-info').css('text-align', 'center');
    }
}

The above code will make sure that if the width of the widget is less than 500px wide, less critical information is removed. Adjust the styling as necessary.

Warning

While this function is debounced (throttled to prevent excessive calls), it is still executed often during a resize. If this function is doing a lot of heavy lifting, make sure you implement a notion of state to prevent the same logic from executing more than necessary. An example of this can be found in the BaseTableWidget.

If you return true from this function, the grid will be forcefully updated to adjust to a new layout.
onWidgetTick

onWidgetTick() {}

This function is called every this.tickTimeout milliseconds. While the dashboard is open, this function is used to update the data presented on the dashboard.
onWidgetClose

onWidgetClose() {}

Executed when a widget is removed from the grid. Make sure to clean up any resources in use by this widget. It is not always necessary to override this function, but it’s possible you’re using a third party library that requires action to be taken when the widget is removed. An example is the cleanup of a rendered chart.

Attention

If you’re using the BaseWidget EventSource mechanism, make sure to call super.onWidgetClose() to cleanup the persistent connection to the server.
onVisibilityChanged

onVisibilityChanged(visible) {}

Executed when the visibility of the page has changed (tab or instance switch). You’re very likely not going to need this function, but if you do, make sure to call super.onVisibilityChanged(visible).
openEventSource

openEventSource(url, onMesage);

When your widget requires a persistent connection to stream data, use the super.openEventSource() function with the API endpoint and a callback function. The onMessage callback function takes in a single event parameter, of which the data property contains the event data.
closeEventSource

closeEventSource();

Closes the current active EventSource. This will be called automatically if the widget closes and you don’t have the onWidgetClose function overridden. If you do, make sure to call super.onWidgetClose().
BaseTableWidget

The BaseTableWidget exposes a set of functions to easily create a responsive table that is capable of some basic CRUD functionality. To make use of this, simply extend from the BaseTableWidget, which automatically exposes the BaseWidget functions as well. E.g.:

import BaseTableWidget from "./BaseTableWidget.js";

export default class YourWidget extends BaseTableWidget {}

createTable

super.createTable(id, options);

Creates and returns a jQuery object with the id attribute set to the id parameter of this function. The options parameters is an object with the following structure:

let options = {
    headerPosition: 'top'|'left'|'none',
}

If the headerPosition is top, some extra options are defined:

let options = {
    headerPosition: 'top',
    rotation: <number>,
    headers: [],
    sortIndex: <number>,
    sortOrder: 'asc'|'desc'
}

    rotation will limit the amount of table entries to this value, and ‘scroll’ new data into view.

    headers defines a static array of strings that contain the table headers. The position in the array also implicitly defines the index of the column.

    sortIndex specifies the index of the headers array to sort on

    sortOrder if the sortIndex is specified, the sort order will be either ascending or descending.

headerPosition left is a key-value structure while headerPosition none allows for arbitrary rows of data without state.
updateTable

super.updateTable(id, data = [], rowIdentifier = null);

Inserts one or more rows into the table with id parameter id. If a rowIdentifier is specified, only a single row of the table is upserted.

The data layout is as follows for headerPosition top and none:

[
    ['x', 'y', 'z'],
    ['x', 'y', 'z']
]

The data layout for headerPosition left also allows nested columns:

[
    ['x', 'x1'],
    ['y', 'y1'],
    ['z', ['z1', 'z2']]
]

BaseGaugeWidget

BaseGuageWidget defines a simple responsive gauge chart. An example implementation can be found in the Memory Usage Widget
createGaugeChart

super.createGaugeChart(options);

updateChart

super.updateChart(data);

Styling

Any styling can be added to the Dashboard CSS file or a themed version of this file.

Since a lot of the charts have programmatic approaches to colors, the special

:root {
    --chart-js-background-color: #f7e2d6;
    --chart-js-border-color: #d94f00;
    --chart-js-font-color: #d94f00;
}

CSS selector is defined so you can override these colors for custom themes.


Components

OPNsense® components are not directly related to the front and backend.

For the OPNsense framework we’ve developed some shared components for common tasks, this page indexes those components which aren’t directly related to the Model View Controller (MVC) framework itself.

    Menu System
    Access Control List
    Authentication


Menu System

OPNsense Menu System
../../_images/menusystem.png
Overview

One of the shared components of the OPNsense framework is the menu system, which is wrapped in a single class and part of the base model.

The only responsibility of the menu system is to create a tree like structure to represent the menu and being able to keep track of the mapping between a location and the hierarchy of the menu system. To keep things clean and understandable, the menu system doesn’t know anything about users or authorisation.

Currently the main focus for the menu system is to support the legacy code, so we will be able to reimplement the menu in both legacy and new code.

Our base UI controller (\OPNsense\Base\ControllerBase) implements the menu system for further use.

An example of how to create a menu, is given below:

// create new menu
$menu = new Menu\MenuSystem();
// append an additional dynamic item into the system
$menu->appendItem("System.Advanced", "test123", array("url"=>"/testpage.php","order"=>1));
// test, print menu as structured named array
print_r($menu->getItems("/testpage.php"));

The current version only implements a static menu defined by one XML file (models/OPNsense/Base/Menu/Menu.xml), but extending with additional XML files is already supported in the component for future use.
Menu.xml

The menu xml is defined as follows:

<menu>
    <MainItem order="0" VisibleName="System" cssClass="glyphicon glyphicon-dashboard">
        <SubItem1 url="/ui/test.php"/>
        <SubItem2 url="/ui/test2.php"/>
    </MainItem>
</menu>

The top level should be named “menu” to let the system know this is a menu structure, the next layers will be used for the structure of itself. To map the attributes to the menu objects created there are setters in OPNsense\Base\Menu\MenuItem, in this version the next attributes are supported:

    order, sort order in our menu

    VisibleName, name to use ( if not set the tagname / id will be used)

    cssClass, style attributes for the frontend system.


Access Control List

Access Control List
../../_images/acl-finger-print.jpg
Overview

The ACL system is targeted at delivering backwards compatibility for legacy code and being able to extend this to add new features without having to reimplement the whole system.

The following steps determine if a page can be accessed by a user:

    The user, stored in the config.xml file at system/user may set “Effective Privileges” valid for that explicit entry, stored in <priv/> sections

    One or more groups for that user, stored in system/group which contains priv sections as well.

    An XML file (ACL.xml) linking logical acl keys to uri patterns

Access controls for most legacy components are stored in models/OPNsense/Core/ACL/ACL.xml, most new components add their own ACL’s in the model belonging to the component. All stored ACL.xml files combined determine the full set of options available in the user/group manager. There is no expicit requirement which model services which ACL.

Note

When in need of a single ACL to match an explicit set of components (pages/api endpoints), one can add an ACL file easily for a module without further logic.
ACL format

Each ACL file is stored in the model location (/usr/local/opnsense/mvc/app/models/) where ACL.xml files are stored in the location [VENDOR]/[MODULE]/ACL/ACL.xml. The format of the file is as follows:

<acl>
  <my-unique-acl-key>             <!-- as stored for the user/group -->
     <name>My ACL name</name>     <!-- name visible in the user manager -->
     <patterns>
        <pattern>path/to/my/module</pattern>      <!-- list of uri's this ACL should unlock. -->
     </patterns>
  </my-unique-acl-key>
</acL>

Usage from PHP

Using the system from PHP is rather simple:

$acl = new OPNsense\Core\ACL();
if ( $acl->isPageAccessible("user", "/firewall_rules.php") ) {
  print ( "/firewall_rules.php is accessible" ) ;
}

Usage in Volt templates

The ACL scheme is bound to the default UI controller, and can be used by using the acl keyword:

{% if acl.isPageAccessible(session.get('Username'),subMenuItem.Url)  %}
  this page is accessible
{% endif %}


Authentication

Access Control List
../../_images/acl-finger-print.jpg
Concepts

Authentication in OPNsense consists of three basic concepts, which are available throughout the entire system:

    Authenticators

        These implement the method to use, for example Radius, Ldap, local authentication, etc

    Connections

        A connection uses an authenticator and defines the properties needed, for example our Radius server available at our domain using specfic settings.

    Services

        Some services require or support authentication, such as the webinterface, OpenVPN, etc. These may allow one or more connectors.

Authenticators & Connections

Services within OPNsense can use different authentication methods, for which connections can be configured in System ‣ Access ‣ Servers (e.g. the method can be radius which is offered through a server at a location). All of these methods use the same api defined in OPNSenseAuthIAuthConnector, which comes with some simple to use handles.

If a class in OPNSenseAuth implements IAuthConnector it is considered a viable authentication option for the authenticator factory named AuthenticationFactory.

The factory provides a layer of abstraction around the different authentication concepts, for example a server defined in System ‣ Access ‣ Servers can be requested using a simple (new AuthenticationFactory())->get('name'); This connects the authenticator to the configured servers and the response object is ready to handle authentication requests.
Services

We strive to use PAM to define our services, in which case we adopt to existing standards. OPNsense comes with a PAM module, which connects our service definitions with the services defined using PAM.

A simple example of a service named opnsense-login is defined as follows in a file with the name /usr/local/etc/pam.d/opnsense-login

auth                sufficient      pam_opnsense.so
account             sufficient      pam_opnsense.so

To test authentication, you can use opnsense-login for any configured service. The following example tries to authenticate user root for service opnsense-login (the default when no options are specified).

/usr/local/sbin/opnsense-login

See man opnsense-login for a list of available command line options.

Note

opnsense-login inherits from the standard system authentication used for console and web GUI login unless otherwise specified.

Internally PAM calls /usr/local/libexec/opnsense-pam which acts as a stepping stone into the authentication sequence served by /usr/local/libexec/opnsense-auth. Since opnsense-auth is written in php and needs elevated privileges for this task, the stepping stone makes sure it has them granted before executing using the setuid bit.

The authentication script opnsense_auth utilizes our factory class to perform the actual authentication using the connections defined in the service.

For this purpose we expose a services namespace in OPNSenseAuthServices where the required options can be read from the OPNsense configuration.

For every service defined in PAM, the factory method getService() expects a class implementing OPNsenseAuthIService. Using the aliases() static method service classes can support multiple PAM services at once if needed (e.g. System can also be used for ssh).

Note

Not every service uses PAM already, in that case it is defined as a script handling the authentication.

The interface IService is quite easy to read and should be self explanatory.


API Reference
Introduction

The OPNsense API calls are structured in the form:

https://opnsense.local/api/<module>/<controller>/<command>/[<param1>/[<param2>/...]]

There are two HTTP verbs used in the OPNsense API:

        GET Retrieves data from OPNsense

        POST Creates new data, updates existing data or executes an action

The body of the HTTP POST request and response is an ‘application/json’ object.

The $key and $secret parameters are used to pass the API credentials using curl. You need to set these parameters with your own API credentials before using them in the examples:

key=w86XNZob/8Oq8aC5r0kbNarNtdpoQU781fyoeaOBQsBwkXUt
secret=XeD26XVrJ5ilAc/EmglCRC+0j2e57tRsjHwFepOseySWLM53pJASeTA3

Note

When using Postman to test an API call, use the ‘basic auth’ authorization type. The $key and $secret parameters go into Username/Password respectively.

Note

Always make sure the owner of the key is authorized to access the resource in question, the “Effective Privileges” set on the user shows which resources are accessible. (Edit reveals the endpoints assigned to each resource).

ACL’s are explained in development/components/acl).
Required parameters and expected responses

Our auto-generated api documentation can only collect endpoints and their most likely call method (GET, POST), Since almost 99% of our endpoints are actually being used by the gui, it’s not very complicated to find their parameters, you just need a browser and open an inspect pane. Calls being executed from the gui can easily be found by filtering the requests starting with /api/.

For exampe, when looking at the search grid in System ‣ Diagnostics ‣ Services, pressing the reload button will execute a POST to https://my.firewall/api/core/service/search containing the following raw json data:

{"current":1,"rowCount":7,"sort":{},"searchPhrase":""}

And returns a structure similar to:

{
    "total": 10,
    "rowCount": 7,
    "current": 1,
    "rows": [
        {
        "id": "configd",
        "locked": 1,
        "running": 1,
        "description": "System Configuration Daemon",
        "name": "configd"
        },
        ....
    ]
}

A lot of endpoints use the same shared model classes underneath and will thus look quite similar. If classes are bound to a model, the documentation will point to it. Here you can find the standard types to expect, without specific application specific validations.

When more detailed information is needed, best read the Architecture documentation to understand how different areas of the system interact.
Core API

    Captiveportal
    Core
    Cron
    Dhcp
    Dhcpv4
    Dhcpv6
    Dhcrelay
    Diagnostics
    Firewall
    Firmware
    Ids
    Interfaces
    Ipsec
    Kea
    Menu
    Monit
    Openvpn
    Proxy
    Routes
    Routing
    Syslog
    Trafficshaper
    Trust
    Unbound
    Wireguard

Plugins API

    Acmeclient
    Apcupsd
    Backup
    Bind
    Caddy
    Chrony
    Cicap
    Clamav
    Collectd
    Crowdsec
    Dechw
    Diagnostics
    Dnscryptproxy
    Dyndns
    Fetchmail
    Freeradius
    Ftpproxy
    Gridexample
    Haproxy
    Helloworld
    Hwprobe
    Iperf
    Lldpd
    Maltrail
    Mdnsrepeater
    Muninnode
    Netdata
    Netsnmp
    Nginx
    Nodeexporter
    Nrpe
    Ntopng
    Nut
    Openconnect
    Postfix
    Proxy
    Proxysso
    Proxyuseracl
    Puppetagent
    Qemuguestagent
    Quagga
    Radsecproxy
    Redis
    Relayd
    Rspamd
    Shadowsocks
    Siproxd
    Smart
    Softether
    Sslh
    Stunnel
    Tayga
    Telegraf
    Tftp
    Tinc
    Tor
    Udpbroadcastrelay
    Vnstat
    Wazuhagent
    Wireguard
    Wol
    Zabbixagent
    Zabbixproxy
    Zerotier

Business edition API

The business edition comes packed with some additional features which could also be used for integration purposes from third-party applications. The most relevant ones will be explained in this section.

    OPNBECore

Firewall

The firewall API plugin (os-firewall) offers a way for machine to machine interaction between custom applications and OPNsense, it can easily be installed like any other plugin via System ‣ Firmware ‣ Plugins.

Although the plugin does contains a basic user interface (in Firewall ‣ Automation), it’s mirely intended as a reference and testbed. There’s no relation to any of the rules being managed via the core system.

Tip

Use your browsers “inspect” feature to compare requests easily, the user interface in terms of communication is exactly the same as offered by the API . Rules not visible in the web interface (Firewall ‣ Automation) will not be returned by the API either.


Concept

The firewall plugin injects rules in the standard OPNsense firewall while maintaining visibility on them in the standard user interface.

We use our standard ApiMutableModelControllerBase to allow crud operations on rule entries and offer a set of specific actions to apply the new configuration. Since firewall rules can be quite sensitive with a higher risk of lockout, we also support a rollback mechanism here, which offers the ability to rollback this components changes.

The diagram above contains the basic steps to change rules, apply and eventually rollback if not being able to access the machine again. When calling savepoint() a new config revision will be created and the timestamp will be returned for later use. If the cancelRollback(savepoint) is not called within 60 seconds, the firewall will rollback to the previous state identified by the savepoint timestamp (if available).

Note

The examples in this document disable certificate validation, make sure when using this in a production environment to remove the verify=False from the requests calls

Tip

The number of versions kept can be configured as “backup count” in System -> Configuration -> History. This affectively determines within how many configuration changes you can still rollback, if the backup is removed, a rollback will keep the current state (do nothing).
Administration example

Administrative endpoints are pretty standard use of ApiMutableModelControllerBase, the example below searches for a rule named “OPNsense_fw_api_testrule_1”, when not found one will be added otherwise it will print the internal uuid. Inline you will find a brief description of the steps performed.
administrative_example.py

 1#!/usr/bin/env python3.7
 2import requests
 3import json
 4
 5# key + secret from downloaded apikey.txt
 6api_key="3RhWOno+HwvtmT406I6zw8of8J6n9FOKlWK6U0B+K7stt/fDaJg7bjeF3QAshlScYqC+3o5THy3vQViW"
 7api_secret="uaBk27NKhQCZSDpfAlG6YJ473MzvsCNiED6kzbYuykzU05fCRkcJADhDm5nxbZt8yREC74ZpvD/vbcEx"
 8
 9# define the basics, hostname to use and description used to identify our test rule
10rule_description='OPNsense_fw_api_testrule_1'
11remote_uri="https://192.168.1.1"
12
13# search for rule
14r = requests.get(
15    "%s/api/firewall/filter/searchRule?current=1&rowCount=7&searchPhrase=%s" % (
16        remote_uri, rule_description
17    ),
18    auth=(api_key, api_secret), verify=False
19)
20
21if r.status_code == 200:
22    response = json.loads(r.text)
23    if len(response['rows']) == 0:
24        # create a new rule, identified by rule_description allowing traffic from
25        # 192.168.0.0/24 to 10.0.0.0/24 using TCP protocol
26        data = {"rule" :
27                    {
28                    "description": rule_description,
29                    "source_net": "192.168.0.0/24",
30                    "protocol": "TCP",
31                    "destination_net": "10.0.0.0/24"
32                    }
33                }
34        r = requests.post(
35            "%s/api/firewall/filter/addRule" % remote_uri, auth=(api_key, api_secret), verify=False, json=data
36        )
37        if r.status_code == 200:
38            print("created : %s" % json.loads(r.text)['uuid'])
39        else:
40            print("error : %s" % r.text)
41
42    else:
43        for row in response['rows']:
44            print ("found uuid %s" % row['uuid'])

Tip

Since our model contains default values for most attributes, we only need to feed the changes if we would like to keep the defaults. In this case the TCP/IP version was IPv4 by default for example. In most cases one would like to set all relevant properties in case defaults change over time.
Apply / revert example

This example will disable the rule created in the previous example and apply the changes using a savepoint, since we’re not calling cancelRollback(savepoint) it will revert after 60 seconds to the original state.
savepoint_example.py

 1#!/usr/bin/env python3.7
 2import requests
 3import json
 4
 5# key + secret from downloaded apikey.txt
 6api_key="3RhWOno+HwvtmT406I6zw8of8J6n9FOKlWK6U0B+K7stt/fDaJg7bjeF3QAshlScYqC+3o5THy3vQViW"
 7api_secret="uaBk27NKhQCZSDpfAlG6YJ473MzvsCNiED6kzbYuykzU05fCRkcJADhDm5nxbZt8yREC74ZpvD/vbcEx"
 8
 9# define the basics, hostname to use and description used to identify our test rule
10rule_description='OPNsense_fw_api_testrule_1'
11remote_uri="https://192.168.1.1"
12
13# search for rule
14r = requests.get(
15    "%s/api/firewall/filter/searchRule?current=1&rowCount=7&searchPhrase=%s" % (
16        remote_uri, rule_description
17    ),
18    auth=(api_key, api_secret), verify=False
19)
20
21if r.status_code == 200:
22    response = json.loads(r.text)
23    if len(response['rows']) > 0:
24        rule_uuid = response['rows'][0]['uuid']
25        r = requests.post("%s/api/firewall/filter/savepoint" % remote_uri, auth=(api_key, api_secret), verify=False)
26        if r.status_code == 200:
27            sp_response = json.loads(r.text)
28            # disable rule
29            r = requests.post("%s/api/firewall/filter/toggleRule/%s/0" % (remote_uri, rule_uuid),
30                              auth=(api_key, api_secret), verify=False
31            )
32            # apply changes, revert to sp_response['revision'] after 60 seconds
33            r = requests.post("%s/api/firewall/filter/apply/%s" % (remote_uri, sp_response['revision']),
34                              auth=(api_key, api_secret), verify=False
35            )
36            print("revert to revision %s in 60 seconds (%s changed)" % (sp_response['revision'], rule_uuid))
37    else:
38        print("rule %s not found" % rule_description)

Note

The savepoint will only revert this components changes, other changes won’t be affected by this revert, for example add an additional interface between savepoint and revert won’t be affected.


Firmware

OPNsense has several API calls to get and set the firmware configuration:

Method
	

Module
	

Controller
	

Command
	

Parameters

POST
	

core
	

firmware
	

audit
	

POST
	

core
	

firmware
	

changelog
	

$version

POST
	

core
	

firmware
	

check
	

POST
	

core
	

firmware
	

connection
	

GET
	

core
	

firmware
	

get
	

GET
	

core
	

firmware
	

getOptions
	

POST
	

core
	

firmware
	

health
	

GET
	

core
	

firmware
	

info
	

POST
	

core
	

firmware
	

log
	

$clear

POST
	

core
	

firmware
	

poweroff
	

POST
	

core
	

firmware
	

reboot
	

POST
	

core
	

firmware
	

resyncPlugins
	

GET
	

core
	

firmware
	

running
	

POST
	

core
	

firmware
	

set
	

POST
	

core
	

firmware
	

status
	

POST
	

core
	

firmware
	

syncPlugins
	

POST
	

core
	

firmware
	

update
	

POST
	

core
	

firmware
	

upgrade
	

GET
	

core
	

firmware
	

upgradestatus
	

Examples:

curl -k -u "$key":"$secret" https://opnsense.local/api/core/firmware/getfirmwareconfig -v

curl -k -u "$key":"$secret" https://opnsense.local/api/core/firmware/status -v

curl -d '' -k -u "$key":"$secret" https://opnsense.local/api/core/firmware/changelog/18.1 -v

Packages

You can manage the packages and plugins in OPNsense, using these API calls:

Method
	

Module
	

Controller
	

Command
	

Parameters

POST
	

core
	

firmware
	

details
	

$pkg_name

POST
	

core
	

firmware
	

install
	

$pkg_name

POST
	

core
	

firmware
	

license
	

$pkg_name

POST
	

core
	

firmware
	

lock
	

$pkg_name

POST
	

core
	

firmware
	

remove
	

$pkg_name

POST
	

core
	

firmware
	

reinstall
	

$pkg_name

POST
	

core
	

firmware
	

unlock
	

$pkg_name

Examples:

curl -d '' -k -u "$key":"$secret" https://opnsense.local/api/core/firmware/lock/os-xen -v

curl -d '' -k -u "$key":"$secret" https://opnsense.local/api/core/firmware/license/acme.sh -v


OPNBECore
Resources (SyncController.php) – extends : ApiControllerBase

Method
	

Module
	

Controller
	

Command
	

Parameters

GET
	

opncentral
	

sync
	

listServices
	

GET
	

opncentral
	

sync
	

listClasses
	

GET
	

opncentral
	

sync
	

metrics
	

GET
	

opncentral
	

sync
	

readConfig
	

$paths

POST
	

opncentral
	

sync
	

reconfigure
	

POST
	

opncentral
	

sync
	

restartService
	
Sync API explained

The sync API is being used to process central actions in parallell from the OPNcentral dashboard. As explained in the documentation for OPNcentral, provisioning is able to detect change on the sections it may distribute. In order to do this the listClasses API action plays a large role here.
listClasses

The list classes endpoint provides insights into the different configuration items the target host understands and how these are tied into services. It’s also a key component in comparing configuration items.

{
  "classes": [
    {
      "description": "Aliases",
      "help": "Synchronize the aliases over to the other HA host.",
      "section": "OPNsense.Firewall.Alias",
      "services": [
        "pf"
      ],
      "md5": "942d6358fb4f17abed7cf4f5de6c5b24",
      "id": "aliases"
    },
  "runtime": 0.07380509376525879
}

When the target firewall is 100% equal to the central node, the md5 values will match. In order to steer specific overrides on the synchronisation action, it is possible to send a json encoded base64 structure as metadata post parameter (not available in the online documentation, advanced usage only).
readConfig

This endpoint is responsible for providing access to various parts of the configuration and mostly practical to retrieve parts of the configuration.

Example usage of this endpoint is provided below.

import json
import requests
auth = {
  "key":"3RhWOno+HwvtmT406I6zw8of8J6n9FOKlWK6U0B+K7stt/fDaJg7bjeF3QAshlScYqC+3o5THy3vQViW",
  "secret":"uaBk27NKhQCZSDpfAlG6YJ473MzvsCNiED6kzbYuykzU05fCRkcJADhDm5nxbZt8yREC74ZpvD/vbcEx"
}
r = requests.get(
    'https://127.0.0.1/api/opncentral/sync/read_config/OPNsense.Firewall.Alias',
    auth=(auth['key'], auth['secret']),
    verify=False    # use for localhost testing only
)
print(r.text)

When executed, this will dump the contents of the configuration path OPNsense.Firewall.Alias into a named array with serialisable content.
reconfigure

The reconfigure action is the counterpart of the readConfig endpoint and accepts new configuration data specified in the payload attribute of the POST request.

In some cases configuration merges have ways to handle local changes, which is documented in the “Provisioning classes” section of the OPNcentral documentation.

After merging the new configuration, this endpoint also detects which services need to be restarted and will issue a restart command automatically.

import json
import requests
auth = {
  "key":"3RhWOno+HwvtmT406I6zw8of8J6n9FOKlWK6U0B+K7stt/fDaJg7bjeF3QAshlScYqC+3o5THy3vQViW",
  "secret":"uaBk27NKhQCZSDpfAlG6YJ473MzvsCNiED6kzbYuykzU05fCRkcJADhDm5nxbZt8yREC74ZpvD/vbcEx"
}

payload = "<<dictionary type content from readConfig>>"

r = requests.post(
    'https://127.0.0.1/api/opncentral/sync/reconfigure',
    auth=(auth['key'], auth['secret']),
    json={'payload': payload},
    verify=False,   # use for localhost testing only
    headers={'Content-Type': 'application/json; charset=UTF-8'}
)

listServices

In order to gain insights on the active running services, you can use the listServices api action. This will report all active services and their status.
restartService

The restart service action is also used in Management: Status / Services and offers the ability to restart a list of selected services on the target host.

import json
import requests
auth = {
  "key":"3RhWOno+HwvtmT406I6zw8of8J6n9FOKlWK6U0B+K7stt/fDaJg7bjeF3QAshlScYqC+3o5THy3vQViW",
  "secret":"uaBk27NKhQCZSDpfAlG6YJ473MzvsCNiED6kzbYuykzU05fCRkcJADhDm5nxbZt8yREC74ZpvD/vbcEx"
}

r = requests.post(
    'https://127.0.0.1/api/opncentral/sync/restart_service',
    auth=(auth['key'], auth['secret']),
    json={'services':['cron']},
    verify=False,     # use for localhost testing only
    headers={'Content-Type': 'application/json; charset=UTF-8'}
)

The example above will restart the cron service.


Examples

    Hello world module & plugin
    Using grids module & plugin
    API enable standard services


Hello world module & plugin

Creating the hello world module
../../_images/Hello-World.jpg
Goal

Goal for this sample

The goal of the “Hello world” module we’re creating in the example is to control a program on our system named “testConnection.py”, which is part of the example package available on GitHub. It will try to send an email using plain smtp and will respond with a json text message about the result of that attempt.

Our application will need some settings to operate correctly, like an ip address and an email address and we need to be able to run that application. Because this application returns some valuable data for our users, we need to be able to fetch the response data back.

overview
Guidelines

Guidelines and coding style

For all OPNsense modules and applications there are some basic style and coding guides which you should use.
Naming

When creating modules for OPNsense, always name your components like this: VendorName/ModuleName

In our sample case this will be: OPNsense/HelloWorld
PHP code

Please use PSR-2 style (http://www.php-fig.org/psr/psr-2/) for all new code.
Architecture

Always make sure there’s a clear separation of concerns, back-end calls (like shell scripts) should be implemented using the configd system, all communication to the client should be handled from an API endpoint. (the example provides more insights on how this works).

Back-end programs should not access the config.xml directly, if data is needed let the template system handle the desired output (most applications, daemons and tools deliver their own desired configuration format). There’s generally no good reason to avoid the standards that are already there.

If you follow this basic rules, you’re automatically building a command structure for the system administrators and provide a connector to third party tools to the API of your component (as of version 16.1).
Directory structure

We will build our HelloWorld example step by step and create several files. Here is the directory structure and the files which will get created:

./src/opnsense/
  ├── mvc/
  |   └── app/
  |       ├── controllers/
  |       |   └── OPNsense/HelloWorld/
  |       |       ├── IndexController.php
  |       |       ├── Api/
  |       |       |   ├── ServiceController.php
  |       |       |   ├── SettingsController.php
  |       |       |   └── SimplifiedSettingsController.php
  |       |       └── forms/
  |       |           └── general.xml
  |       ├── models/
  |       |   └── OPNsense/HelloWorld/
  |       |       ├── HelloWorld.php
  |       |       ├── HelloWorld.xml
  |       |       ├── ACL/
  |       |       |   └── ACL.xml
  |       |       └── Menu/
  |       |           └── Menu.xml
  |       └── views/
  |           └── OPNsense/HelloWorld/
  |               └── index.volt
  ├── scripts/
  |   └── OPNsense/HelloWorld/
  |       └── testConnection.py
  └── service/
      ├── templates/
      |   └── OPNsense/HelloWorld/
      |       ├── +TARGETS
      |       └── helloworld.conf
      └── conf/actions.d/
          └── actions_helloworld.conf

Skeleton

Setup a skeleton for the frontend / middleware

First step for our project is to build a skeleton which holds the structure for our frontend/middleware.
Model

For our sample application we want to setup some configuration data, which for all new style projects should live in it’s own model.

First we start by creating two files inside the models/OPNsense/HelloWorld directory.

The first one is the boilerplate for the model class, which should contain model specific methods and (by deriving it from BaseModel) automatically understands the second file.
/usr/local/opnsense/mvc/app/models/OPNsense/HelloWorld/HelloWorld.php

<?php
namespace OPNsense\HelloWorld;

use OPNsense\Base\BaseModel;

class HelloWorld extends BaseModel
{
}

Not all modules contain additional code in the PHP class, sometimes all the standard behaviour is already sufficient for your modules/application.

Which is the model XML template, our skeleton starts with something like this:
/usr/local/opnsense/mvc/app/models/OPNsense/HelloWorld/HelloWorld.xml

<model>
    <mount>//OPNsense/helloworld</mount>
    <description>
        the OPNsense "Hello World" application
    </description>
    <items>
    </items>
</model>

The content of the mount tag is very important, this is the location within the config.xml file where this model is responsible. Other models cannot write data into the same area. You should name this location with your vendor and module name to make sure others could easily identify it.

Use the description tag to identify your model, the last tag in place is the items tag, where the actual definition will live. We leave it empty for now as we proceed with the next step of creating our skeleton.
View

Page template (View)

We should add a (Volt) template to use for the index page of our module; we will use the same naming convention here.

Create a template named index.volt inside the views/OPNsense/HelloWorld directory containing the following data:
/usr/local/opnsense/mvc/app/views/OPNsense/HelloWorld/index.volt

<h1>Hello World!</h1>

Controller

Next step is to add controllers, which will be automatically picked up by the system routing. A controller connects the user interaction to logic and presentation.

Every OPNsense module should separate presentation from logic, that’s why there should always be multiple controllers per module.

Our first controller handles the template rendering to the user and connects the user view we just created. We start by creating a PHP file in controllers/OPNsense/HelloWorld/ with the following name IndexController.php and contents:
/usr/local/opnsense/mvc/app/controllers/OPNsense/HelloWorld/IndexController.php

<?php
namespace OPNsense\HelloWorld;
class IndexController extends \OPNsense\Base\IndexController
{
    public function indexAction()
    {
        // pick the template to serve to our users.
        $this->view->pick('OPNsense/HelloWorld/index');
    }
}

At this point you should be able to test if your work so far was successful, by going to the following location (after being logged in to the firewall as root user):

http[s]://<your ip>/ui/helloworld/

Which should serve you the “Hello World!” text you’ve added in the template.

Serving the first "hello world" page

Next two controllers we are going to create are to be used for the api to the system, they should take care of service actions and the retrieval/changing of configuration data.

They should live in a subdirectory of the controller called Api and extend the corresponding class.

For our modules we create two API controllers, one for controlling settings and one for performing service actions. (Named SettingsController.php and ServiceController.php) Both should look like this (replace Settings with Service for the other one):
/usr/local/opnsense/mvc/app/controllers/OPNsense/HelloWorld/Api/SettingsController.php

<?php
namespace OPNsense\HelloWorld\Api;

use \OPNsense\Base\ApiControllerBase;
class SettingsController extends ApiControllerBase
{
}

First Input Form

Building your first input form

The first step in building forms is to determine what information we should collect.

Our simple application will send an email using data in our configuration xml. For this very module we want to collect the following:

Property
	

Default
	

Description

General.Enabled
	

Enabled (1)
	

Should this module be enabled (Boolean)

General.SMTPHost
	

<empty>
	

IP address for the remote smtp host

General.FromEmail
	

sample@example.com
	

Email address of the sender

General.ToEmail
	

<empty>
	

Email address to send our test email to

General.Description
	

<empty>
	

Description, used as subject of the email.
Adding Fields

Adding fields to your model

When building the skeleton, we have created an empty model (XML), which we are going to fill with some attributes now. The items section of the model XML should contain the structure you want to use for your application, you can create trees to hold data in here. All leaves should contain a field type to identify and validate it’s content. The list of attributes for our application can be translated to this:
/usr/local/opnsense/mvc/app/models/OPNsense/HelloWorld/HelloWorld.xml

………
<items>
    <!-- container -->
    <general>
        <!-- fields -->
        <Enabled type="BooleanField">
            <default>1</default>
            <Required>Y</Required>
        </Enabled>
        <SMTPHost type="NetworkField">
            <Required>Y</Required>
        </SMTPHost>
        <FromEmail type="EmailField">
            <default>sample@example.com</default>
            <Required>Y</Required>
        </FromEmail>
        <ToEmail type="EmailField">
            <Required>Y</Required>
        </ToEmail>
        <Description type="TextField">
            <Required>Y</Required>
        </Description>
    </general>
</items>
………

All available field types can be found in the models/OPNsense/Base/FieldTypes directory. If specific field types support additional parameters, for example for validation, they should be registered in the model as well (just like the default tag in Enabled).
Presentation XML

Create a presentation XML to feed your template

Because creating forms is one of the key assets of the system, we have build some easy to use wrappers to guide you through the process. First we create an XML file for the presentation, which defines fields to use and adds some information for your template to render. Create a file in your controller directory using the sub directory forms and name it general.xml. Next copy in the following content:
/usr/local/opnsense/mvc/app/controllers/OPNsense/HelloWorld/forms/general.xml

<form>
    <field>
        <id>helloworld.general.Enabled</id>
        <label>enabled</label>
        <type>checkbox</type>
        <help>Enable this feature</help>
    </field>
    <field>
        <id>helloworld.general.SMTPHost</id>
        <label>SMTPHost</label>
        <type>text</type>
        <help><![CDATA[ip address of the mail host]]></help>
        <hint>choose a valid IPv4/v6 address</hint>
    </field>
    <field>
        <id>helloworld.general.FromEmail</id>
        <label>Email (from)</label>
        <type>text</type>
    </field>
    <field>
        <id>helloworld.general.ToEmail</id>
        <label>Email (to)</label>
        <type>text</type>
    </field>
    <field>
        <id>helloworld.general.Description</id>
        <label>Description</label>
        <type>text</type>
    </field>
 </form>

All items should contain at least an id (where to map data from/to), a type (how to display) and a label, which identifies it to the user. Optional you may add additional fields like help or mark features as being only for advanced users. (The Volt template defines which attributes are usable.)

Now we need to tell the controller to use this information and pass it to your template, so change the IndexController.php and add this line:

$this->view->generalForm = $this->getForm("general");

And we are ready to update the (Volt) template with this information. Let’s remove the “<h1>Hello World!</h1>” line and replace it with something like this:

{{ partial("layout_partials/base_form",['fields':generalForm,'id':'frm_GeneralSettings'])}}

This tells the template system to add a form using the contents of generalForm and name it frm_GeneralSettings in the HTML page. Based on a standard template part which is already part of the standard system, named base_form.volt.

When opening the page again it will render like this:

Template with fields without content
Create API calls

Create API calls to retrieve and store data

The framework provides some helpful utilities to get and set data from and to the configuration XML by using your defined model. First step in binding your model to the system is to add a method to the SettingsController to fetch the data from our configuration (or provide the defaults if there is no content).

We start by adding the model to our SettingsController, by adding this in the “use” section:

use \OPNsense\HelloWorld\HelloWorld;

Which includes our model into the controller. Next we create an action to get data from our system, and put it into a json object for the client (browser) to parse, by using the wrappers already in our model.
/usr/local/opnsense/mvc/app/controllers/OPNsense/HelloWorld/Api/SettingsController.php

* retrieve HelloWorld general settings
 * @return array general settings
 */
public function getAction()
{
    // define list of configurable settings
    $result = array();
    if ($this->request->isGet()) {
        $mdlHelloWorld = new HelloWorld();
        $result['helloworld'] = $mdlHelloWorld->getNodes();
    }
    return $result;
}

You will probably notice the return value of the action, it’s a standard array which uses “helloworld” for all attributes from getNodes() which will automatically be converted by the framework to a json object for the client. The getNodes method itself returns a tree a values, as defined by your model.

You can test the result (while logged in as root), by going to this address:

http[s]://<your ip>/api/helloworld/settings/get

For saving the data back, we need a similar kind of call, let’s name it “set” and add this to the same php file:
/usr/local/opnsense/mvc/app/controllers/OPNsense/HelloWorld/Api/SettingsController.php

/**
 * update HelloWorld settings
 * @return array status
 */
public function setAction()
{
    $result = array("result"=>"failed");
    if ($this->request->isPost()) {
        // load model and update with provided data
        $mdlHelloWorld = new HelloWorld();
        $mdlHelloWorld->setNodes($this->request->getPost("helloworld"));

        // perform validation
        $valMsgs = $mdlHelloWorld->performValidation();
        foreach ($valMsgs as $field => $msg) {
            if (!array_key_exists("validations", $result)) {
                $result["validations"] = array();
            }
            $result["validations"]["general.".$msg->getField()] = $msg->getMessage();
        }

        // serialize model to config and save
        if ($valMsgs->count() == 0) {
            $mdlHelloWorld->serializeToConfig();
            Config::getInstance()->save();
            $result["result"] = "saved";
        }
    }
    return $result;
}

And include the Config class from our base system by adding this to the “use” section:

use \OPNsense\Core\Config;

[Create API calls] Simplify a recurring pattern

As one can imagine, retrieving and setting data is a pattern that is used quite often and for which we would like to minimize the amount of work needed to incorporate.

The API example can be simplified by using one of our base classes (ApiMutableModelControllerBase), which would lead to the same result. For comparison we have added a different endpoint in SimplifiedSettingsController.php

class SimplifiedSettingsController extends ApiMutableModelControllerBase
{
    protected static $internalModelName = 'helloworld';
    protected static $internalModelClass = 'OPNsense\HelloWorld\HelloWorld';
}

The “magic” is hidden underneath, but equals the example previously given. $internalModelName declares the root of the returned array structure, $internalModelClass tells the controller which model it should use.

We recommend using (ApiMutableModelControllerBase) in most cases, but to better understand the components and their responsibilities we choose to explain the separate steps.

Note

ApiMutableModelControllerBase contains more shared functionality for grid like operations as well, most of our api controllers use this as a base.
Support jQuery API calls

Update the view to support the API calls using jQuery

Now we need to link the events to the backend code to be able to load and save our form, by using the OPNsense libraries you can validate your data automatically.

Add this to the index.volt template from the HelloWorld module:

<script type="text/javascript">
    $( document ).ready(function() {
        var data_get_map = {'frm_GeneralSettings':"/api/helloworld/settings/get"};
        mapDataToFormUI(data_get_map).done(function(data){
            // place actions to run after load, for example update form styles.
        });

        // link save button to API set action
        $("#saveAct").click(function(){
            saveFormToEndpoint(url="/api/helloworld/settings/set",formid='frm_GeneralSettings',callback_ok=function(){
                // action to run after successful save, for example reconfigure service.
            });
        });


    });
</script>

<div class="col-md-12">
    <button class="btn btn-primary"  id="saveAct" type="button"><b>{{ lang._('Save') }}</b></button>
</div>

The first piece of javascript code handles the loading of data when opening the form, then a button is linked to the save event.

Let’s give it a try and save our data, without modifying it first.

Form with validation errors

Next correct the errors and save again, on successful save the data should be stored in the config.xml. If you want to change validation messages, just edit the model XML and add your message in the ValidationMessage tag. For example:

<ToEmail type="EmailField">
    <Required>Y</Required>
    <ValidationMessage>please specify a valid email address</ValidationMessage>
</ToEmail>

Changes the “email address invalid” into “please specify a valid email address”

Tip

replace /api/helloworld/settings with /api/helloworld/simplifiedsettings to use the simplified api controller as explained in “Simplify a recurring pattern” earlier.
Add actions

Add some activity to the module

Our basic module provides a way to read and modify configuration data using the web interface (and in time also other consumers using the api). Next step is to add some activity to our system, all backend applications should use their own configuration, which in real life we would keep as standard as possible.

For our example we will follow the same process as for any other service and start writing some configuration data for our sample application. Which means, creating a template and hooking it into our save action.

Our example will write a simple configuration file, stored in /usr/local/etc/helloworld/helloworld.conf

The configd system is responsible for updating the contents of that file when requested, it does so by using a definition found in its template folder. This sample will use the following path to store the backend templates:

/usr/local/opnsense/service/templates/OPNsense/HelloWorld/

First we add a content definition, by creating a file named +TARGETS, which should hold the following information:

helloworld.conf:/usr/local/etc/helloworld/helloworld.conf

This basically tells the engine that there will be a file in the same folder named “helloworld.conf” which provides, together with config.xml, data for the file in /usr/local/etc/helloworld/helloworld.conf

Next thing to do is create that helloworld.conf file in the templates directory. We will keep things very simple for this one and just copy in our data into an ini file structured configuration, when the module is enabled.
/usr/local/opnsense/service/templates/OPNsense/HelloWorld/helloworld.conf

{% if helpers.exists('OPNsense.helloworld.general') and OPNsense.helloworld.general.Enabled|default("0") == "1" %}
[general]
SMTPHost={{ OPNsense.helloworld.general.SMTPHost|default("") }}
FromEmail={{ OPNsense.helloworld.general.FromEmail|default("") }}
ToEmail={{ OPNsense.helloworld.general.ToEmail|default("") }}
Subject={{ OPNsense.helloworld.general.Description|default("") }}
{% endif %}

Now we need to be able to reload this module (or in real life, this would probably be a service) by adding a service action into our ServiceController. Edit controllers/OPNsense/HelloWorld/Api/ServiceController.php and add the backend module to the use section, like this:

use \OPNsense\Core\Backend;

By doing this we can use the backend communication in this class. Next add a new action to the class called “reloadAction” using this piece of code:
/usr/local/opnsense/mvc/app/controllers/OPNsense/HelloWorld/Api/ServiceController.php

public function reloadAction()
{
    $status = "failed";
    if ($this->request->isPost()) {
        $backend = new Backend();
        $bckresult = trim($backend->configdRun("template reload OPNsense/HelloWorld"));
        if ($bckresult == "OK") {
            $status = "ok";
        }
    }
    return array("status" => $status);
}

This validates the type of action (it should always be POST to enable CSRF protection) and adds a backend action for reloading the template. When successful the action will return “status”:”ok” as json object back to the client.

Now we are able to refresh the template content, but the user interface doesn’t know about it yet. To hook loading of the template into the save action, we will go back to the index.volt view and add the following jQuery / framework code between the braces of “saveFormToEndPoint”.

ajaxCall(url="/api/helloworld/service/reload", sendData={},callback=function(data,status) {
    // action to run after reload
});

If you save the form now (when enabled), you should see a new file in

helloworld.conf:/usr/local/etc/helloworld/helloworld.conf

Containing something like this:

[general]
SMTPHost=127.0.0.1
FromEmail=sample@example.com
ToEmail=sample@example.com
Subject=test

What have we accomplished now, we can input data, validate it and save it to the corresponding format of the actual service or application, which uses this data. So if you have a third party application, which you want to integrate into the user interface. You should be able to generate what it needs now. (There’s more to learn, but these are the basics).

But how do should we control that third part program now? That’s the next step.
Controlling the sample

Instead of running all kinds of shell commands directly from the PHP code, which very often need root access (starting/stopping services, etc.), we should always communicate to our backend process which holds templates of possible things to run and protects your system from executing arbitrary commands.

Another advantage of this approach is that all commands defined here, can also be ran from the command line of the firewall providing easier serviceability. For example, the command to refresh the helloworld configuration can be run from the command line by running:

configctl template reload OPNsense/HelloWorld

First thing to do when registering new actions to the system for a new application is to create a config template.

/usr/local/opnsense/service/conf/actions.d/actions_helloworld.conf

And add a command to the template like this:

[test]
command:/usr/local/opnsense/scripts/OPNsense/HelloWorld/testConnection.py
parameters:
type:script_output
message:hello world module test

Let’s test our new command by restarting configd from the command line:

service configd restart

And test our new command using:

configctl helloworld test

Which should return some response in json format.

Next step is to use this command in our controller (middleware), just like we did with the template action. For consistency we call our action testAction and let it pass json data to our clients when using a POST type request.
/usr/local/opnsense/mvc/app/controllers/OPNsense/HelloWorld/Api/ServiceController.php

public function testAction()
{
    if ($this->request->isPost()) {
        $backend = new Backend();
        $bckresult = json_decode(trim($backend->configdRun("helloworld test")), true);
        if ($bckresult !== null) {
            // only return valid json type responses
            return $bckresult;
        }
    }
    return array("message" => "unable to run config action");
}

And now we can make our user interface aware of the action, place a button and link an action in the index.volt. Using the following elements:

(in script section)

$("#testAct").click(function(){
    $("#responseMsg").removeClass("hidden");
    ajaxCall(url="/api/helloworld/service/test", sendData={},callback=function(data,status) {
        // action to run after reload
        $("#responseMsg").html(data['message']);
    });
});

(in HTML section)
/usr/local/opnsense/mvc/app/views/OPNsense/HelloWorld/index.volt

<div class="alert alert-info hidden" role="alert" id="responseMsg">

</div>
<button class="btn btn-primary"  id="testAct" type="button"><b>{{ lang._('Test') }}</b></button>

Now go back to the page and save some data using the save button, next press test to see some results.

test the application action
Multi language / Translations

OPNsense is available in may different languages like english, german or japanese. This works because we are using the gettext library which is available to all GUI components. While the XML based user interfaces are supporting it automatically, there may still the need to call it manually (buttons, tabs etc.).

If you have a static string, you should add it like this into a classic PHP page:

<?= gettext('your string here') ?>

And this way into a volt template:

{{ lang._('your string here') }}

If your string is not only plaintext because it contains non-static words, HTML tags and other dynamic content, you need to use a format string. This way, you can use placeholders for such elements which should not land in the translation file.

For php it works this way:

<?= sprintf(gettext('your %s here'), $data) ?>

And for volt templates it works this way:

{{ lang._('your %s here') | format(data) }}

Note

You should NEVER split strings which should belong together like a sentence. This makes plugins hard to translate and will decrease the quality of OPNsense in other languages.
Plugin to the menu system

Most modules and applications need a place in the menu system, you could easily arrange that by creating a Menu.xml definition for your module in the model directory under Menu/Menu.xml.

Now let’s register our “hello world” in the user section of our menu, by adding this content into the Menu.xml:
/usr/local/opnsense/mvc/app/models/OPNsense/HelloWorld/Menu/Menu.xml

<menu>
    <!-- Plugin HelloWorld menu -->
    <User order="999">
        <HelloWorld VisibleName="Hello World!" url="/ui/helloworld/"/>
    </User>
</menu>

When you refresh your page now, you should notice the menu system automatically picks up this new information.

menu registration
Plugin to access control (ACL)

If we want to authorize users to access this module, we can add an ACL to this module. Without it, only admin users can access it. Create an XML file in the model directory name ACL/ACL.xml and place the following content in it:
/usr/local/opnsense/mvc/app/models/OPNsense/HelloWorld/ACL/ACL.xml

<acl>
    <!-- unique acl key, must be globally unique for all ACLs  -->
    <page-user-helloworld>
        <name>WebCfg - Users: Hello World! </name>
        <description>Allow access to the Hello World! module</description>
        <patterns>
            <pattern>ui/helloworld/*</pattern>
            <pattern>api/helloworld/*</pattern>
        </patterns>
    </page-user-helloworld>
</acl>

This creates an ACL key named “page-user-helloworld” which authorizes access to both the ui and API urls of this application. You can now grant access to this module from the system user manager.
Create an installable plugin

All files are created in their original locations (on the OPNsense machine /usr/local/…), now we are ready to create a package from them. To fully use this process and create the actual package, it’s best to setup a full build environment (explained over here: https://github.com/opnsense/tools )

When everything is in place, we will create a new plugin directory. For this example we will use the following:

/usr/plugins/devel/helloworld/

Add a new Makefile, containing the information for our plugin:

PLUGIN_NAME=     helloworld
PLUGIN_VERSION=        1.0
PLUGIN_COMMENT=        A sample framework application
#PLUGIN_DEPENDS=
PLUGIN_MAINTAINER= user@domain

.include "../../Mk/plugins.mk"


Then create an src directory in here:

/usr/plugins/devel/helloworld/src/

Next copy all files created and located in /usr/local/ into this new src directory, which results in the following file listing:

src/opnsense/mvc/app/controllers/OPNsense/HelloWorld/Api/ServiceController.php
src/opnsense/mvc/app/controllers/OPNsense/HelloWorld/Api/SettingsController.php
src/opnsense/mvc/app/controllers/OPNsense/HelloWorld/Api/SimplifiedSettingsController.php
src/opnsense/mvc/app/controllers/OPNsense/HelloWorld/IndexController.php
src/opnsense/mvc/app/controllers/OPNsense/HelloWorld/forms/general.xml
src/opnsense/mvc/app/models/OPNsense/HelloWorld/ACL/ACL.xml
src/opnsense/mvc/app/models/OPNsense/HelloWorld/HelloWorld.php
src/opnsense/mvc/app/models/OPNsense/HelloWorld/HelloWorld.xml
src/opnsense/mvc/app/models/OPNsense/HelloWorld/Menu/Menu.xml
src/opnsense/mvc/app/views/OPNsense/HelloWorld/index.volt
src/opnsense/scripts/OPNsense/HelloWorld/testConnection.py
src/opnsense/service/templates/OPNsense/HelloWorld/+TARGETS
src/opnsense/service/templates/OPNsense/HelloWorld/helloworld.conf
src/opnsense/service/conf/actions.d/actions_helloworld.conf

With everything in place, you could build the plugin package using the “make plugins” command in the /usr/tools directory. The result of this will be a standard pkg package, which you can install on any OPNsense system and will be usable right after installing. All plugins are prefixed with os-, our new package file will be called:

os-helloworld-1.0.txz

(-1.0 comes from the version in the makefile)

Reference

    source of this example : https://github.com/opnsense/plugins/tree/master/devel/helloworld

    build instructions : https://github.com/opnsense/tools

    practical frontend development : https://github.com/opnsense/ui_devtools

    frontend template language reference (Volt) : https://docs.phalconphp.com/en/latest/reference/volt.html

    configuration template language reference (mostly the same as Volt) : http://jinja.pocoo.org/docs/dev/

    OPNsense architecture Architecture

    OPNsense creating models Develop:Frontend/Creating_models


Using grids module & plugin

Creating grid enabled forms
../../_images/grid-sample.png
Goal

The purpose of this example is to show how to build data grids in OPNsense, using the various components within our framework.

If you haven’t read the HelloWorld example yet, we advise you to start there. This example assumes you already know the basics.

Our topic of choice for this module is a basic list for email addresses, for which you should be able to add, remove and change items.
Model

Our example starts with a model, which is constructed by creating a php class deriving from BaseModel and an XML file containing the actual model definition.
/usr/local/opnsense/mvc/app/models/OPNsense/GridExample/GridExample.php

1<?php
2namespace OPNsense\GridExample;
3
4use OPNsense\Base\BaseModel;
5
6class GridExample extends BaseModel
7{
8}

/usr/local/opnsense/mvc/app/models/OPNsense/GridExample/GridExample.xml

 1<model>
 2    <mount>//OPNsense/GridExample</mount>
 3    <description>
 4        the OPNsense "GridExample" application
 5    </description>
 6    <items>
 7        <addresses>
 8            <address type="ArrayField">
 9                <enabled type="BooleanField">
10                    <default>1</default>
11                    <Required>Y</Required>
12                </enabled>
13                <email type="EmailField">
14                    <Required>Y</Required>
15                </email>
16            </address>
17        </addresses>
18    </items>
19</model>

Note the ArrayField type in the XML, this is a special field type for nested items in automatically includes an internal uuid for easy referencing when written to disk. Both other field types are also used in the HelloWorld example earlier. All the preinstalled types can be found in our field type directory on GitHub.
API controller

The ApiMutableModelControllerBase class supports most model manipulations, all *Base methods embody shared functionality to operate on either new or existing model items.

Our example below uses the base methods to link all operations we need and link them on endpoints ending at Item:

    searchItemAction, queries the items in your configuration

    getItemAction, fetches an existing record (or returns a blank one with all defaults)

    addItemAction, add a new record

    setItemAction, update a record

    delItemAction, delete a record

    toggleItemAction, toggle [0|1] the “enabled” property (see the enabled BooleanField in the model)

/usr/local/opnsense/mvc/app/controllers/OPNsense/GridExample/Api/SettingsController.php

 1namespace OPNsense\GridExample\Api;
 2
 3use \OPNsense\Base\ApiMutableModelControllerBase;
 4
 5class SettingsController extends ApiMutableModelControllerBase
 6{
 7    protected static $internalModelName = 'gridexample';
 8    protected static $internalModelClass = 'OPNsense\GridExample\GridExample';
 9
10    public function searchItemAction()
11    {
12        return $this->searchBase("addresses.address", array('enabled', 'email'), "email");
13    }
14
15    public function setItemAction($uuid)
16    {
17        return $this->setBase("address", "addresses.address", $uuid);
18    }
19
20    public function addItemAction()
21    {
22        return $this->addBase("address", "addresses.address");
23    }
24
25    public function getItemAction($uuid = null)
26    {
27        return $this->getBase("address", "addresses.address", $uuid);
28    }
29
30    public function delItemAction($uuid)
31    {
32        return $this->delBase("addresses.address", $uuid);
33    }
34
35    public function toggleItemAction($uuid, $enabled = null)
36    {
37        return $this->toggleBase("addresses.address", $uuid, $enabled);
38    }
39}

The parameters of all methods contain at least the root of the ArrayField type you want to operate on and in cases the action involves form data the name of the root property used as in the container to transport data in.

For example, a getItem (/api/gridexample/settings/getItem/my-uuid-id) would return a response like this (highlighted the container):

1{
2  "address": {
3    "enabled": "1",
4    "email": "test@example.com"
5  }
6}

Define dialog items

To edit the data we define which fields should be presented to the user and how they are formatted. Below a simple layout, the id fields reference the actual data points to map (address.enabled for example), which is exactly what the api endpoint returns.
/usr/local/opnsense/mvc/app/controllers/OPNsense/GridExample/forms/dialogAddress.xml

<form>
    <field>
        <id>address.enabled</id>
        <label>enabled</label>
        <type>checkbox</type>
        <help>Enable this address</help>
    </field>
    <field>
        <id>address.email</id>
        <label>Email</label>
        <type>text</type>
    </field>
</form>

Constructing the volt template

We ship a javascript wrapper to implement a slightly modified version of jquery-bootgrid, to use this in our template (view) we define three different blocks.

First of all we bind a table by id (grid-addresses) using UIBootgrid(), then we define the table which will be changed into a dynamic searchable grid and finally we link our dialog content using a volt partial().

The basic “UIBootgrid” bind connects all actions which we have defined in our API controller earlier, there are more options available, but these are not needed for this use-case.

When defining the table, we need to add all fields that should be displayed and the order in which they should appear. If fields should not be visible by default, simply use data-visible="false" on the <th> tag.

Our edit dialog is being written in advance so the javascript code can open the statically defined form when needed, the last highlighted block takes care of this. The partial uses three argument, the variable connected via the controller containing all form entries, the name (id) of the form, which is referenced in the table (data-editDialog) and the caption of the dialog.
/usr/local/opnsense/mvc/app/views/OPNsense/GridExample/index.volt

 1<script>
 2    $( document ).ready(function() {
 3        $("#grid-addresses").UIBootgrid(
 4            {   search:'/api/gridexample/settings/searchItem/',
 5                get:'/api/gridexample/settings/getItem/',
 6                set:'/api/gridexample/settings/setItem/',
 7                add:'/api/gridexample/settings/addItem/',
 8                del:'/api/gridexample/settings/delItem/',
 9                toggle:'/api/gridexample/settings/toggleItem/'
10            }
11        );
12    });
13</script>
14<table id="grid-addresses" class="table table-condensed table-hover table-striped" data-editDialog="DialogAddress">
15    <thead>
16        <tr>
17            <th data-column-id="uuid" data-type="string" data-identifier="true"  data-visible="false">{{ lang._('ID') }}</th>
18            <th data-column-id="enabled" data-width="6em" data-type="string" data-formatter="rowtoggle">{{ lang._('Enabled') }}</th>
19            <th data-column-id="email" data-type="string">{{ lang._('Email') }}</th>
20            <th data-column-id="commands" data-width="7em" data-formatter="commands" data-sortable="false">{{ lang._('Commands') }}</th>
21        </tr>
22    </thead>
23    <tbody>
24    </tbody>
25    <tfoot>
26        <tr>
27            <td></td>
28            <td>
29                <button data-action="add" type="button" class="btn btn-xs btn-default"><span class="fa fa-plus"></span></button>
30                <button data-action="deleteSelected" type="button" class="btn btn-xs btn-default"><span class="fa fa-trash-o"></span></button>
31            </td>
32        </tr>
33    </tfoot>
34</table>
35
36
37{{ partial("layout_partials/base_dialog",['fields':formDialogAddress,'id':'DialogAddress','label':lang._('Edit address')])}}

UI controller

The user interface controller sets the template (view) to use and collects the dialog form properties from the xml file defined earlier.
/usr/local/opnsense/mvc/app/controllers/OPNsense/GridExample/IndexController.php

 1namespace OPNsense\GridExample;
 2
 3class IndexController extends \OPNsense\Base\IndexController
 4{
 5    public function indexAction()
 6    {
 7        $this->view->pick('OPNsense/GridExample/index');
 8        $this->view->formDialogAddress = $this->getForm("dialogAddress");
 9    }
10}

Menu and ACL

The sample package on GitHub also contains a menu definition (xml) and ACL (xml), which are similar to the ones explained in the hello world example.
Test drive your app

Now go to http[s]://your.host/ui/gridexample and try it out.
../../_images/grid-test-drive.png

API enable standard services

OPNsense contains a simple wrapper which handles standard service actions like starting and stopping services. For this example, we assume the HelloWorld example is created and the model exists.
Prerequisites

The HelloWorld example forms the basis for this one, please make sure you read and try it first before starting with this one.
Configd actions

Since the example didn’t contain a service, we’re going to extend the configd template first. Edit /usr/local/opnsense/service/conf/actions.d/actions_helloworld.conf and expand with the following sections:

[start]
command:exit 0
parameters:
type:script
message:hello world service start

[stop]
command:exit 0
parameters:
type:script
message:hello world service stop

[restart]
command:exit 0
parameters:
type:script
message:hello world service restart

[reload]
command:exit 0
parameters:
type:script
message:hello world service restart

[status]
command: echo "hello world is running"
parameters:
type:script_output
message:hello world service status

Next restart configd using service configd restart and test these new calls using the following commands

# configctl helloworld start
OK
# configctl helloworld stop
OK
# configctl helloworld status
hello world is running
# configctl helloworld restart
OK

Our template only simulates a service, it doesn’t actually do anything (exit 0).
Update the service controller

Next we change the existing controller to use ApiMutableServiceControllerBase, which links the existing model to the service callouts defined. The testAction used in the HelloWorld example is left out to avoid confusion.
/usr/local/opnsense/mvc/app/controllers/OPNsense/HelloWorld/Api/ServiceController.php

use OPNsense\Base\ApiMutableServiceControllerBase;

class ServiceController extends ApiMutableServiceControllerBase
{
    protected static $internalServiceClass = '\OPNsense\HelloWorld\HelloWorld';
    protected static $internalServiceTemplate = 'OPNsense/HelloWorld';
    protected static $internalServiceEnabled = 'general.enabled';
    protected static $internalServiceName = 'helloworld';

    protected function reconfigureForceRestart()
    {
        return 0;
    }
}

The service above defines the following static variables:

    $internalServiceClass

            reference the model class, which is used to determine if this service is enabled (links the model to the service)

    $internalServiceTemplate

            before starting the service it will call configd to generate configuration data, in this case it would execute the equivalent of configctl template reload OPNsense/HelloWorld on the console

    $internalServiceEnabled

            Which section of the model contains a boolean defining if the service is enabled (general.enabled)

    $internalServiceName

            refers to the action template, where it can find start/stop/restart/status/reload actions (actions_helloworld.conf)

The reconfigureForceRestart overwrite tells the controller if it should always stop the service before trying a start, some services can be signaled to do a reconfigure without stopping.

Tip

When a service may register new interfaces, one could implement the protected method invokeInterfaceRegistration and make it return true, after which the plugin system will detect changes to the interface registrations automatically.
Endpoints

When deploying this controller into the HelloWorld module it would expose the following endpoints

Method
	

Endpoint

POST
	

/api/helloworld/service/stop

POST
	

/api/helloworld/service/start

POST
	

/api/helloworld/service/restart

POST
	

/api/helloworld/service/reconfigure

GET
	

/api/helloworld/service/status


How-tos

    Use the API
    Profiling/Debugging the kernel
    Remote debugging the kernel


Use the API
Overview

All components that are using the full architecture of OPNsense automatically receive API capabilities, for this simple tutorial we use the firmware module but others will function in the same way. API access is part of the local user authentication system, but uses key/secret pairs to separate account information from machine to machine communication. Secrets are not stored on OPNsense and can be downloaded only once, if lost, a new key has to be generated for your application.

A user can have multiple keys, our advice is to create a unique key for every application in use.
Creating keys

API keys are managed in the user manager (system_usermanager.php), go to the user manager page and select a user. Somewhere down the page you will find the API section for this user.

Usermanager add api key.png

Click on the + sign to add a new key. When the key is created, you will receive a (single download) with the credentials in one text file (ini formatted). The contents of this file look like this:

key=w86XNZob/8Oq8aC5r0kbNarNtdpoQU781fyoeaOBQsBwkXUt
secret=XeD26XVrJ5ilAc/EmglCRC+0j2e57tRsjHwFepOseySWLM53pJASeTA3

Code sample (python)

For the python code sample we use the nice “requests” library (http://docs.python-requests.org/en/latest/), which makes HTTP calls very easy.

Before you can start, make sure your OPNsense has a valid SSL certificate (or choose to ignore it for testing purposes by setting verify=False), don’t forget to verify that the selected user may access the firmware page.

The web interface uses the same logic that will be available for the api, in this example we will collect some status information from the firmware module and print it out for the user.

It all starts with creating the request and waiting for the response, all data interaction is using json format, both for the responses as for the request data (when sending POST data).

First step of the example is importing the required libraries, then define the endpoint url and credentials to use and finally fire the (get type) request. As soon as we receive the response, we parse the json string back to a dictionary and print some data depending on the response.

# import libraries
import json
import requests

# define endpoint and credentials
api_key = 'w86XNZob/8Oq8aC5hxh2he+vLN00r0kbNarNtdpoQU781fyoeaOBQsBwkXUt'
api_secret = 'puOyw0Ega3xZXeD26XVrJ5WYFepOseySWLM53pJASeTA3'
url = 'https://192.168.1.1/api/core/firmware/status'

# request data
r = requests.get(url,
                 verify='OPNsense.pem',
                 auth=(api_key, api_secret))

if r.status_code == 200:
    response = json.loads(r.text)

    if response['status'] == 'ok':
        print ('OPNsense can be upgraded')
        print ('download size : %s' % response['download_size'])
        print ('number of packages : %s' % response['updates'])
        if response['upgrade_needs_reboot'] == '1':
            print ('REBOOT REQUIRED')
    elif 'status_msg' in response:
        print (response['status_msg'])
else:
    print ('Connection / Authentication issue, response received:')
    print r.text

Using curl

Simple testing with curl is also possible, the sample below uses the same credentials, but ignores the SSL certificate check (-k) for testing.

curl -k -u "w86XNZob/8Oq8aC5hxh2he+vLN00r0kbNarNtdpoQU781fyoeaOBQsBwkXUt":"puOyw0Ega3xZXeD26XVrJ5WYFepOseySWLM53pJASeTA3" https://192.168.1.1/api/core/firmware/status

And schedule the actual update of all packages using:

curl -XPOST -k -u "w86XNZob/8Oq8aC5hxh2he+vLN00r0kbNarNtdpoQU781fyoeaOBQsBwkXUt":"puOyw0Ega3xZXeD26XVrJ5WYFepOseySWLM53pJASeTA3" https://10.211.55.100/api/core/firmware/update


Profiling/Debugging the kernel
Overview

Kernel development often involves writing code without an IDE. Even if an IDE is used, proper profiling support is often lacking. Luckily, FreeBSD includes DTrace.

Since OPNsense runs on a fork of FreeBSD, DTrace is natively available on the system for developers to use in debugging and profiling. To quote the FreeBSD handbook on DTrace:

“DTrace, also known as Dynamic Tracing, was developed by Sun™ as a tool
for locating performance bottlenecks in production and pre-production
systems. In addition to diagnosing performance problems, DTrace can be used
to help investigate and debug unexpected behavior in both the FreeBSD kernel
and in userland programs.

DTrace is a remarkable profiling tool, with an impressive array of features
for diagnosing system issues. It may also be used to run pre-written scripts
to take advantage of its capabilities. Users can author their own utilities
using the DTrace D Language, allowing them to customize their profiling based
on specific needs.”

We will be looking at setting up DTrace on OPNsense, and running a sample script to perform some useful analysis on kernel space. An example for generating a FlameGraph will also be presented. Keep in mind that user space can also be analyzed using DTrace, but this is beyond the scope of this document.

Although detailed steps for enabling DTrace in a custom kernel are widely available, this document provides an explanation in combination with the use of OPNsense-specific tools. Further resources will be provided at the end of this document.

Note

All generic DTrace concepts, as well as default probe providers are documented here. If you are interested in using DTrace to profile performance issues, we suggest reading the documentation before proceeding. We will not go into too much detail here to prevent cluttering the document and keep it simple and to-the-point.
Enabling DTrace

Make sure the OPNsense/src repository is present on the system and navigate to /usr/src/sys/[ARCHITECTURE, e.g. amd64]/conf and open up GENERIC. Add the following options:

makeoptions     DEBUG=-g                # Will build a debug kernel (using gdb debug symbols)
makeoptions     WITH_CTF=1              # Adds CTF type data to built executables
options         KDTRACE_FRAME           # Ensure frames are compiled in

Note

CTF type data is described here. The idea is to represent the types used in a C program within the executable, allowing users of DTrace to access symbols and function parameters during runtime.

As a best practice, under stock FreeBSD you would save the file under a different name (e.g. DTRACE) and build the kernel by specifying KERNCONF=DTRACE. The opnsense-tools require the name to be GENERIC, so we will leave it as is. It is advisable to create a backup of the original GENERIC file though. Make sure the OPNsense-tools repository is installed and navigate to /usr/tools/config/[VERSION]. Open up SMP and make sure the following line is either removed or commented out:

nomakeoptions DEBUG

Furthermore, should you wish to enable DTrace in Userspace, it is imperative that you also add the following line to /usr/tools/conf/[VERSION]/make.conf

STRIP=
CFLAGS+=-fno-omit-frame-pointer

Now clean and build the new kernel

# make clean-obj,kernel kernel

A kernel package will be available at the following location:

    /usr/local/opnsense/build/[Version]/[Architecture]/sets/kernel*.txz

Install the package using our opnsense-update command:

# opnsense-update -ikfr [version] -l /location/from/

Where [version] is the version part of the kernel package, such as 21.1.a_83
Test the installation

Follow the steps described in the section ‘Getting Started’ here
DTrace program

Although it is possible to instruct DTrace to execute a certain function on the command line (and there are a lot of one-liners for this here), instead we present a D script that measures some statistics on the ixgbe 10GbE driver and shows some interesting capabilities of DTrace in one go. Specifically, it measures the amount of interrupts fired on the packet receive side, as well as the time spent in the relevant functions in nanoseconds. It also measures how many threads on average are waiting to be serviced because another thread is busy.


/* RX threads, retrieved from procstat -a -t, listing thread information for all (kernel) processes */
inline int	qg0 = 100018;
inline int	qg1 = 100019;
inline int 	qg2 = 100020;
inline int	qg3 = 100021;
inline int	qg4 = 100022;
inline int	qg5 = 100023;
inline int	qg6 = 100024;
inline int 	qg7 = 100025;

/* Because of this preprocessor statement, this script should be compiled with -C option */
#define PROBE_PREDICATE 		\
			pid == 0 &&	\
			(tid == qg0 || 	\
			 tid == qg1 || 	\
			 tid == qg2 || 	\
			 tid == qg3 || 	\
			 tid == qg4 || 	\
			 tid == qg5 || 	\
			 tid == qg6 || 	\
			 tid == qg7)	\
					\


#define DRIVER_CHECK self->driver_prefix == "ix"

/********************************************/
/* Iflib rx info & interrupt info */
/********************************************/

struct iflib_intr_info {
	uint64_t fast_intr_ts;
	uint64_t fast_intr_elapsed;
	uint64_t filter_routine_ts;
	uint64_t task_tx_ts;
};

struct iflib_intr_info ii[int];

struct iflib_task_info {
	uint64_t task_rx_ts; 
	uint64_t rxeof_ts;
};

struct iflib_task_info iti[int];

/* RX (and TX) interrupt entry point, will call driver supplied filter */
fbt::iflib_fast_intr:entry
{
	ii[tid].fast_intr_ts = timestamp;
	this->info = ((kernel`iflib_filter_info_t)arg0);
	self->rxq_id = (uint16_t)((kernel`iflib_rxq_t)this->info->ifi_ctx)->ifr_id;
	@intcounts[tid, self->rxq_id, probefunc] = count();

}

fbt::iflib_fast_intr:return
/ii[tid].fast_intr_ts/
{
	@time[tid, self->rxq_id, probefunc] = avg(timestamp - ii[tid].fast_intr_ts);
	@fi_time_min[tid, self->rxq_id, probefunc] = min(timestamp - ii[tid].fast_intr_ts);
	@fi_time_max[tid, self->rxq_id, probefunc] = max(timestamp - ii[tid].fast_intr_ts);
}

/* axgbe driver filter routine */
fbt::axgbe_msix_que:entry, fbt::ixgbe_msix_que:entry
{
	ii[tid].filter_routine_ts = timestamp;	
	@intcounts[tid, self->rxq_id, probefunc] = count();
}

fbt::axgbe_msix_que:return, fbt::ixgbe_msix_que:return
/ii[tid].filter_routine_ts/
{
	@fr_time_avg[tid, self->rxq_id, probefunc] = avg(timestamp - ii[tid].filter_routine_ts);
	@fr_time_min[tid, self->rxq_id, probefunc] = min(timestamp - ii[tid].filter_routine_ts);
	@fr_time_max[tid, self->rxq_id, probefunc] = max(timestamp - ii[tid].filter_routine_ts);
}


/* 
 * at this point, iflib has enqueued the _task_fn_rx / _task_fn_tx function,
 * we could measure some relevant things here.
 * The threads that run the queued functions are all in the range of the threads
 * defined at the top of this file
 * We could also inspect the queue structure to determine the average amount of functions
 * waiting to be serviced, this information could be pulled out of the iflib interrupt handler
 * Also, the thread that runs the queued function is different from the thread that runs the interrupt handler,
 * so query again for the relevant drivers and include it in the probe predicates
 */

char *driver_name[2];


fbt::_task_fn_rx:entry
/PROBE_PREDICATE && (!self->prefix_set)/
{


	/* get taskqueue structure information to determine amount of functions waiting to be serviced */
	this->rxq = ((kernel`iflib_rxq_t)arg0);
	this->grouptask = (struct grouptask)(this->rxq->ifr_task);
	self->gt_name = stringof(this->grouptask.gt_name);
	this->if_ctx = (if_ctx_t)(this->rxq)->ifr_ctx;
	this->dev = (device_t)(this->if_ctx)->ifc_dev;
	this->driver = (driver_t *)(this->dev)->driver;
	driver_name[0] = (const char *)(this->driver)->name;
	driver_name[1] = (const char *)(this->driver)->name + 1;
	self->driver_prefix = stringof(*(driver_name));
	self->prefix_set = 1;

}

fbt::_task_fn_rx:entry
/PROBE_PREDICATE && DRIVER_CHECK/
{
	iti[tid].task_rx_ts = timestamp;
	@_task_fn_rx_count[tid, self->gt_name, probefunc] = count();
}

fbt::_task_fn_rx:return
/PROBE_PREDICATE && iti[tid].task_rx_ts && DRIVER_CHECK/
{
	@task_rx_avg[tid, self->gt_name, probefunc] = avg(timestamp - iti[tid].task_rx_ts);
	@task_rx_min[tid, self->gt_name, probefunc] = min(timestamp - iti[tid].task_rx_ts);
	@task_rx_max[tid, self->gt_name, probefunc] = max(timestamp - iti[tid].task_rx_ts);
}


fbt::iflib_rxeof:entry
/PROBE_PREDICATE && DRIVER_CHECK/
{
	iti[tid].rxeof_ts = timestamp;
	@rxeof_count[tid, self->gt_name, probefunc] = count();

}

fbt::iflib_rxeof:return
/PROBE_PREDICATE && iti[tid].rxeof_ts && DRIVER_CHECK/
{
	@rxeof_avg[tid, self->gt_name, probefunc] = avg(timestamp - iti[tid].rxeof_ts);
	@rxeof_min[tid, self->gt_name, probefunc] = min(timestamp - iti[tid].rxeof_ts);
	@rxeof_max[tid, self->gt_name, probefunc] = max(timestamp - iti[tid].rxeof_ts);

}

fbt::ixgbe_isc_rxd_refill:entry
/PROBE_PREDICATE && DRIVER_CHECK/
{
	this->ts = timestamp;
	@rxd_refill_count[tid, self->gt_name, probefunc] = count();
}

fbt::ixgbe_isc_rxd_refill:return
/PROBE_PREDICATE && this->ts && DRIVER_CHECK/
{
	
	@rxd_refill_avg[tid, self->gt_name, probefunc] = avg(timestamp - this->ts);
	@rxd_refill_min[tid, self->gt_name, probefunc] = min(timestamp - this->ts);
	@rxd_refill_max[tid, self->gt_name, probefunc] = max(timestamp - this->ts);
}


/* notice how the ixgbe driver is missing, this is because of the dtrace compiler optimization - the return probe is missing */
fbt::ixgbe_isc_rxd_available:entry
/PROBE_PREDICATE && DRIVER_CHECK/
{
	this->ts = timestamp;
	@rxd_avail_count[tid, self->gt_name, probefunc] = count();
}

fbt::ixgbe_isc_rxd_available:return
/PROBE_PREDICATE && (this->ts != 0) && DRIVER_CHECK/
{
	@rxd_avail_avg[tid, self->gt_name, probefunc] = avg(timestamp - this->ts);
	@rxd_avail_min[tid, self->gt_name, probefunc] = min(timestamp - this->ts);
	@rxd_avail_max[tid, self->gt_name, probefunc] = max(timestamp - this->ts);
}

fbt::ixgbe_isc_rxd_pkt_get:entry
/PROBE_PREDICATE && DRIVER_CHECK/
{
	this->ts = timestamp;
	@rxd_pkt_get_count[tid, self->gt_name, probefunc] = count();
}

fbt::ixgbe_isc_rxd_pkt_get:return
/PROBE_PREDICATE && (this->ts != 0) && DRIVER_CHECK/
{
	@rxd_pkt_get_avg[tid, self->gt_name, probefunc] = avg(timestamp - this->ts);	
	@rxd_pkt_get_min[tid, self->gt_name, probefunc] = min(timestamp - this->ts);	
	@rxd_pkt_get_max[tid, self->gt_name, probefunc] = max(timestamp - this->ts);	
}


/********************************************/
/* Queue behaviour */
/********************************************/

int qlen[int];

/* enqueue and deqeueue probes to determine the run length of the queues */
sched:::enqueue
/PROBE_PREDICATE && DRIVER_CHECK/
{
	this->q_len = qlen[tid]++;

	@q_len_all_threads_avg[tid] = avg(this->q_len);
	@q_len_all_threads_min[tid] = min(this->q_len);
	@q_len_all_threads_max[tid] = max(this->q_len);
}

sched:::dequeue
/PROBE_PREDICATE && qlen[tid] && DRIVER_CHECK/
{
	qlen[tid]--;

}


END
{
	printf("\n");
	printf("\n");
	printf("\n");
	printf("\n");
	printf("-------INTERRUPTS-------\n");
	printf("\n");
	printf("thread  core               function            count  avg time(ns)  min time  max time  avg time(driver)  min time(driver)  max time(driver)\n");
	printf("------  ----  ---------------------  ---------------  ------------  --------  --------  ----------------  ----------------  ----------------\n");
	printa("%6d  %4d  %21s  %@15d  %@12d  %@8d  %@8d  %@16d  %@16d  %@16d\n", @intcounts, @time, @fi_time_min, @fi_time_max, @fr_time_avg, @fr_time_min, @fr_time_max);
	printf("\n");

	printf("-------DRIVER/IFLIB FUNCTIONS RX-------\n");
	printf("thread  grouptask name                        function  avg time(ns)  min time(ns)  max time(ns)        count\n");
	printf("------  --------------  ------------------------------  ------------  ------------  ------------  -----------\n");
	printa("%6d  %14s  %30s  %@12d  %@12d  %@12d  %@11d\n", @task_rx_avg, @task_rx_min, @task_rx_max, @_task_fn_rx_count);
	printa("%6d  %14s  %30s  %@12d  %@12d  %@12d  %@11d\n", @rxeof_avg, @rxeof_min, @rxeof_max, @rxeof_count);
	printa("%6d  %14s  %30s  %@12d  %@12d  %@12d  %@11d\n", @rxd_refill_avg, @rxd_refill_min, @rxd_refill_max, @rxd_refill_count);
	printa("%6d  %14s  %30s  %@12d  %@12d  %@12d  %@11d\n", @rxd_avail_avg, @rxd_avail_min, @rxd_avail_max, @rxd_avail_count);
	printa("%6d  %14s  %30s  %@12d  %@12d  %@12d  %@11d\n", @rxd_pkt_get_avg, @rxd_pkt_get_min, @rxd_pkt_get_max, @rxd_pkt_get_count);
	printf("\n");


	printf("---------QUEUE BEHAVIOUR---------\n");
	printf("thread  avg run length  min run length  max run length\n");
	printf("------  --------------  --------------  --------------\n");
	printa("%6d  %@14d  %@14d  %@14d\n", @q_len_all_threads_avg, @q_len_all_threads_min, @q_len_all_threads_max);
	printf("\n");
}

The one-line command to pre-process, compile and run the script is:

# dtrace -C -s example.d

The -C option specifies that the standard C preprocessor should evaluate the file, ensuring that the C-specific code like macro definitions are defined.

The output (when pinging the device):
Dtrace Output

Notice how the queue behaviour section shows no output, this is because there is no actual queue behaviour going on. There is simply too little traffic for the kernel to be queueing threads. When stressing the driver, it might look something like this:
Queue behaviour
Flame Graphs

If you run the following command:

# dtrace -n 'uiomove:entry{ @[stack()] = count(); }'

Let it run for a while, and exit using CTRL-C

You will see all stack frames associated with uiomove() that have taken place, aggregated to only unique frames. The number below the individual frame represents the amount of times that particular frame was executed. Although this is nice, it isn’t particulary visually pleasing or helpful in spotting potential bottlenecks.

A senior performance analyst at Netflix, named Brendan Gregg, developed the FlameGraph for use with DTrace (and other profiling tools). The program consists of a set of Perl files that take in the data produced by a command similar to the one we executed, and generate a graph that helps spot ‘hot code paths’. This time however, we will look at the kernel as a whole and sample it in a set interval.

1. Clone the repository and instruct dtrace to sample kernel stacks at a rate of 997 Hertz for 60 seconds:

# dtrace -x stackframes=100 -n 'profile-997 /arg0/ { @[stack()] = count(); } tick-60s { exit(0); }' -o out.kern_stacks

    Collapse the individual lines in the output file by folding it into single lines:

# ./stackcollapse.pl out.kern_stacks > out.kern_folded

Having a separate folded input file allows for grepping functions of interest:

# grep cpuid out.kern_folded | ./flamegraph.pl > cpuid.svg

Note

If you get the message “Command not found”, use the command perl stackcollapse.pl out.kern_stacks > out.kern_folded

    Generate a flame graph:

# ./flamegraph.pl out.kern_folded > kernel.svg

FlameGraph

The output image is an SVG file, enabling interaction within a browser.
Other Resources

Brendan Gregg’s collection of DTrace programs: http://www.brendangregg.com/dtrace.html

Using the right datatypes in DTrace to increase profiling performance: http://dtrace.org/blogs/brendan/2011/11/25/dtrace-variable-types/

FreeBSD DTrace manual page: https://www.freebsd.org/cgi/man.cgi?query=dtrace

FreeBSD DTrace one-liners: https://wiki.freebsd.org/DTrace/One-Liners


Remote debugging the kernel

FreeBSD supports remote debugging using a serial interface. Since most virtual solutions support serial interfaces it can be quite convenient to deploy a kernel and start a debug session on another machine.

The setup assumes two (virtual) machines with a serial (rs232) connection in between.
Configure and build a kernel

Use our toolchain described in detail here and add the following options to your SMP file in /usr/tools/config/[VERSION]/SMP

#nomakeoptions DEBUG
options        GDB                     # Support remote GDB.
makeoptions    DEBUG=-g

Next clean and build a kernel

make clean-obj,kernel kernel

Install the kernel on test vm

With the build finished, we should have a kernel package on the build machine available at the following location:

    /usr/local/opnsense/build/[Version]/[Architecture]/sets/kernel*.txz

Copy this package to the test vm and install it using our opnsense-update command:

opnsense-update -ikfr [version] -l /location/from/

Where [version] is the version part of the kernel package, such as 19.1.2
Configure the test vm

To be able to connect to the test machine using kgdb, you need to make sure some settings are set.

Edit /boot/device.hints and change or add hint.uart.0.flags to the following:

hint.uart.0.flags="0xc0"

Also /boot/loader.conf.local should have a baud-rate configured for the serial device:

comconsole_speed="115200"

Test your setup

Login to the test machine and force a debug session in gdb, using the following commands:

# sysctl debug.kdb.current=gdb
# sysctl debug.kdb.enter=1
db> gdb
Step to enter the remote GDB backend.
db> c (continue)

Then go to the build machine, make sure gdb is installed (pkg install gdb) and go to the directory where the debug symbols are and start a session, ask a backtrace bt and continue normal operation c:

